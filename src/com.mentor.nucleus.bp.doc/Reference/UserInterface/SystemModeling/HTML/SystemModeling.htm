<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<title>System-Level Modeling with Components</title>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:SimSun;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:Webdings;
	panose-1:5 3 1 2 1 5 9 6 7 3;}
@font-face
	{font-family:"\@SimSun";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
h1
	{mso-style-link:"Heading 1 Char";
	margin-right:0in;
	margin-left:0in;
	font-size:18.0pt;
	font-family:"Arial","sans-serif";
	color:black;
	font-weight:normal;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-right:0in;
	margin-left:0in;
	line-height:15.6pt;
	font-size:12.0pt;
	font-family:"Arial","sans-serif";
	color:navy;
	font-weight:bold;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-right:0in;
	margin-bottom:2.4pt;
	margin-left:0in;
	font-size:11.0pt;
	font-family:"Arial","sans-serif";
	color:maroon;
	font-weight:bold;}
h4
	{mso-style-link:"Heading 4 Char";
	margin-top:7.5pt;
	margin-right:7.5pt;
	margin-bottom:2.4pt;
	margin-left:7.5pt;
	font-size:11.0pt;
	font-family:"Arial","sans-serif";
	color:#0176B9;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:navy;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:#0176B9;
	text-decoration:underline;}
p
	{margin:7.5pt;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"Balloon Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:8.0pt;
	font-family:"Tahoma","sans-serif";}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Cambria","serif";
	color:#365F91;
	font-weight:bold;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Cambria","serif";
	color:#4F81BD;
	font-weight:bold;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Cambria","serif";
	color:#4F81BD;
	font-weight:bold;}
span.Heading4Char
	{mso-style-name:"Heading 4 Char";
	mso-style-link:"Heading 4";
	font-family:"Cambria","serif";
	color:#4F81BD;
	font-weight:bold;
	font-style:italic;}
p.preformatted-tpcode, li.preformatted-tpcode, div.preformatted-tpcode
	{mso-style-name:preformatted-tp_code;
	margin-top:15.0pt;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	background:silver;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
p.normalnotoc, li.normalnotoc, div.normalnotoc
	{mso-style-name:normalnotoc;
	margin:7.5pt;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
span.codeChar
	{mso-style-name:"code Char";
	mso-style-link:code;
	font-family:"Courier New";}
p.code, li.code, div.code
	{mso-style-name:code;
	mso-style-link:"code Char";
	margin:7.5pt;
	font-size:11.0pt;
	font-family:"Courier New";}
span.tpcodeChar
	{mso-style-name:"tp_code Char";
	mso-style-link:tp_code;
	font-family:"Courier New";}
p.tpcode, li.tpcode, div.tpcode
	{mso-style-name:tp_code;
	mso-style-link:"tp_code Char";
	margin:7.5pt;
	font-size:10.0pt;
	font-family:"Courier New";}
p.tpinput, li.tpinput, div.tpinput
	{mso-style-name:tp_input;
	margin:7.5pt;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";
	font-weight:bold;}
p.tpui, li.tpui, div.tpui
	{mso-style-name:tp_ui;
	margin:7.5pt;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";
	color:navy;}
p.tpvar, li.tpvar, div.tpvar
	{mso-style-name:tp_var;
	margin:7.5pt;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";
	font-style:italic;}
p.tpfooter, li.tpfooter, div.tpfooter
	{mso-style-name:tp_footer;
	margin:7.5pt;
	text-align:center;
	background:white;
	font-size:9.0pt;
	font-family:"Times New Roman","serif";}
p.sub, li.sub, div.sub
	{mso-style-name:sub;
	margin:7.5pt;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";}
p.sublstbody, li.sublstbody, div.sublstbody
	{mso-style-name:sublstbody;
	margin:7.5pt;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";}
span.tpfile
	{mso-style-name:tp_file;
	color:#990000;
	letter-spacing:1.2pt;}
span.tpnote
	{mso-style-name:tp_note;
	font-weight:bold;}
span.tpmenuarrow
	{mso-style-name:tp_menuarrow;
	font-family:Webdings;
	color:navy;}
span.hypertext
	{mso-style-name:hypertext;}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-link:"Balloon Text";
	font-family:"Tahoma","sans-serif";}
.MsoChpDefault
	{font-size:10.0pt;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;}
div.WordSection1
	{page:WordSection1;}
-->
</style>

<script language="JavaScript"  src="../../../org.eclipse.help/livehelp.js">
</script>
</head>

<body bgcolor=white lang=EN-US link=navy vlink="#0176B9">

<div class=WordSection1>

<h1><a name="_Ref100717464">System-Level Modeling with Components</a></h1>

<p class=MsoNormal>Electronic systems grow smaller yet more complex.  Modeling
with UML has begun to help us model individual modules, or components of larger
systems.  Modeling at the top level is only just beginning.  Using components,
Executable UML defines a means of modeling systems at the highest level in an
executable and testable manner before low-level detail is available. 
Executable system models then serve as executable specification input to teams
developing the behavior of individual system components.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>A component represents any quantity of functionality that
can be interfaced to other components.  A component can be modeled or already <i>realized</i>
(pre-existing).  A component can be viewed as a black box of functionality with
a set of published interfaces.  The black box can be accessed or viewed only
from the outside.  The view from the outside consists only of the interfaces.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Other components cannot &quot;see&quot; inside the component
but can only send and receive information to and from it through its
interfaces.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Modeled components are <i>formalized</i> to xtUML domain
models.  The internal functionality of a modeled component consists of xtUML
modeling artifacts such as class diagrams, state machines, classes,
associations, attributes, etc.  Before being formalized to an xtUML domain, a
component is only the outside of the black box and its interfaces.  Upon
formalization, the internals of the component can now be defined and edited by
the user.  Of course, domains do not have to be formalized to a component. 
They may exist as independent entities in the project.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Formalizing a component in BridgePoint is an operation
performed on the component from the modeling user interface.  It also is possible
to un-formalize a component.  This operation will disassociate the component
and the underlying xtUML modeled domain.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Realized components represent functionality that has been
&quot;realized&quot; in some way other than with an internal xtUML model.  Most
often realized components represent legacy software modules or libraries that
are to be integrated with modeled components.  Realized components have
interfaces just like modeled components have interfaces.  The interfaces define
the API of the realized functionality.</p>

<h2>Component Packages</h2>

<p class=MsoNormal>Components are collated in UML packages.  Interfaces also
are organized in packages.  In fact, all BridgePoint xtUML diagrams are
organized in packages.  Packages are a diagrammatic way to group modeling
elements together and manage their hierarchy.  Packages can be nested. 
Component packages may contain other component packages and/or interface
packages.  This allows a level of organizational association between components
and their interfaces.</p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt;
font-family:"Courier New"'>&nbsp;</span></p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt;
font-family:"Courier New"'><img width=775 height=613 id="Picture 1"
src="SystemModeling_files/image001.jpg" alt="Description: nested_component"></span></p>

<p class=MsoNormal><b>Figure 1</b></p>

<h3>Imported Components<span style='font-size:10.0pt;font-family:"Courier New"'> 
</span></h3>

<p class=MsoNormal>Components can be imported onto component diagrams.  An
imported component is a component that has been defined on one component
diagram and is being used on another diagram.  Importing a component allows the
analyst to reuse components.  Some developers may choose to define components
in one diagram but show their interfacing/wiring on a separate diagram.  This
is supported with the importing of components.  A similar concept is used on
class diagrams to allow users to import classes into one class diagram from
other class diagrams (subsystems).  In Figure 1, the <span class=codeChar><span
style='font-size:11.0pt'>GPS</span></span> component is imported from the
component package named <span class=codeChar><span style='font-size:11.0pt'>GPS
Package</span></span>.</p>

<h3>Nested Components</h3>

<p class=MsoNormal>Components can be nested within other components.  Component
nesting provides a hierarchical containment of components within components. 
Component nesting provides a way to functionally decompose a complex system
into a collection of simpler parts, components.  The components nested inside
of another component must have interfaces to satisfy all of the interface
requirements of the outer component.  In Figure 1, <span class=codeChar><span
style='font-size:11.0pt'>Satellite Alpha IF</span></span> is an interface
package defined inside the component <span class=codeChar><span
style='font-size:11.0pt'>Satellite Alpha</span></span>.</p>

<h2>Interfaces</h2>

<p class=MsoNormal>An interface is a declaration of a collection of synchronous
and asynchronous messages that can be passed between components.  Interfaces
are separate from components.  Modeling them separately allows interfaces to be
defined and managed independently of the components that implement these
interfaces.  The separation also allows more than one component to implement
(require or provide) any particular interface.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Interfaces are declared in interface diagrams.  An interface
diagram depicts interfaces in the standard UML box format with the messages
contained inside the interface. A message is the declaration of an individual
type of interaction between components.  It provides the signature of the
interaction including return type and the types of all parameters carried in
the message.  Messages can be asynchronous or synchronous.  Asynchronous
messages are called <i>signals</i>.  Synchronous messages are called <i>operations</i>. 
Often operations on an interface will be called <i>interface operations</i>
rather than simply operations to distinguish the term from uses elsewhere in
UML.  Messages in the interface are grouped graphically by
&quot;synchronicity&quot;.  Asynchronous signals are in one compartment in the
box; synchronous interface operations are grouped in a separate compartment.</p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt;
font-family:"Courier New"'>&nbsp;</span></p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt;
font-family:"Courier New"'><img width=787 height=497 id="Picture 2"
src="SystemModeling_files/image002.jpg" alt="Description: component_interface"></span></p>

<p class=MsoNormal><b>Figure 2</b></p>

<h3>Interface Packages<span style='font-size:10.0pt;font-family:"Courier New"'>  
</span></h3>

<p class=MsoNormal>Multiple interfaces can be organized into packages.  Packages
do not reflect the functionality of interfaces but simply provide a way to
group them and manage them in convenient, logical collections.  In Figure 2,
the <span class=codeChar><span style='font-size:11.0pt'>getIdentity</span></span>
and <span class=codeChar><span style='font-size:11.0pt'>getLocation</span></span>
interfaces are part of the <span class=codeChar><span style='font-size:11.0pt'>Satellite
Communication</span></span> interface package.</p>

<h3>Provided and Required Interfaces</h3>

<p class=MsoNormal>Components can <i>provide</i> interfaces and <i>require</i>
interfaces.  A <i>provided interface</i> is an interface through which the
component is able to provide services to other components.  It provides the
services by passing messages across the provided interface to and from the
client who requires the interface.  Graphically a provided interface is
depicted as a &quot;lollipop&quot; (a stick with a ball on it) jutting out from
the component.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>A <i>required interface</i> is an interface through which a
component is able to demand services from another component.  It demands these
services by passing messages across the required interface to and from the
server who provides the interface.  Graphically a required interface is
depicted as a stick with a &quot;cup&quot; on one end.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Ultimately a required interface is wired to a provided
interface.  This connects the components across the interface.  On the
component diagram, the required interface (cup) and the provided interface
(ball) will join together and bind. Any number of components can provide and/or
supply a particular named interface.</p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt;
font-family:"Courier New"'>&nbsp;</span></p>

<p class=MsoNormal>Going back to Figure 1, we see the four pairs of wired
interfaces.  For example the <span class=codeChar><span style='font-size:11.0pt'>Location
Module </span></span>provision of the <span class=codeChar><span
style='font-size:11.0pt'>getLocation</span></span> interface is wired to the <span
class=codeChar><span style='font-size:11.0pt'>Diagnostics</span></span> requirement
of the same interface.</p>

<h3>Informal Interfaces</h3>

<p class=MsoNormal>The BridgePoint user interface supplies a glyph on the
component diagram canvas to add provided interfaces and to add required
interfaces to components.  When a provided interface or a required interface is
first added to a component, it is not named and not formalized.  At this point
the provided or required interface is not named, is informal and contains no
messages.  By renaming it, the provided or required interface can be given an
informal name.</p>

<h3>Formal Provided and Required Interfaces</h3>

<p class=MsoNormal>Required interfaces and provided interfaces are formalized
to interfaces declared in interface diagrams.  Formalizing an interface
establishes the fact that the selected component requires or provides the named
interface. This further establishes that the exact set of messages declared in
the interface (on the interface diagram) are required or provided by the
selected component.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Some developers will build component diagrams first.  They
may model informal required and provided interfaces and wire the components
together with them.  Then, they will declare the details of the interfaces and
formalize the wired interfaces on the component diagrams to the newly defined
interfaces from their interface diagrams.  Other developers will carefully
craft interfaces first.  They will define all the messages that can be passed
between components.  Then, they will build component diagrams and wire them
with formalized provided and required interfaces.  Both approaches are
supported in BridgePoint.</p>

<h3>Ports</h3>

<p class=MsoNormal>A port specifies a distinct interaction point between a
component and its outside environment or between the component and its internal
subordinate components.  A port has a name and is associated with one of the
provided or required interfaces of the component.  In Figure 3 below, there are
five ports.  Each is represented by a square box on the boundary of the
component and is associated with an interface.  The port names are not shown on
the diagram to avoid clutter.</p>

<h3>Delegations</h3>

<p class=MsoNormal>When components are nested, the internally nested components
must together provide and require a superset of the interfaces of the parent
component.  A delegation denotes the mapping of required/provided interfaces of
the parent component to the required/provided interfaces of the nested
components.  The mapping is denoted with an arrow connecting the nested
interface to the parent component interface.  There are 3 delegations shown in
Figure 3.  For example, the <span class=codeChar><span style='font-size:11.0pt'>Ephemeris</span></span>
nested component requires the <span class=codeChar><span style='font-size:11.0pt'>getIdentity</span></span>
interface that is required by the container component <span class=codeChar><span
style='font-size:11.0pt'>Location Module</span></span>.</p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt;
font-family:"Courier New"'>&nbsp;</span></p>

<p class=MsoNormal style='text-autospace:none'><span style='font-size:10.0pt;
font-family:"Courier New"'><img width=783 height=598 id="Picture 3"
src="SystemModeling_files/image003.jpg" alt="Description: portsdelegation2"></span></p>

<p class=MsoNormal><b>Figure 3</b></p>

<h2>Handling Inter-Component Messaging</h2>

<h3>Where to Begin</h3>

<p class=MsoNormal>This section describes how to map messages in a modeled
domain.  Please see the subsection “How/Where Realized Domains Fit” below for
more information about non-modeled domains.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>The first step to handling inter-component messages
(operations and signals) is to formalize a component to a modeled xtUML
domain.  The domain provides the concrete implementation that the rest of the
world simply sees as the component “black box”.  The next step is to formalize
a provided interface of this component to the appropriate interface.</p>

<h3>Handling Asynchronous Messages (Signals)</h3>

<p class=MsoNormal>Since instance state machines require resolution to an instance,
which is not possible at the domain boundary, signals may only be assigned to
class state machines.  Therefore, the next step in handling an interface signal
is to which class state machine in the model will receive the signal.  Once the
proper class state machine is determined, identify a transition in the state
machine to assign the signal to.   Use the context menu of the transition to
launch the <span class=codeChar><span style='font-size:11.0pt'>Assign Signal…</span></span>
wizard (Figure 4).</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><img width=785 height=631 id="Picture 4"
src="SystemModeling_files/image004.jpg" alt="Description: Assign Signal"></p>

<p class=MsoNormal><b>Figure 4</b></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>A wizard will appear with a dropdown list.  Select from the
list of interfaces referred to on the formalized model boundary. Once an
interface is selected, select from the dropdown list that shows the list of
currently unassigned signals declared on that interface.  Assignment of the
same signal to multiple transitions of a single class state machine is
supported.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>You may use the <span class=codeChar><span style='font-size:
11.0pt'>param</span></span> keyword to access the data carried as a signal
parameter. Where events and signals are mixed on transitions into the same
state, argument values with the same name must also match in terms of the
argument type.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>If you make a mistake, or decide the signal is better
handled by another transition, you can use the context menu <span
class=codeChar><span style='font-size:11.0pt'>Remove Signal</span></span> menu
entry to revert the transition to be unassigned.</p>

<h3>Alternative Method - Handling Interface Messages with OAL</h3>

<p class=MsoNormal>The functionality of interface messages can alternatively be
defined using OAL.  This works for both interface operations and signals.  In
this case, simply expand the interface reference under the associated component
port.  You will see all the interface’s messages listed underneath (Figure 5).
Each one can have custom OAL added to its activity.  The OAL here is stored
with the port and only applies to this port’s usage of the interface.  Note,
the exact same interface messages will have entirely different activity
implementations for a different port’s provision or requirement of the same
interface.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><img width=784 height=587 id="Picture 5"
src="SystemModeling_files/image005.jpg" alt="Description: OAL in interface"></p>

<p class=MsoNormal><b>Figure 5</b></p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>If an interface signal is assigned to a class state machine,
any OAL that existed in the signal activity will be stored away behind the
scenes.  It will not run when the signal is used in the state machine.  It
will, however, be used again if the user removes the signal from the class
state machine.</p>

<h2>A Different Way to Model</h2>

<h3>What happened to domains? How/where modeled domains fit.</h3>

<p class=MsoNormal>The UML component provides the syntax and semantics needed
to package xtUML domain models into clearly interfaced modules.  The xtUML
domain model is used to define the internal behavior of the component.  On the
component and interface diagrams, the external view of a domain can be
declared.  By formalizing a component to a domain model, the user is
establishing that the internal behavior of the component is defined by the
xtUML artifacts (classes, operations, state machines, etc) of the xtUML domain
model.</p>

<h3>How/Where Realized Domains Fit</h3>

<p class=MsoNormal>The UML component also provides the syntax and semantics
needed to package realized (non-modeled) functionality into clearly interfaced
modules.  The component works equally well for modeled and non-modeled
functionality.  Non-modeled components declare the interaction of the
non-modeled component with the other components in the system.  The internal
functionality of the non-modeled component is assumed to be provided by legacy
code, off-the-shelf libraries or some means other than a locally defined xtUML
model.</p>

<h3>The Deprecating Role of External Entities</h3>

<p class=MsoNormal>BridgePoint external entities (EEs) historically have
defined the interfacing to non-modeled functionality.  Although external
entities will continue to work as they do in version 1.4 of BridgePoint, their
functionality is effectively superceded by components and interfaces.</p>

<h3>The Reduced Role of Domain Functions</h3>

<p class=MsoNormal>BridgePoint domain functions historically have defined the
externally supplied synchronous application interface to an xtUML modeled
domain.  Domain functions also provide a form of domain-global processing. 
Because domain functions are accessible from inside a domain model as well as
outside, they can serve as a place to package domain-level processing
utilities.  This latter use of domain functions is unchanged and completely
valid.</p>

<p class=MsoNormal>The former functionality of providing externally visible
synchronous interfacing is effectively superceded by components and interfaces.</p>

<p class=MsoNormal style='text-autospace:none'>  </p>

</div>

</body>

</html>
