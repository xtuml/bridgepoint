.//=====================================================================
.//
.// File:      $RCSfile$
.// Version:   $Revision$
.// Modified:  $Date$
.//
.// (c) Copyright 2006-2014 by Mentor Graphics Corp. All rights reserved.
.//
.//=======================================================================
.// Licensed under the Apache License, Version 2.0 (the "License"); you may not
.// use this file except in compliance with the License.  You may obtain a copy
.// of the License at
.//
.//      http://www.apache.org/licenses/LICENSE-2.0
.//
.// Unless required by applicable law or agreed to in writing, software
.// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
.// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
.// License for the specific language governing permissions and limitations under
.// the License.
.//=======================================================================
.//
.// This file is responsible for creating the SessionExplorerView View
.// It is generated so that filters are defined for each tree
.// node, giving the user the ultimate flexibility over what
.// they want to see.
.//
.function create_SessionExplorer_view
  .param string path
  .param string plugin_name
  .//
  .assign viewer_name = "SessionExplorerView"
  .assign attr_result = viewer_name  
package org.xtuml.bp.ui.session.views;
//======================================================================
//
// File: ${path}/${viewer_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      $$Revision$$
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp. All rights reserved.
//
//=======================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
// License for the specific language governing permissions and limitations under
// the License.
//=======================================================================
//
// This class is the main entry point for the SessionExplorerView View.
// It is responsible for building the presentation to the user and
// for provideing the interface to the Eclipse infrastructure.
//
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Platform;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.GroupMarker;
import org.eclipse.jface.action.IMenuListener;
import org.eclipse.jface.action.IMenuManager;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.viewers.DecoratingLabelProvider;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.IOpenListener;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.OpenEvent;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerFilter;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IPartListener;
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchActionConstants;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.actions.ExportResourcesAction;
import org.eclipse.ui.actions.ImportResourcesAction;
import org.eclipse.ui.actions.NewWizardMenu;
import org.eclipse.ui.actions.RefreshAction;
import org.eclipse.ui.part.ViewPart;
import org.eclipse.ui.views.framelist.BackAction;
import org.eclipse.ui.views.framelist.ForwardAction;
import org.eclipse.ui.views.framelist.FrameList;
import org.eclipse.ui.views.framelist.TreeViewerFrameSource;
import org.eclipse.ui.views.framelist.UpAction;
import org.eclipse.ui.views.properties.IPropertySheetPage;
import org.eclipse.ui.views.properties.PropertySheetPage;
import org.osgi.framework.Bundle;

import org.xtuml.bp.core.*;
import org.xtuml.bp.core.common.*;
import org.xtuml.bp.core.ui.DeleteAction;
import org.xtuml.bp.core.ui.RenameAction;
import org.xtuml.bp.core.ui.Selection;
import org.xtuml.bp.core.util.EditorUtil;
import org.xtuml.bp.core.util.UIUtil;

import org.xtuml.bp.ui.properties.BridgepointPropertySheetPage;
import org.xtuml.bp.ui.properties.ModelPropertySourceProvider;
import org.xtuml.bp.ui.session.ISessionExplorerHelpContextIds;
import org.xtuml.bp.ui.session.SessionExplorerContentProvider;
import org.xtuml.bp.ui.session.SessionExplorerFiltersContentProvider;
import org.xtuml.bp.ui.session.SessionExplorerLabelProvider;
import org.xtuml.bp.ui.session.SessionExplorerTreeViewer;
import org.xtuml.bp.ui.session.actions.FilterSelectionAction;

/**
 * SessionExplorerView allows the user to navigate the BridgePoint
 * metamodel. It provides a tree view analogous to that provided
 * by the Java Package Explorer.
 * 
 * @see ViewPart
 */
public class ${viewer_name} extends ViewPart {
  private static final String COLLAPSE = "Collapse All";
  private static final String OPEN = "open";
  private static final String HIDE_STATICS = "Hide Static Members";
  .select many tree_nodes from instances of T_TNS
  .for each node in tree_nodes 
  private static final String HIDE_$U_{node.CategoryName} = "Hide ${node.CategoryName}";
  .end for
  private FrameList frames;
  protected SessionExplorerTreeViewer treeViewer;
  protected SessionExplorerLabelProvider labelProvider;
  protected MenuManager menuManager;
  protected Action collapseAll, linkWithEditor;
  protected Action back, fwd, up;
  protected Action cut, copy, paste;
  protected Action open, delete, rename; 
  protected Action fileImport, fileExport;
  protected Action treeRefresh;
  protected Action hideStatics;
  protected Action\
  .for each node in tree_nodes 
 hide$r{node.CategoryName}\
    .if (not_last tree_nodes)
,\
    .else
;
    .end if
  .end for
  protected FilterSelectionAction filters;
  protected ViewerFilter filterStatics;
  protected ViewerFilter\
  .for each node in tree_nodes 
 filter$r{node.CategoryName}\
    .if (not_last tree_nodes)
,\
    .else
;
    .end if
  .end for

  private IModelChangeListener m_modelChangeListener;
  private ITransactionListener m_transactionListener;
  private ISelectionChangedListener m_selChangedListener;
  private IPartListener m_partListener;
  private static SessionExplorerView instance = null;


    private static Selection selection = Selection.getInstance();
    
  /**
   * The constructor.
   */
  public ${viewer_name}() {
    instance = this;
  }
  /**
   * Returns the tree viewer for the SessionExplorerView window
   */
  public SessionExplorerTreeViewer getTreeViewer() {
    return treeViewer;
  }
  
  public static SessionExplorerView instance() {
    if (instance == null) {
      new SessionExplorerView();
    }
    return instance;
  }
  /*
   * @see IWorkbenchPart#createPartControl(Composite)
   */
  public void createPartControl(Composite parent) {
    // Create the view's layout
    FillLayout layout = new FillLayout();
    parent.setLayout(layout);
    treeViewer = new SessionExplorerTreeViewer(parent);
    treeViewer.setContentProvider(new SessionExplorerContentProvider());
    labelProvider = new SessionExplorerLabelProvider();
    treeViewer.setLabelProvider(labelProvider);
    treeViewer.setUseHashlookup(true);
    // Create menu, toolbar and filters.
    createActions();
    createMenus();
    createToolbar();
    createFilters();
    hookListeners();
    initLabelProvider(treeViewer);
	treeViewer.setInput(Ooaofooa.getDefaultInstance());
	  // disable until non-instance data is not removable
	  //
    // getViewSite().getActionBars().setGlobalActionHandler(
    //   ActionFactory.DELETE.getId(),
    //   delete);
    // getViewSite().getActionBars().setGlobalActionHandler(
    //   ActionFactory.RENAME.getId(),
    //   rename);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.COPY.getId(),
      copy);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.CUT.getId(),
      cut);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.PASTE.getId(),
      paste);
    // Set help for the view 
    PlatformUI.getWorkbench().getHelpSystem().setHelp(treeViewer.getControl(), ISessionExplorerHelpContextIds.SessionExplorerViewId);
  }
  /**
   * Hook up all the listeners needed by SessionExplorerView
   */    
  protected void hookListeners() {
		m_partListener = new IPartListener() {

			public void partActivated(IWorkbenchPart part) {
				// update the system selection if the part
				// activated is an instance of this class
				if (part instanceof ${viewer_name})
						  if(!getTreeViewer().getTree().isDisposed()) {
						// if link with editor is set the selection will
						// already by up to date, otherwise set the current
						// selection to that of this viewers
						if (!linkWithEditor.isChecked()) {
							selection.setSelection(getTreeViewer().getSelection());
							}
						}
					}

			public void partDeactivated(IWorkbenchPart part) {}

			public void partBroughtToTop(IWorkbenchPart part) {}

			public void partClosed(IWorkbenchPart part) {}

			public void partOpened(IWorkbenchPart part) {}

			};
		getSite().getPage().addPartListener(m_partListener);

    treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
        // Transfer the selection to the model
        selection.setSelection(event.getSelection());
      }
    });
    m_selChangedListener = new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
        if (!getTreeViewer().getTree().isDisposed()) {
          if (linkWithEditor.isChecked()){
            // transfer the selection to the tree, but avoid having the tree 
            // viewer report its selection change to its listeners, as if what the 
            // model is reporting as selected is not contained in the tree
            // (such as when a connector is selected), we don't want the
            // tree's newly empty selection being propagated back to the model 
            // by the treeview-listener, above; see issue 453 for more context
            IStructuredSelection selection = (IStructuredSelection)event.getSelection();
            setTreeSelection(getTreeViewer(), selection);
          }
        }
      }
    };
    selection.addSelectionChangedListener(m_selChangedListener);
    m_modelChangeListener = new ModelChangeAdapter() {
		public void modelElementLoaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				SessionExplorerTreeViewer viewer = getTreeViewer();
				Object parent = ((SessionExplorerContentProvider) viewer.getContentProvider()).getParent(modelElement);
				UIUtil.refreshViewer(viewer, parent);
			}
		}
		public void modelElementUnloaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				SessionExplorerTreeViewer viewer = getTreeViewer();
				Object parent = ((SessionExplorerContentProvider) viewer.getContentProvider()).getParent(modelElement);
				UIUtil.refreshViewer(viewer, parent);
			}
		}
    };
	m_transactionListener = new ITransactionListener() {
			@Override
			public void transactionCancelled(Transaction transaction) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void transactionEnded(Transaction transaction) {
				PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
					
					@Override
					public void run() {
						getTreeViewer().refresh();	
					}
				});
			}

			@Override
			public void transactionStarted(Transaction transaction) {
				// TODO Auto-generated method stub
				
			}
		};
	TransactionManager.getSingleton().addTransactionListener(m_transactionListener);
    treeViewer.addOpenListener(new IOpenListener() {
      public void open(OpenEvent event) {
        handleOpen();
      }
    });
  }
  private static void setTreeSelection(SessionExplorerTreeViewer tv, IStructuredSelection sel) {
    tv.setSelectionToWidget(sel, true);

    // scroll to reveal all elements of the new selection
    for (Iterator iterator = sel.iterator(); iterator.hasNext();) {
      Object element = iterator.next();
      tv.reveal(element);
    }
  }
  public static final boolean classInTree( Object o )
  {
  .// declare two empty inst_ref_set<O_OBJ>'s
  .select many all_referenced_class_set from instances of O_OBJ where (selected.Name == "-1" )
  .assign empty_class_set = all_referenced_class_set
  .//
  .for each node in tree_nodes 
    .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .assign all_referenced_class_set = all_referenced_class_set | class
  .end for
  .//
  .// add any classes that are only called out in T_TNS.NamingAttributeRelChain
  .//
  .for each node in tree_nodes
    .invoke arcc = add_rel_chain_classes( empty_class_set, node.NamingAttributeRelChain )
    .assign all_referenced_class_set = all_referenced_class_set | arcc.class_set
  .end for
  .//
  .// now do the same thing for T_TPS.ParentChildRelChain
  .//
  .select many parent_nodes from instances of T_TPS
  .for each parent in parent_nodes 
    .invoke arcc = add_rel_chain_classes( empty_class_set, parent.ParentChildRelChain )
    .assign all_referenced_class_set = all_referenced_class_set | arcc.class_set
  .end for
  .//
  .// special case classes
  .select any class from instances of O_OBJ where (selected.Key_Lett == "O_RATTR")
  .assign all_referenced_class_set = all_referenced_class_set | class
  .select any class from instances of O_OBJ where (selected.Key_Lett == "O_REF")
  .assign all_referenced_class_set = all_referenced_class_set | class
  .//
  .for each class in all_referenced_class_set 
    .invoke cn = get_class_name( class )
    if ( o instanceof ${cn.body} ) return true;
  .end for
    return false;
  }
  /**
   * Create the Actions provided by SessionExplorerView
   */
  protected void createActions() {
    frames = new FrameList(new TreeViewerFrameSource(getTreeViewer()));
    back = new BackAction(frames) {
      public void run() {
      }
    };
    fwd = new ForwardAction(frames) {
      public void run() {
      }
    };
    up = new UpAction(frames) {
      public void run() {
      }
    };
    collapseAll = new Action(COLLAPSE) {
      public void run() {
        getTreeViewer().collapseAll();
      }
    };
    collapseAll.setToolTipText(COLLAPSE);
    collapseAll.setImageDescriptor(CorePlugin.getImageDescriptor("collapseall.gif")); //$$NON-NLS-1$$
    PlatformUI.getWorkbench().getHelpSystem().setHelp(collapseAll, ISessionExplorerHelpContextIds.COLLAPSE_ALL_ACTION);
    linkWithEditor = new Action(IWorkbenchActionConstants.SHOW_IN) {
      public void run() {
        IStructuredSelection selection = (IStructuredSelection)Selection.getInstance().getSelection();
        getTreeViewer().setSelection(selection);
        for (Iterator iterator = selection.iterator(); iterator.hasNext();) {
          Object element = iterator.next();
          getTreeViewer().reveal(element);
        }
      }
    };
    linkWithEditor.setChecked(false);
    linkWithEditor.setText("Link With Editor");
    linkWithEditor.setToolTipText("Link with Editor");
    linkWithEditor.setImageDescriptor(CorePlugin.getImageDescriptor("synced.gif")); //$$NON-NLS-1$$
    // 'New' is provided as a sub-menu only. See 'createMenus'
    open = new Action(OPEN){
      public void run(){
        handleOpen();
      }
    };
    open.setText("Open");
    open.setToolTipText("Open this model Element");
    // 'Open With' is provided as a sub-menu only. See 'createMenus'
	cut = new Action(ActionFactory.CUT.getId()) {
      public void run() {
      }
	};
    cut.setText("Cut");
    cut.setToolTipText("Cut this model Element to the clipboard");
    cut.setImageDescriptor(CorePlugin.getImageDescriptor("cut_edit.gif")); //$$NON-NLS-1$$
    cut.setEnabled(false); // Retargetable Actions work removes this line
    copy = new Action(ActionFactory.COPY.getId()) {
      public void run() {
      }
    };
    copy.setText("Copy");
    copy.setToolTipText("Copy this model Element to the clipboard");
    copy.setImageDescriptor(CorePlugin.getImageDescriptor("copy_edit.gif")); //$$NON-NLS-1$$
    copy.setEnabled(false); // Retargetable Actions work removes this line
    paste = new Action(ActionFactory.PASTE.getId()) {
      public void run() {
      }
    };
    paste.setText("Paste");
    paste.setToolTipText("Paste from the clipboard");
    paste.setImageDescriptor(CorePlugin
        ..getImageDescriptor("paste_edit.gif")); //$$NON-NLS-1$$
    paste.setEnabled(false); // Retargetable Actions work removes this line
    //
    // Delete and Rename are retargetable actions defined by core.
    //
    delete = CorePlugin.getDeleteAction();
    rename = CorePlugin.getRenameAction(treeViewer);
    //
    fileImport = new Action(ActionFactory.IMPORT.getId()){
      public void run(){
		ImportResourcesAction ira = new ImportResourcesAction(
		    CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow());
		ira.run();
      }
    };
    fileImport.setText("Import...");
    fileImport.setToolTipText("Import a BridgePoint file");
    fileImport.setImageDescriptor(CorePlugin.getImageDescriptor("import_wiz.gif")); //$$NON-NLS-1$$
    fileExport = new Action(ActionFactory.EXPORT.getId()){
      public void run(){
		ExportResourcesAction era = new ExportResourcesAction(
		    CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow());
		era.run();
      }
    };
    fileExport.setText("Export...");
    fileExport.setToolTipText("Export a BridgePoint file");
    fileExport.setImageDescriptor(CorePlugin.getImageDescriptor("export_wiz.gif")); //$$NON-NLS-1$$
    hideStatics = new Action(HIDE_STATICS) {
      public void run() {
        updateFilter(hideStatics);
      }
    };
	treeRefresh = new Action(ActionFactory.REFRESH.getId()) {
		public void run() {
			RefreshAction ra = new RefreshAction(
				CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getShell());
			ra.run();
			getTreeViewer().refresh();
		}
	};
	treeRefresh.setText("Refresh");
	treeRefresh.setToolTipText("Refresh the tree");
	treeRefresh.setImageDescriptor(
		CorePlugin.getImageDescriptor("refresh.gif")); //$$NON-NLS-1$$
	treeRefresh.setAccelerator(SWT.F5);
	treeRefresh.setActionDefinitionId("org.eclipse.ui.file.refresh"); //$$NON-NLS-1$$
	getSite().getKeyBindingService().registerAction(treeRefresh);

    hideStatics.setChecked(false);
    hideStatics.setToolTipText(HIDE_STATICS);
  .for each node in tree_nodes
    hide$r{node.CategoryName} = new Action(HIDE_$U_{node.CategoryName}) {
      public void run() {
        updateFilter(hide$r{node.CategoryName});
      }
    };
    hide$r{node.CategoryName}.setChecked(false);
    hide$r{node.CategoryName}.setToolTipText(HIDE_$U_{node.CategoryName});
  .end for
    filters = new FilterSelectionAction(this, "Filters...");
    filters.setImageDescriptor(CorePlugin.getImageDescriptor("filter_ps.gif")); //$$NON-NLS-1$$
  }
  /**
   * Create the menus for the SessionExplorerView
   */  
  protected void createMenus() {
    // Context Menu
    MenuManager menuManager = new MenuManager("#PopupMenu"); //$$NON-NLS-1$$
    menuManager.setRemoveAllWhenShown(true);
    final MenuManager createMenuManager = new MenuManager("Ne&w", "org.xtuml.bp.ui.newroot"); //$$NON-NLS-2$$
    final MenuManager openMenuManager = new MenuManager("Open Wit&h", "org.xtuml.bp.ui.openroot"); //$$NON-NLS-2$$
	final MenuManager classesMenu = new MenuManager("Classes", "org.xtuml.bp.ui.classroot"); //$$NON-NLS-2$$
	final MenuManager componentsMenu = new MenuManager("Components", "org.xtuml.bp.ui.componentroot"); //$$NON-NLS-2$$
	final MenuManager exceptionMenu = new MenuManager("Exceptions", "org.xtuml.bp.ui.exceptionroot"); //$$NON-NLS-2$$
	final MenuManager externalMenu = new MenuManager("External", "org.xtuml.bp.ui.externalroot"); //$$NON-NLS-2$$
	final MenuManager interactionMenu = new MenuManager("Interaction", "org.xtuml.bp.ui.interactionroot");//$$NON-NLS-2$$
	final MenuManager activityMenu = new MenuManager("Activity", "org.xtuml.bp.ui.activityroot"); //$$NON-NLS-2$$
	final MenuManager typesMenu = new MenuManager("Types", "org.xtuml.bp.ui.typeroot"); //$$NON-NLS-2$$
	final MenuManager useCaseMenu = new MenuManager("Use Case", "org.xtuml.bp.ui.usecaseroot"); //$$NON-NLS-2$$
    
    menuManager.addMenuListener(new IMenuListener() {
      public void menuAboutToShow(IMenuManager mgr) {
        mgr.add(createMenuManager);
        createMenuManager.removeAll();
        createMenuManager.add(new GroupMarker("org.xtuml.bp.ui.newmenu")); //$$NON-NLS-1$$
        
        createMenuManager.add(activityMenu);
		activityMenu.removeAll();
		activityMenu.add(new GroupMarker("org.xtuml.bp.ui.newactivitymenu") );

		createMenuManager.add(classesMenu);
		classesMenu.removeAll();
		classesMenu.add(new GroupMarker("org.xtuml.bp.ui.newclassmenu") );

		createMenuManager.add(componentsMenu);
		componentsMenu.removeAll();
		componentsMenu.add(new GroupMarker("org.xtuml.bp.ui.newcomponentmenu") );

		createMenuManager.add(exceptionMenu);
		exceptionMenu.removeAll();
		exceptionMenu.add(new GroupMarker("org.xtuml.bp.ui.newexternalmenu") );

		createMenuManager.add(externalMenu);
		externalMenu.removeAll();
		externalMenu.add(new GroupMarker("org.xtuml.bp.ui.newexternalmenu") );

		createMenuManager.add(interactionMenu);
		interactionMenu.removeAll();
		interactionMenu.add(new GroupMarker("org.xtuml.bp.ui.newinteractionmenu") );

		createMenuManager.add(typesMenu);
		typesMenu.removeAll();
		typesMenu.add(new GroupMarker("org.xtuml.bp.ui.newtypemenu") );

		createMenuManager.add(useCaseMenu);
		useCaseMenu.removeAll();
		useCaseMenu.add(new GroupMarker("org.xtuml.bp.ui.newusecasemenu") );
        
        createMenuManager.add(new NewWizardMenu(getSite().getWorkbenchWindow()));
        mgr.add(open);
        mgr.add(openMenuManager);
        openMenuManager.removeAll();
        openMenuManager.add(new GroupMarker("org.xtuml.bp.ui.openmenu")); //$$NON-NLS-1$$
        mgr.add(new Separator("org.xtuml.bp.ui.context-internal")); //$$NON-NLS-1$$
        mgr.add(new Separator("org.xtuml.bp.ui.context-internal-end")); //$$NON-NLS-1$$
        mgr.add(cut);
        mgr.add(copy);
        mgr.add(paste);
        //  disable until non-instance related data is not removable
        //
        //  delete.setEnabled(DeleteAction.canDeleteAction());
        //  mgr.add(delete);
        //  rename.setEnabled(RenameAction.canRenameAction());
        //  mgr.add(rename);
        mgr.add(new Separator());
        mgr.add(fileImport);
        mgr.add(fileExport);
		mgr.add(new Separator());
		mgr.add(treeRefresh);
        // If this is omitted, the platform complains because
        // it can't allow third party plug-ins to extend the menu
        // This is important for those who wish to use change
        // management plugins because Team menu items are added here.
        mgr.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
      }
    });
    Menu menu = menuManager.createContextMenu(treeViewer.getTree());
    treeViewer.getTree().setMenu(menu);
    getSite().setSelectionProvider(selection);
    getSite().registerContextMenu(menuManager, selection);
    // Titlebar Menu
    IMenuManager rootMenuManager = getViewSite().getActionBars().getMenuManager();
    rootMenuManager.setRemoveAllWhenShown(true);
    rootMenuManager.addMenuListener(new IMenuListener() {
      public void menuAboutToShow(IMenuManager mgr) {
        fillMenu(mgr);
      }
    });
    fillMenu(rootMenuManager);
  }
  /**
   * Fill the SessionExplorerView's Titlebar dropdown menu 
   */  
  protected void fillMenu(IMenuManager rootMenuManager) {
    // These actions are being presented in the menu and so should have an icon
    hideStatics.setImageDescriptor(CorePlugin.getImageDescriptor("static_co.gif")); //$$NON-NLS-1$$
    rootMenuManager.add(hideStatics);
    rootMenuManager.add(filters);
    rootMenuManager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
    rootMenuManager.add(linkWithEditor);
  }
  /**
   * Create the view filters for the SessionExplorerView window
   */
  .select any op_class from instances of O_OBJ where (selected.Key_Lett == "O_TFR")
  .invoke op = get_class_name(op_class)
  .select any fn_class from instances of O_OBJ where (selected.Key_Lett == "S_SYNC")
  .invoke fn = get_class_name(fn_class)
  protected void createFilters() {
    filterStatics = new ViewerFilter() {
      public boolean select(Viewer viewer, Object parentElement, Object element) {
        if (element instanceof ${op.body}) {
          return (((${op.body})element).getInstance_based() == Scope_c.Instance);
        }
        if (element instanceof ${fn.body}) {
          return false;
        }
        return true;
      }
    };
  .for each node in tree_nodes
    .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke cn = get_class_name( class )
    filter$r{node.CategoryName} = new ViewerFilter() {
      public boolean select(Viewer viewer, Object parentElement, Object element) {
    .if ( class.AdapterName == "IFile" )
        return !(element instanceof ${cn.body})
            && !(element instanceof $cr{class.Name}Proxy);
    .else
        return !(element instanceof ${cn.body});
    .end if
      }
    };
    .end for
    SessionExplorerFiltersContentProvider contentProvider = new SessionExplorerFiltersContentProvider();
    String [] selections = contentProvider.getInitialSelections();
    updateFilters(selections); 
  }
  /**
   * Update the SessionExplorerView's view filters 
   */
  public void updateFilters(String[] filters){
  .for each node in tree_nodes
    hide$r{node.CategoryName}.setChecked(false);
    updateFilter(hide$r{node.CategoryName});
  .end for
    for (int i=0; i <  filters.length; i++){
  .for each node in tree_nodes
      if (filters[i].equals("${node.CategoryName}")) {
        hide$r{node.CategoryName}.setChecked(true);
        updateFilter(hide$r{node.CategoryName});
      }
  .end for
    }
  }
  /**
   * Update a single filter
   */
  /* Multiple filters can be enabled at a time. */
  protected void updateFilter(Action action) {
    if(action == hideStatics) {
      if(action.isChecked()) {
        treeViewer.addFilter(filterStatics);
      } else {
        treeViewer.removeFilter(filterStatics);
      }
      return;
    }
    .for each node in tree_nodes
    if(action == hide$r{node.CategoryName}) {
      if(action.isChecked()) {
        treeViewer.addFilter(filter$r{node.CategoryName});
      } else {
        treeViewer.removeFilter(filter$r{node.CategoryName});
      }
      return;
    }
    .end for
  }
  /**
   * Create the tool bar for the SessionExplorerView 
   */  
  protected void createToolbar() {
    IActionBars actionBars = getViewSite().getActionBars();
    actionBars.setGlobalActionHandler(ActionFactory.BACK.getId(), back);
    actionBars.setGlobalActionHandler(
       ActionFactory.FORWARD.getId(),
       fwd);
    actionBars.setGlobalActionHandler(ActionFactory.UP.getId(), up);
    IToolBarManager toolBarManager = actionBars.getToolBarManager();
    toolBarManager.add(back);
    toolBarManager.add(fwd);
    toolBarManager.add(up);
    toolBarManager.add(new Separator());
    toolBarManager.add(collapseAll);
    toolBarManager.add(linkWithEditor);
  }
  /*
   * @see IWorkbenchPart#setFocus()
   */
  public void setFocus() {
    Viewer viewer = getTreeViewer();
    if (viewer != null) {
      Control c = viewer.getControl();
      if (!c.isFocusControl()) {
        c.setFocus();
      }
    }
  }
  /**
   * Returns an adapter if available
   * @see IAdaptable#getAdapter
   */
  public Object getAdapter(Class adapter) {
    if (adapter.equals(IPropertySheetPage.class)) {
      return getPropertySheet();
    }
    return super.getAdapter(adapter);
  }
  /**
   * return a property sheet if available
   */
  protected IPropertySheetPage getPropertySheet() {
        PropertySheetPage pss =  new BridgepointPropertySheetPage();
        pss.setPropertySourceProvider(new ModelPropertySourceProvider());
        return pss;
  }
  /**
   * Fire up an editor
   */
  private IEditorPart handleOpen() {
    
    IStructuredSelection sel = (IStructuredSelection) selection.getSelection();
	if (sel.isEmpty())
	{
		return null;
	}
	Object current = sel.iterator().next();    
    String name = current.getClass().getName();
    Object elementToEdit = EditorUtil.getElementToEdit(current);
    if(elementToEdit == null) {
    	return null;
    }
    //
    // Get the registry
    //
    IExtensionRegistry reg = Platform.getExtensionRegistry();
    //
    // Get all the plugins that have extended this point
    //
    IExtensionPoint extPt = reg.getExtensionPoint("org.xtuml.bp.core.editors"); //$$NON-NLS-1$$
    IExtension[] exts = extPt.getExtensions();
    // Repeat for each extension until we find a default editor
    for (int i=0; i < exts.length; i++) {
      IConfigurationElement[] elems = exts[i].getConfigurationElements();
      for (int j=0; j < elems.length; j++) {
        // Find the editor elements
        if (elems[j].getName().equals("editor")){                                  //$$NON-NLS-1$$
          IConfigurationElement[] edElems = elems[j].getChildren();
          for (int k=0; k < edElems.length; k++) {
            //
            // Is this editor the default for the current model element ?
            //
            if (edElems[k].getName().equals("defaultFor") &&                       //$$NON-NLS-1$$
                edElems[k].getAttribute("class").equals(name) ) {                  //$$NON-NLS-1$$
              try {
                //
                // Get the class supplied for the input
                //
                Bundle bundle = Platform.getBundle(elems[j]
                                      ..getDeclaringExtension().getNamespace());
                Class inputClass = bundle.loadClass(
                                       elems[j].getAttribute("input"));//$$NON-NLS-1$$
                Class[] type = new Class[1];
                type[0] = Object.class;
                //
                // Dynamically get the method createInstance, the supplied class must implement this
                //
                Method createInstanceMethod = inputClass.getMethod("createInstance", type);          //$$NON-NLS-1$$
                Object[] args = new Object[1];
                args[0] = elementToEdit;
                //
                // Invoke the method.
                // The method is static; no instance is needed, so first argument is null
                //
                IEditorInput input = (IEditorInput)createInstanceMethod.invoke(null, args);
                //
                // pass the input to the Eclipse editor, along with the class name supplied by
                // the extending plugin.
                //
                if (input != null) {
                  return PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().openEditor(
                    input,
                    elems[j].getAttribute("class"));                                 //$$NON-NLS-1$$
                }
                return null;
              }
              catch (ClassNotFoundException e){
                CorePlugin.logError("Input Class not found", e);
              }
              catch (NoSuchMethodException e) {
                CorePlugin.logError("Class does not implement static method createInstance", e);
              }
              catch (InvocationTargetException e) {
                CorePlugin.logError("Exception occured on invocation of static method createInstance of the Target", (Exception)e.getTargetException());
              }
              catch (IllegalAccessException e) {
                CorePlugin.logError("Target does not support static method createInstance", e);
              }
              catch (PartInitException e) {
                CorePlugin.logError("Could not activate Editor", e);
              }
            }
          }
        }
      }
    }

    return null; 
  }
  /**
   * Dispose of the SessionExplorerView widget
   */ 
  public void dispose() {
    super.dispose();
    Ooaofooa.removeModelChangeListenerFromAll(m_modelChangeListener);
	TransactionManager.getSingleton().removeTransactionListener(m_transactionListener);
    selection.removeSelectionChangedListener(m_selChangedListener);
		getSite().getPage().removePartListener(m_partListener);
  }
  /**
   * Initialize the Label provider to link it into the chain 
   * of platform label decorators.
   */
  protected void initLabelProvider(TreeViewer viewer){
    viewer.setLabelProvider(
       new DecoratingLabelProvider(
                              (ILabelProvider)viewer.getLabelProvider(),
                              CorePlugin.getDefault().getWorkbench().
                              getDecoratorManager().getLabelDecorator()));
  }

	/**
	 * Sets whether this SessionExplorerView's selection is linked to that of the 
	 * whichever editor is currently open.  This method is used by
	 * automated test programs to simulate pressing/unpressing the 
	 * "Link with Editor" button of the SessionExplorerView.
	 */ 
	public void setLinkWithEditor(boolean link)
	{
		linkWithEditor.setChecked(link);
	}
    /**
     * Have this explorer-view behave as if its open-action was just
     * invoked. Returns the editor that was opened. For automated test purposes.
     */
    public IEditorPart doOpen() {
        return handleOpen();
    }

    /**
     * Have this explorer-view behave as if its delete-action was just
     * invoked.  For automated test purposes.
     */
    public void doDelete() {
        delete.run();
    }
}
.end function
.//
.function add_rel_chain_classes
  .param inst_ref_set p_result_set   .// an empty inst_ref_set<O_OBJ>
  .param string p_rel_chain
  .//
  .while ("$r{p_rel_chain}" != "")
    .invoke nav = parse_chain(p_rel_chain, "backward")
    .if (not_empty nav.class)
      .assign cl = nav.class
      .assign p_result_set = p_result_set | cl
    .end if
    .assign p_rel_chain = nav.remainder
  .end while
  .assign attr_class_set = p_result_set
.end function

