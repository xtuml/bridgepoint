.//=====================================================================
.//
.// File:      $RCSfile$
.// Version:   $Revision$
.// Modified:  $Date$
.//
.// (c) Copyright 2006-2014 by Mentor Graphics Corp.  All rights reserved.
.//
.//=======================================================================
.// Licensed under the Apache License, Version 2.0 (the "License"); you may not
.// use this file except in compliance with the License.  You may obtain a copy
.// of the License at
.//
.//      http://www.apache.org/licenses/LICENSE-2.0
.//
.// Unless required by applicable law or agreed to in writing, software
.// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
.// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
.// License for the specific language governing permissions and limitations under
.// the License.
.//=======================================================================
.//
.// This file is responsible for creating the adapter that decouples the
.// client model objects from the tree viewer by delegating the job of
.// finding a parent of an element or the children of an element to the
.// correct (generated) adapter.
.//
.function create_generic_content_provider
  .param string path
  .param string prefix
  .param string package
  .//
  .assign provider_name = "${prefix}ContentProvider"
  .assign attr_result = provider_name  
package ${package};
//========================================================================
//
// File: ${path}/${provider_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      **Revision**
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp.  All rights reserved.
//
//========================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License.  You may obtain a copy 
// of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the 
// License for the specific language governing permissions and limitations under
// the License.
//======================================================================== 
//
// This class is an adapter that decouples the client model objects from
// the tree viewer by delegating the job of finding a parent of an element
// or the children of an element to the correct adapter.
//
import org.eclipse.jface.viewers.ITreeContentProvider;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;

import com.mentor.nucleus.bp.core.*;
import com.mentor.nucleus.bp.core.sorter.*;
import ${package}.adapters.*;

public class ${provider_name} implements ITreeContentProvider {
  protected TreeViewer viewer;
  protected static MetadataSortingManager.ISorter sorter = new AlphaSorter();
  /**
   * @see IContentProvider#dispose()
   */
  public void dispose() {
    // No resources allocated, nothing to dispose.
  }
  /**
   * @see IContentProvider#inputChanged(Viewer, Object, Object)
   */
  /**
   * Notifies this content provider that the given viewer's input
   * has been switched to a different element.
   * <p>
   * A typical use for this method is registering the content provider as a listener
   * to changes on the new input (using model-specific means), and deregistering the viewer
   * from the old input. In response to these change notifications, the content provider
   * propagates the changes to the viewer.
   * </p>
   *
   * @param viewer the viewer
   * @param oldInput the old input element, or <code>null</code> if the viewer
   *   did not previously have an input
   * @param newInput the new input element, or <code>null</code> if the viewer
   *   does not have an input
   */
  public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
    // Singleton model, nothing to do
  }
  .select many tree_nodes from instances of T_TNS
  /**
   * @see ITreeContentProvider#getChildren(Object)
   */
  public Object[] getChildren(Object parentElement) {
    if (parentElement instanceof Ooaofooa) {
      return RootAdapter.getInstance().getChildren(parentElement);
    }
  .for each node in tree_nodes
    .select any node_class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke result = get_class_name(node_class)
    if (parentElement instanceof ${result.body}) {
      return $Cr{node.CategoryName}Adapter.getInstance().getChildren(parentElement);
    }
  .end for
    return null;
  }
  /**
   * @see ITreeContentProvider#getParent(Object)
   */
  public Object getParent(Object element) {
    if (element instanceof Ooaofooa) {
      return RootAdapter.getInstance().getParent(element);
    }
  .for each node in tree_nodes
    .select any node_class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke result = get_class_name(node_class)
    if (element instanceof ${result.body}) {
      return $Cr{node.CategoryName}Adapter.getInstance().getParent(element);
    }
  .end for
    return null;
  }
  /**
   * @see ITreeContentProvider#hasChildren(Object)
   */
  public boolean hasChildren(Object element) {
    if (element instanceof Ooaofooa) {
      return RootAdapter.getInstance().hasChildren(element);
    }
  .for each node in tree_nodes
    .select any node_class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke result = get_class_name(node_class)
    if (element instanceof ${result.body}) {
      return $Cr{node.CategoryName}Adapter.getInstance().hasChildren(element);
    }
  .end for
    // Unknown element
    return false;
  }
  /**
   * @see IStructuredContentProvider#getElements(Object)
   */
  public Object[] getElements(Object inputElement) {
    return getChildren(inputElement);
  } 
  public static void sort(Object[] elements){
    sorter.sort(elements);
  }  
}
.end function
