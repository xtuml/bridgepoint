<!-- 
  UK Crown Copyright (c) 2016. All Rights Reserved
-->
<!-- Converted by db4-upgrade version 1.0 -->
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="MASLExamples"><info><title>MASL Examples</title></info>

<section xml:id="MASLExamplesCharacteristics"><info><title>Characteristics</title></info>

<para>
<programlisting>

  t  : string;
  i  : integer   := 1;
  r  : real      := -99.9;
  e  : Time_Unit := DAY;
  b  : boolean   := false;
  d  : record_structure_type;
  ds : sequence of record_structure_type;
  p  : instance of Pilot;
  ps : sequence of instance of Pilot;

begin
   //image
  t := i'image;
  if (t/="1") then
    raise Standard::constraint_error;
  end if;
  t := r'image;
  if (t/="-99.900002") then
    raise Standard::constraint_error;
  end if;
  t := b'image;
  if (t/="FALSE") then
    raise Standard::constraint_error;
  end if;
  t := e'image;
  if (t/="DAY") then
    raise Standard::constraint_error;
  end if;

  //upper
  t := "loWer";
  t := t'upper;
  if (t/="LOWER") then
    raise Standard::constraint_error;
  end if;

  //lower
  t := "UppER";
  t := t'lower;
  if (t/="upper") then
    raise Standard::constraint_error;
  end if;

  //firstcharpos
  t := "upper";
  i := t'firstcharpos('u');
  if (i/=t'first) then
    raise Standard::constraint_error;
  end if;
  i := t'firstcharpos('r');
  if (i/=t'last) then
    raise Standard::constraint_error;
  end if;
  t := t[t'firstcharpos('p')..t'firstcharpos('e')];
  if (t/="ppe") then
    raise Standard::constraint_error;
  end if;
  begin
    t := t[t'firstcharpos('p')..t'firstcharpos('x')];
    t := "error";
  exception
    when Standard::constraint_error =&gt;
      null;
  end;
  if (t = "error") then
    raise Standard::constraint_error;
  end if;

  //type first,last
  if (Time_Unit'first/=MILLISECOND) then
    raise Standard::constraint_error;
  end if;
  if (Time_Unit'last/=DAY) then
    raise Standard::constraint_error;
  end if;
  if (octal_type'first/=0) then
    raise Standard::constraint_error;
  end if;
  if (octal_type'last/=7) then
    raise Standard::constraint_error;
  end if;


  //string first,last,size
  t := "";
  if (t'first/=0 or t'last&gt;=0 or t'length/=0)  then
    raise Standard::constraint_error;
  end if;
  t := t &amp; " ";
  if (t'first/=0 or t'last/=0 or t'length/=1)  then
    raise Standard::constraint_error;
  end if;
  t := t &amp; " ";
  if (t'first/=0 or t'last/=1 or t'length/=2)  then
    raise Standard::constraint_error;
  end if;


  //collection first,last,size
  if (ds'first/=0 or ds'last&gt;=0 or ds'length/=0)  then
    raise Standard::constraint_error;
  end if;
  ds := ds &amp; d;
  if (ds'first/=0 or ds'last/=0 or ds'length/=1)  then
    raise Standard::constraint_error;
  end if;
  ds := ds &amp; d;
  if (ds'first/=0 or ds'last/=1 or ds'length/=2)  then
    raise Standard::constraint_error;
  end if;
  p := create Pilot (age=&gt;33);
  if (ps'first/=0 or ps'last&gt;=0 or ps'length/=0)  then
    raise Standard::constraint_error;
  end if;
  ps := ps &amp; p;
  if (ps'first/=0 or ps'last/=0 or ps'length/=1)  then
    raise Standard::constraint_error;
  end if;
  ps := ps &amp; p;
  if (ps'first/=0 or ps'last/=1 or ps'length/=2)  then
    raise Standard::constraint_error;
  end if;

  //pred,succ
  e := MILLISECOND;
  if (e'succ/=SECOND) then
    raise Standard::constraint_error;
  end if;
  e := e'succ;
  if (e'pred/=MILLISECOND) then
    raise Standard::constraint_error;
  end if;

  i := 0;
  begin
    e := MILLISECOND;
    e := e'pred;
  exception
    when Standard::constraint_error =&gt;
      i := i + 1;
  end;
  begin
    e := DAY;
    e := e'succ;
  exception
    when Standard::constraint_error =&gt;
      i := i + 1;
  end;
  if (i /= 2) then
    raise Standard::constraint_error;
  end if;

  //pos
  //i := Time_Unit'pos(MILLISECOND);
  //if (i/=1) then
  //  raise Standard::constraint_error;
  //end if;

  //value
  //e := Time_Unit'value("MILLISECOND");
  //if (e/=MILLISECOND) then
  //  raise Standard::constraint_error;
  //end if;
  //t := "DAY";
  //e := Time_Unit'value(t);
  //if (e/=DAY) then
  //  raise Standard::constraint_error;
  //end if;

  //find length
  //i := find_all Pilot ()'length;
  //if (i=0)  then
  //  raise Standard::constraint_error;
  //end if;

end;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesCreationandNavigation"><info><title>Creation and Navigation</title></info>

<para>
<programlisting>

  declare
  pilot         : instance of Pilot;
  airplane      : instance of Airplane;
  aps           : instance of Airplane_Pilot_Assignment;
  wing          : instance of Wing;
  wings         : sequence of instance of Wing;
  wheel         : instance of Wheel;
  wheels        : sequence of instance of Wheel;
  i             : integer;
begin
  i:= 0;
  begin
    wheels := pilot-&gt;R2-&gt;R3-&gt;R7;
    i := 1;
  exception
    when Standard::constraint_error =&gt;
      i:= 2;
  end;
  if (i/=2 or wheels'length /= 0) then
    raise Standard::constraint_error;
  end if;

  airplane := create Airplane (model=&gt;747);

  wing  := create Wing(span=&gt;300);
  wheel := create Wheel(size=&gt;36);
  link wheel R7 wing;
  link wing R3 airplane;
 
  wing  := create Wing(span=&gt;300);
  wheel := create Wheel(size=&gt;36);
  link wheel R7 wing;
  link wing R3 airplane;
 
  pilot := create Pilot(age=&gt;33);
  aps := create Airplane_Pilot_Assignment(Current_State=&gt;state_one);
  link airplane R2 pilot using aps;

  wheels := pilot-&gt;R2-&gt;R3-&gt;R7;
  if (wheels'length /= 2 or wheels[wheels'first].size /= 36) then
    raise Standard::constraint_error;
  end if;
end service;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesDataSets"><info><title>Data Sets</title></info>

<para>
<programlisting>

declare
  i    : integer := 0;
  r    : real    := 0.0;
  t    : string  :="";
  d1   : record_structure_type;
  s1   : sequence of record_structure_type;
  fs   : sequence of Server::fixed_size_structure_type;
  date : Calendar::Date;
  time : Calendar::Time_of_Day;
begin
  //create a sequence of structures
  for x in 1..3 loop
    d1.int_field  := x;
    d1.real_field := real(x*1.1);
    d1.text_field := x'image;
    s1 := s1 &amp; d1;
  end loop;
  for x in s1'elements loop
    i := i + x.int_field;
    t := t &amp; x.text_field;
  end loop;
  if (i /= 6 or t /="123") then
    raise Standard::constraint_error;
  end if;

  //normal order
  s1 := s1 ordered_by(int_field);
  t := "";
  for x in s1'elements loop
    t:=t &amp; x.text_field;
  end loop;
  if (t /="123") then
    raise Standard::constraint_error;
  end if;

  //reverse order
  s1 := s1 reverse_ordered_by(int_field);
  t := "";
  for x in s1'elements loop
    t:=t &amp; x.text_field;
  end loop;
  if (t /="321") then
    raise Standard::constraint_error;
  end if;

  //slice
  d1 := s1[s1'last-1];
  t := "";
  for x in s1'elements loop
    t:=t &amp; x.text_field;
  end loop;
  if (t /="321") then
    raise Standard::constraint_error;
  end if;
  if (d1.text_field /= "2") then
    raise Standard::constraint_error;
  end if;

  s1[s1'last-1].text_field := "two";
  t := "";
  for x in s1'elements loop
    t:=t &amp; x.text_field;
  end loop;
  if (t /="3two1") then
    raise Standard::constraint_error;
  end if;

  //normal order
  s1 := s1 ordered_by(int_field);
  t := "";
  for x in s1'elements loop
    t:=t &amp; x.text_field;
  end loop;
  if (t /="1two3") then
    raise Standard::constraint_error;
  end if;

  //reverse order
  s1 := s1 reverse_ordered_by(text_field);
  t := "";
  for x in s1'elements loop
    t:=t &amp; x.text_field;
  end loop;
  if (t /="two31") then
    raise Standard::constraint_error;
  end if;

  //multiple order
  s1 :=      (3,1.2,"bla",date,time,blue);
  s1 := s1 &amp; (1,1.0,"bla",date,time,blue);
  s1 := s1 &amp; (4,1.0,"bla",date,time,blue);
  s1 := s1 &amp; (2,1.0,"bbla",date,time,blue);
  s1 := s1 &amp; (2,1.0,"bla",date,time,blue);
  s1 := s1 &amp; (3,1.0,"bla",date,time,blue);
  s1 := s1 ordered_by(int_field,real_field,text_field);
  //for x in s1'elements loop
  //  Text_IO::put_line(x'image);
  //end loop;
  if (s1[s1'first+1].text_field /= "bbla") then
    raise Standard::constraint_error;
  end if;

  //structure comparisons, removed from language
  //d1 := s1[s1'first];
  //if (d1 /= s1[s1'first]) then
  //  raise Standard::constraint_error;
  //end if;
  //d1.int_field := s1[s1'first].int_field &amp; 2;
  //if (d1 = s1[s1'first]) then
  //  raise Standard::constraint_error;
  //end if;

  //double nested normal order, testing cgen here
  for x in s1'elements loop
    s1 := s1 ordered_by(text_field);
  end loop;
  s1 := s1 ordered_by(text_field);

  //other domain structure ordering, testing cgen here
  fs := fs ordered_by(i);
end service;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesStringManipulation"><info><title>String Manipulation</title></info>

<para>
<programlisting>

declare 
  text   : string  := "";
  text2  : string  := "";
  passed : boolean := false;
begin
  text := "hello";
  for c in text'elements loop
    text2 := text2 &amp; c;
  end loop;
  if (text2 /= "hello") then
    raise Standard::constraint_error;
  end if;

  text := "hello";
  for c in reverse text'elements loop
    text2 := text2 &amp; c;
  end loop;
  if (text2 /= "helloolleh") then
    raise Standard::constraint_error;
  end if;

  text  := "hello";
  text2 := "";
  for i in text'range loop
    text2 := text2 &amp; text[i];
  end loop;
  if (text2 /= "hello") then
    raise Standard::constraint_error;
  end if;

  text := "hello";
  for i in reverse text'range loop
    text2 := text2 &amp; text[i];
  end loop;
  if (text2 /= "helloolleh") then
    raise Standard::constraint_error;
  end if;

  text := "hello";
  if (text /= "hello") then
    raise Standard::constraint_error;
  end if;

  text := "hello";
  text := text[text'first];
  if (text /= "h") then
    raise Standard::constraint_error;
  end if;

  text := "hello";
  text := text[text'last];
  if (text /= "o") then
    raise Standard::constraint_error;
  end if;

  text[text'first] := 'h';
  if (text /= "h") then
    raise Standard::constraint_error;
  end if;

  text := text &amp; "ello";
  if (text /= "hello") then
    raise Standard::constraint_error;
  end if;

  text := "hello";
  if (text &lt; "goodbye") then
    raise Standard::constraint_error;
  end if;
  if ("goodbye" &gt; text) then
    raise Standard::constraint_error;
  end if;

  text := "hello";
  text := text[0..2];
  if (text /= "hel") then
    raise Standard::constraint_error;
  end if;

  //should all raise exceptions 
  begin
    passed := false;
    text := text[text'first-1];
  exception
    when Standard::constraint_error =&gt;
      passed := true;
  end;
  if (passed = false) then
    raise Standard::constraint_error;
  end if;

  begin
    passed := false;
    text := text[text'length];
  exception
    when Standard::constraint_error =&gt;
      passed := true;
  end;
  if (passed = false) then
    raise Standard::constraint_error;
  end if;

 begin
    passed := false;
    text[text'length]  := 'h';
  exception
    when Standard::constraint_error =&gt;
      passed := true;
  end;
  if (passed = false) then
    raise Standard::constraint_error;
  end if;

 begin
    passed := false;
    text[text'first-1] := 'h';
  exception
    when Standard::constraint_error =&gt;
      passed := true;
  end;
  if (passed = false) then
    raise Standard::constraint_error;
  end if;

 begin
    passed := false;
    text := text[100..2];
  exception
    when Standard::constraint_error =&gt;
      passed := true;
  end;
  if (passed = false) then
    raise Standard::constraint_error;
  end if;
end service;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesStringLiterals"><info><title>String Literals</title></info>

<para>
<programlisting>

declare 
  i    : integer   := 10;
  r    : real      := 88.8;
  c    : character := 'g';
  s    : string    := "h";
  b    : boolean   := false;
  e    : Time_Unit := DAY;
  f    : Calendar::time_unit_type;
  ih   : instance of Pilot;
  ihc  : sequence of instance of Pilot;
  re   : record_structure_type;
  rec  : sequence of record_structure_type;
  date : Calendar::Date;
  time : Calendar::Time_of_Day;
begin
  //literals
  i :=  0;
  i :=  99;
  i := +99;
  i := -99;
  r :=  99.9;
  r := +99;
  r := -99;
  r := 0.9;
  c := 'f';
  s := "";
  s := "hello";
  b := true;
  b := false;
  e := DAY;
  f := Calendar::SECOND;
  ih := null;
  re := (4,5.0,"hello",date,time,green);

  //names
  i := 0;
  s[4] := 'r';
  ih := create Pilot(age=&gt;44);
  ih.NI := 99;
  ihc := ihc &amp; ih;
  ihc[ihc'first].NI := 10;
  re.int_field := 0;
  rec := rec &amp; re;
  rec := rec &amp; (4,5.0,"hello",date,time,blue);
  rec[rec'first].int_field := 1;

  //expressions, all on integers
  i := 100;
  if not (i=100 and i/=1) then
    raise Standard::constraint_error;
  elsif not (i&lt;1000 or i&gt;1) then
    raise Standard::constraint_error;
  elsif (i&lt;=100 xor i&gt;=100) then
    raise Standard::constraint_error;
  elsif not (i=99+1 or i=101-1) then
    raise Standard::constraint_error;
  elsif not (i=10*10) then
    raise Standard::constraint_error;
  elsif not (i=1000/10) then
    raise Standard::constraint_error;
  elsif not (i=10**2) then
    raise Standard::constraint_error;
  elsif not (i=1100 rem 1000) then
    raise Standard::constraint_error;
  elsif not (i mod 50 = 0) then
    raise Standard::constraint_error;
  elsif not (i = abs(-100)) then
    raise Standard::constraint_error;
  end if;

  //various expressions on other all base types
  r := 99.9;
  c := 'f';
  s := "hello";
  b := true;
  e := DAY;
  f := Calendar::SECOND;
  ih := null;
  if (r&lt;100-1.3) then
    raise Standard::constraint_error;
  elsif (c /= 'f') then
    raise Standard::constraint_error;
  elsif (c &lt; 'a') then
    raise Standard::constraint_error;
  elsif not (c &gt; 'a') then
    raise Standard::constraint_error;
  elsif (s /= "hello") then
    raise Standard::constraint_error;
  elsif not (s = "hello") then
    raise Standard::constraint_error;
  elsif not (s &gt; "gello") then
    raise Standard::constraint_error;
  elsif (b=false) then
    raise Standard::constraint_error;
  elsif (e=SECOND) then
    raise Standard::constraint_error;
  elsif not (e&gt;SECOND) then
    raise Standard::constraint_error;
  elsif (f=Calendar::DAY) then
    raise Standard::constraint_error;
  elsif not (f&lt;Calendar::DAY) then
    raise Standard::constraint_error;
  elsif not (date.month=date.month) then
    raise Standard::constraint_error;
  elsif not (date.month&lt;=date.month) then
    raise Standard::constraint_error;
  elsif (ih/=null) then
    raise Standard::constraint_error;
  end if;
end;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesFindStatements"><info><title>Find Statements</title></info>

<para>
<programlisting>

declare
  pilot     : instance of Pilot;
  pilots    : sequence of instance of Pilot;
  xpilots   : sequence of instance of Pilot;
  total_age : integer := 0;
  temp      : integer := 0;
  today     : Calendar::date_type;
begin
  //find one on no population
  pilot := find_one Pilot(age=5);
  if (pilot/=null) then
    raise Standard::constraint_error;
  end if;

  //find one on single population
  pilot := create Pilot(age=&gt;10,qualified=&gt;today);
  pilot := find_one Pilot(age=5 and qualified.year=today.year);
  if (pilot/=null) then
    raise Standard::constraint_error;
  end if;
  pilot := find_one Pilot(age=10);
  if (pilot=null or pilot.age /=10) then
    raise Standard::constraint_error;
  end if;

  //find one on small population
  pilot := create Pilot(age=&gt;20);
  pilot := create Pilot(age=&gt;30);
  pilot := find_one Pilot(age=5);
  if (pilot/=null) then
    raise Standard::constraint_error;
  end if;
  pilot := find_one Pilot(age=10);
  if (pilot=null or pilot.age /= 10) then
    raise Standard::constraint_error;
  end if;
  pilot := find_one Pilot(age=20);
  if (pilot=null or pilot.age /= 20) then
    raise Standard::constraint_error;
  end if;
  pilot := find_one Pilot(age=30);
  if (pilot=null or pilot.age /= 30) then
    raise Standard::constraint_error;
  end if;

  //find one on large population
  for age in 1..100 loop
    pilot := create Pilot(age=&gt;age);
  end loop;
  pilot := find_one Pilot(age=1);
  if (pilot=null or pilot.age /= 1) then
    raise Standard::constraint_error;
  end if;
  pilot := find_one Pilot(age=100);
  if (pilot=null or pilot.age /= 100) then
    raise Standard::constraint_error;
  end if;

  //cleanup
  pilot := find_one Pilot();
  while (pilot /= null) loop
    delete pilot;
    pilot := find_one Pilot();
  end loop;
  pilot := find_one Pilot();
  if (pilot/=null) then
    raise Standard::constraint_error;
  end if;

  //find all on no population
  pilots := find_all Pilot();
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;

  //find all on single population
  pilot := create Pilot(age=&gt;10);
  pilots := find_all Pilot();
  if (pilots'length /= 1 or pilots[pilots'first].age /= 10) then
    raise Standard::constraint_error;
  end if;

  //find all on small population
  pilot := create Pilot(age=&gt;20);
  pilot := create Pilot(age=&gt;30);
  pilots := find_all Pilot();
  if (pilots'length /= 3 or pilots[pilots'first+0].age /= 10
                       or pilots[pilots'first+1].age /= 20
                       or pilots[pilots'first+2].age /= 30) then
    raise Standard::constraint_error;
  end if;

  //find all on large population
  delete pilots;
  total_age := 0;
  for age in 1..100 loop
    pilot := create Pilot(age=&gt;age);
    total_age := total_age+age;
  end loop;
  pilots := find_all Pilot();
  temp := 0;
  for pilot in pilots'elements loop
    temp := temp + pilot.age;
  end loop;
  if (total_age /= temp) then
    raise Standard::constraint_error;
  end if;

  //cleanup
  pilots := find_all Pilot();
  delete pilots;

  //find on no population
  pilots := find Pilot(age=4);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;

  //find on single population
  pilot := create Pilot(age=&gt;10);
  pilots := find Pilot(age=10);
  if (pilots'length /= 1 or pilots[pilots'first].age /= 10) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age=100);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;

  //find on small population
  pilot := create Pilot(age=&gt;20);
  pilot := create Pilot(age=&gt;30);
  pilots := find Pilot(age&gt;10);
  if (pilots'length /= 2 or pilots[pilots'first+0].age /= 20
                       or pilots[pilots'first+1].age /= 30) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age&lt;=10);
  if (pilots'length /= 1 or pilots[pilots'first+0].age /= 10) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age&lt;1);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;

  //find on large population
  delete pilots;
  for age in 1..100 loop
    pilot := create Pilot(age=&gt;age);
  end loop;
  pilots := find Pilot(age&gt;50);
  if (pilots'length /= 50) then
    raise Standard::constraint_error;
  end if;

  //cleanup
  pilots := find_all Pilot();
  delete pilots;

  //*************************************************************************
  //find only no population
  pilot := find_only Pilot(age=4);
  if (pilot /= null) then
    raise Standard::constraint_error;
  end if;

  //find on single population
  pilot := create Pilot(age=&gt;10);
  pilot := find_only Pilot(age=10);
  if (pilot.age /= 10) then
    raise Standard::constraint_error;
  end if;
  pilot := find_only Pilot(age=100);
  if (pilot /= null) then
    raise Standard::constraint_error;
  end if;

  //find on small population
  pilot := create Pilot(age=&gt;20);
  pilot := create Pilot(age=&gt;30);
  pilot := find_only Pilot(age=20);
  if (pilot.age /= 20) then
    raise Standard::constraint_error;
  end if;
  begin
    pilot := find_only Pilot(age&gt;=10);
  exception
    when Standard::constraint_error =&gt;
      pilot := find_only Pilot(age=30);
  end;
  if (pilot.age /= 30) then
    raise Standard::constraint_error;
  end if;

  //cleanup
  pilots := find_all Pilot();
  delete pilots;

  //find over empty collections
  if (xpilots'length /= 0) then
    raise Standard::constraint_error;
  end if;
  pilots := find_all xpilots();
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;

  //find on single element collection
  pilot   := create Pilot(age=&gt;10);
  xpilots := find_all Pilot();
  pilots  := find xpilots(age=10);
  if (pilots'length /= 1 or pilots[pilots'first].age /= 10) then
    raise Standard::constraint_error;
  end if;
  pilots := find xpilots(age=100);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;

  //find over small collections
  pilot := create Pilot(age=&gt;20);
  pilot := create Pilot(age=&gt;30);
  xpilots := find_all Pilot();
  pilots := find xpilots(age&gt;10);
  if (pilots'length /= 2 or pilots[pilots'first+0].age /= 20
                       or pilots[pilots'first+1].age /= 30) then
    raise Standard::constraint_error;
  end if;
  pilots := find xpilots(age&lt;=10);
  if (pilots'length /= 1 or pilots[pilots'first+0].age /= 10) then
    raise Standard::constraint_error;
  end if;
  pilots := find xpilots(age&lt;1);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;

  //find over large collections
  pilots := find_all Pilot();
  delete pilots;
  for age in 1..100 loop
    pilot := create Pilot(age=&gt;age);
  end loop;
  xpilots := find_all Pilot();
  pilots := find xpilots(age&gt;50);
  if (pilots'length /= 50) then
    raise Standard::constraint_error;
  end if;

  //cleanup
  pilots := find_all Pilot();
  delete pilots;

  //various find conditions
  pilot := create Pilot(age=&gt;10);
  pilot := create Pilot(age=&gt;20);

  pilots := find Pilot(age/=10);
  if (pilots'length /= 1 or pilots[pilots'first].age /= 20) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age=10);
  if (pilots'length /= 1 or pilots[pilots'first].age /= 10) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age&lt;10);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age&gt;20);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age&lt;=20);
  if (pilots'length /= 2) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age&gt;=20);
  if (pilots'length /= 1 or pilots[pilots'first].age /= 20) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(not (age=10));
  if (pilots'length /= 1 or pilots[pilots'first].age /= 20) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age=10 or age=20);
  if (pilots'length /= 2) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age=10 or age=20 or age&gt;1);
  if (pilots'length /= 2) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age=10 and age=20);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age=10 xor age/=10);
  if (pilots'length /= 2) then
    raise Standard::constraint_error;
  end if;
  pilots := find Pilot(age=10 xor age=10 and age&gt;1);
  if (pilots'length /= 0) then
    raise Standard::constraint_error;
  end if;

  //cleanup
  pilots := find_all Pilot();
  delete pilots;

  //various ordered_by conditions on finds
  pilot := create Pilot(age=&gt;7);
  pilot := create Pilot(age=&gt;3);
  pilot := create Pilot(age=&gt;8);
  pilot := create Pilot(age=&gt;1);
  pilot := create Pilot(age=&gt;6);
  pilot := create Pilot(age=&gt;2);
  pilot := create Pilot(age=&gt;5);
  pilot := create Pilot(age=&gt;4);
  pilot := create Pilot(age=&gt;10);
  pilot := create Pilot(age=&gt;9);

  xpilots := find_all Pilot() ordered_by(age);
  temp := 1;
  for pilot in xpilots'elements loop
    if (pilot.age /= temp) then
      raise Standard::constraint_error;
    end if;
    temp := temp+1;
  end loop;

  xpilots := find_all Pilot() reverse_ordered_by(age);
  temp := 1;
  for pilot in xpilots'elements loop
    if (pilot.age = temp) then
      raise Standard::constraint_error;
    end if;
    temp := temp+1;
  end loop;

  pilots := find_all Pilot();
  xpilots := pilots ordered_by(age);
  temp := 1;
  for pilot in xpilots'elements loop
    if (pilot.age /= temp) then
      raise Standard::constraint_error;
    end if;
    temp := temp+1;
  end loop;

  pilots := find_all Pilot();
  xpilots := pilots reverse_ordered_by(age);
  temp := 1;
  for pilot in xpilots'elements loop
    if (pilot.age = temp) then
      raise Standard::constraint_error;
    end if;
    temp := temp+1;
  end loop;

  //cleanup
  pilots := find_all Pilot();
  delete pilots;


  //*************************************************************************
  //various multiple ordered_by conditions on finds
  pilot := create Pilot(age=&gt;3, NI=&gt;455, name=&gt;"fred",     qualified=&gt;today);
  pilot := create Pilot(age=&gt;3, NI=&gt;222, name=&gt;"fred",     qualified=&gt;today);
  pilot := create Pilot(age=&gt;8, NI=&gt;455, name=&gt;"sid",      qualified=&gt;today);
  pilot := create Pilot(age=&gt;8, NI=&gt;455, name=&gt;"bill",     qualified=&gt;today);
  pilot := create Pilot(age=&gt;6, NI=&gt;455, name=&gt;"harvey",   qualified=&gt;today);
  pilot := create Pilot(age=&gt;2, NI=&gt;455, name=&gt;"bob",      qualified=&gt;today);
  pilot := create Pilot(age=&gt;5, NI=&gt;455, name=&gt;"bernard",  qualified=&gt;today);
  pilot := create Pilot(age=&gt;4, NI=&gt;455, name=&gt;"baldrick", qualified=&gt;today);
  pilot := create Pilot(age=&gt;4, NI=&gt;455, name=&gt;"bonsai",   qualified=&gt;today);
  pilot := create Pilot(age=&gt;9, NI=&gt;455, name=&gt;"biggles",  qualified=&gt;today);

  xpilots := find_all Pilot() ordered_by(age,name,NI);

  for x in 0..8 loop
    if (xpilots[x].age &gt; xpilots[x+1].age) then
      raise Standard::constraint_error;
    end if;
  end loop;
  if (xpilots[1].NI /= 222) then
    raise Standard::constraint_error;
  end if;
  if (xpilots[8].name /= "sid") then
    raise Standard::constraint_error;
  end if;

  //xpilots := find_all Pilot() ordered_by(age,name,NI,qualified);

  xpilots := find_all Pilot() ordered_by(age,name,NI,qualified.year);

  xpilots := xpilots reverse_ordered_by(age,name,NI,qualified.year);
end;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesControlStatements"><info><title>Control Statements</title></info>

<para>
<programlisting>

declare
  i    : integer := 1;
  b    : integer := 0;
  t    : string  := "hello";
  f    : boolean := true;
  date : Calendar::Date;
  time : Calendar::Time_of_Day;
  ds   : sequence of record_structure_type;
  ia   : array (octal_type'range) of string;
  ea   : array (colour_type'range) of string;
  p    : instance of Pilot;
  ins  : sequence of instance of Pilot;
begin
  //if statement
  if (i/=1) then
    raise Standard::constraint_error;
  end if;
  if (i=1) then
    i:= 2;
  end if;
  if (i/=2) then
    raise Standard::constraint_error;
  end if;

  if (i/=2) then
    raise Standard::constraint_error;
  else
    i := 3;
  end if;
  if (i/=3) then
    raise Standard::constraint_error;
  end if;
  if (i=3) then
    i := 4;
  else
    raise Standard::constraint_error;
  end if;
  if (i/=4) then
    raise Standard::constraint_error;
  end if;

  if (i/=4) then
    raise Standard::constraint_error;
  elsif (i/=4) then 
    raise Standard::constraint_error;
  end if;
  if (i/=4) then
    raise Standard::constraint_error;
  elsif (i=4) then 
    i := 5;
  end if;
  if (i/=5) then
    raise Standard::constraint_error;
  end if;

  if (i/=5) then
    raise Standard::constraint_error;
  elsif (i=5) then 
    i := 6;
  else
    raise Standard::constraint_error;
  end if;
  if (i/=6) then
    raise Standard::constraint_error;
  end if;

  if (i/=6) then
    raise Standard::constraint_error;
  elsif (i/=6) then 
    raise Standard::constraint_error;
  else
    i := 7;
  end if;
  if (i/=7) then
    raise Standard::constraint_error;
  end if;

  if f then
    f := false;
  end if;
  if f then 
    raise Standard::constraint_error;
  end if;

  //case statement
  i := 3;
  case i is
    when 1=&gt;
      b:=1;
    when 2=&gt;
      b:=2;
    when others=&gt;
      b:=1000;
  end case;
  if (b/=1000) then
    raise Standard::constraint_error;
  end if;
  i := 1;
  case i is
    when 1=&gt;
      b:=1;
    when 2=&gt;
      b:=2;
    when others=&gt;
      b:=1000;
  end case;
  if (b/=1) then
    raise Standard::constraint_error;
  end if;
  i := 2;
  case i is
    when 1=&gt;
      b:=1;
    when 2=&gt;
      b:=2;
    when others=&gt;
      b:=1000;
  end case;
  if (b/=2) then
    raise Standard::constraint_error;
  end if;
  i := 2;
  case i is
    when 1 | 2=&gt;
      b:=1;
    when 3=&gt;
      b:=3;
    when others=&gt;
      b:=1000;
  end case;
  if (b/=1) then
    raise Standard::constraint_error;
  end if;

  //while statement
  i:=0;
  b:=0;
  while (i&gt;0) loop
    i := i-1;
    b := b+1;
  end loop;
  if (b/=0) then
    raise Standard::constraint_error;
  end if;
  i:=0;
  b:=0;
  while (i&gt;=0) loop
    i := i-1;
    b := b+1;
  end loop;
  if (b/=1) then
    raise Standard::constraint_error;
  end if;
  i:=2;
  b:=0;
  while (i&gt;=1) loop
    i := i-1;
    b := b+1;
  end loop;
  if (b/=2) then
    raise Standard::constraint_error;
  end if;

  //exit statement
  i:=0;
  b:= 0;
  while (i=0) loop
    b:=b+1;
    exit;
  end loop;
  if (b/=1) then
    raise Standard::constraint_error;
  end if;
  i:=0;
  b:= 0;
  while (i=0) loop
    b:=b+1;
    exit when b=2;
  end loop;
  if (b/=2) then
    raise Standard::constraint_error;
  end if;

  //for statement, int loop
  b:=0;
  for i in 1..10 loop
    b:=b+1;
    if (b/=i) then
      raise Standard::constraint_error;
    end if;
  end loop;
  if (b/=10) then
    raise Standard::constraint_error;
  end if;
  b:=0;
  for i in reverse 1..10 loop
    b:=b+1;
    if (b=i) then
      raise Standard::constraint_error;
    end if;
  end loop;
  if (b/=10) then
    raise Standard::constraint_error;
  end if;

  //for statement, derived and subtypes of int loop
  b:=0;
  for i in octal_type'range loop
    if (b/=i) then
      raise Standard::constraint_error;
    end if;
    b:=b+1;
  end loop;
  if (b/=8) then
    raise Standard::constraint_error;
  end if;

  //for statement, enum loop
  t := "";
  for e in SECOND..DAY loop
    t := t &amp; "," &amp; e'image;
  end loop;
  if (t/=",SECOND,MINUTE,HOUR,DAY") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for e in reverse SECOND..DAY loop
    t := t &amp; "," &amp; e'image;
  end loop;
  if (t/=",DAY,HOUR,MINUTE,SECOND") then
    raise Standard::constraint_error;
  end if;

  //for statement, enum type loop
  t := "";
  for e in Time_Unit'range loop
    t := t &amp; "," &amp; e'image;
  end loop;
  if (t/=",MILLISECOND,SECOND,MINUTE,HOUR,DAY") then
    raise Standard::constraint_error;
  end if;

  //for statement, data set loop 
  for x in 1..3 loop
    ds := ds &amp; (x,1.2,x'image,date,time,blue);
  end loop;
  t := "";
  for x in ds'elements loop
    t := t &amp; x.text_field;
  end loop;
  if (t /= "123") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ds'range loop
    t := t &amp; ds[x].text_field;
  end loop;
  if (t /= "123") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ds'first..ds'last loop
    t := t &amp; ds[x].text_field;
  end loop;
  if (t /= "123") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ds'last..ds'first loop
    t := t &amp; ds[x].text_field;
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ds'elements loop
    t := t &amp; x.text_field;
  end loop;
  if (t /= "321") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ds'range loop
    t := t &amp; ds[x].text_field;
  end loop;
  if (t /= "321") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ds'first..ds'last loop
    t := t &amp; ds[x].text_field;
  end loop;
  if (t /= "321") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ds'last..ds'first loop
    t := t &amp; ds[x].text_field;
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;

  //for statement, array loop integer index
  for x in octal_type'range loop
    ia[x] := x'image;
  end loop;
  t := "";
  for x in ia'elements loop
    t := t &amp; x;
  end loop;
  if (t /= "01234567") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ia'range loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "01234567") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ia'first..ia'last loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "01234567") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in octal_type'range loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "01234567") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in octal_type'first..octal_type'last loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "01234567") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ia'last..ia'first loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in octal_type'last..octal_type'first loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ia'elements loop
    t := t &amp; x;
  end loop;
  if (t /= "76543210") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ia'range loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "76543210") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ia'first..ia'last loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "76543210") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse octal_type'range loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "76543210") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse octal_type'first..octal_type'last loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "76543210") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ia'last..ia'first loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse octal_type'last..octal_type'first loop
    t := t &amp; ia[x];
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;

  //for statement, array loop enum index
  for x in colour_type'range loop
    ea[x] := x'image;
  end loop;
  t := "";
  for x in ea'elements loop
    t := t &amp; x;
  end loop;
  if (t /= "redgreenblue") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ea'range loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "redgreenblue") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ea'first..ea'last loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "redgreenblue") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in colour_type'range loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "redgreenblue") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in colour_type'first..colour_type'last loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "redgreenblue") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ea'last..ea'first loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in colour_type'last..colour_type'first loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ea'elements loop
    t := t &amp; x;
  end loop;
  if (t /= "bluegreenred") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ea'range loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "bluegreenred") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ea'first..ea'last loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "bluegreenred") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse colour_type'range loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "bluegreenred") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse colour_type'first..colour_type'last loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "bluegreenred") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ea'last..ea'first loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse colour_type'last..colour_type'first loop
    t := t &amp; ea[x];
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;

  //for statement, instance set loop
  p:= create Pilot(age=&gt;20,name=&gt;"1");
  ins := ins &amp; p;
  p:= create Pilot(age=&gt;20,name=&gt;"2");
  ins := ins &amp; p;
  p:= create Pilot(age=&gt;20,name=&gt;"3");
  ins := ins &amp; p;
  t := "";
  for x in ins'elements loop
    t := t &amp; x.name;
  end loop;
  if (t /= "123") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ins'range loop
    t := t &amp; ins[x].name;
  end loop;
  if (t /= "123") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ins'first..ins'last loop
    t := t &amp; ins[x].name;
  end loop;
  if (t /= "123") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in ins'last..ins'first loop
    t := t &amp; ins[x].name;
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ins'elements loop
    t := t &amp; x.name;
  end loop;
  if (t /= "321") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ins'range loop
    t := t &amp; ins[x].name;
  end loop;
  if (t /= "321") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ins'first..ins'last loop
    t := t &amp; ins[x].name;
  end loop;
  if (t /= "321") then
    raise Standard::constraint_error;
  end if;
  t := "";
  for x in reverse ins'last..ins'first loop
    t := t &amp; ins[x].name;
  end loop;
  if (t /= "") then
    raise Standard::constraint_error;
  end if;
end;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesArrays"><info><title>Arrays</title></info>

<para>
<programlisting>

declare
  my_b_array        : array(1..2) of byte;
  my_int_array_1    : array(1..5) of integer;
  my_int_array_2    : my_int_array_type;
  my_int_array_3    : my_int_array_type;
  my_struct_array   : array(1..2)  of nested_structure_type;
  my_time_array     : array(2..3)  of Calendar::time_type;
  my_sub_type_array : array(3..30) of my_int_sub_type_type;
  my_array_array    : array(1..5)  of my_int_array_type;
  x                 : integer:=0;
  s                 : nested_structure_type;
begin
  for i in 1..10 loop
    my_int_array_2[i] := 9;
    my_int_array_3[i] := 10;
  end loop;
  if (my_int_array_2[5] /= 9) then
    raise Standard::constraint_error;
  end if;

  //general access
  my_int_array_1[1] := 55;
  if (my_int_array_1[1] /= 55) then
    raise Standard::constraint_error;
  end if;

  my_int_array_1[my_int_array_1'first] := 55;
  if (my_int_array_1[1] /= 55) then
    raise Standard::constraint_error;
  end if;

  my_int_array_1[my_int_array_1'last] := 55;
  if (my_int_array_1[5] /= 55) then
    raise Standard::constraint_error;
  end if;

  //parser error
  //my_int_array_1[my_int_array_type'last] := 55;

  //copy
  my_int_array_2 := my_int_array_3;
  my_int_array_3[4] := 0;
  
  //slices, parser error
  for i in 1..5 loop
    my_int_array_1[i] := i;
  end loop;
  //my_int_array_1 := my_int_array_2[1..5];
  x := 0;
  for i in my_int_array_1'elements loop
    x:=x+i;
  end loop;
  //if (x /= 5) then
  //  raise Standard::constraint_error;
  //end if;

  //arrays as parameters
  Array_passing(my_int_array_2,my_int_array_3);

  //array of strucures
  my_struct_array[2].id := 9;
  s := my_struct_array[2];
  if (s.id /= 9) then
    raise Standard::constraint_error;
  end if;

  //array of arrays
  my_array_array[1][1] := 55;
  my_int_array_2 :=  my_array_array[1];
  if (my_int_array_2[1] /= 55) then
    raise Standard::constraint_error;
  end if;

  //expected exceptions
  x := 0;
  begin
    my_b_array[10] := 0;
  exception
    when Standard::constraint_error =&gt;
      x := x + 1;
  end;
  begin
    my_array_array[0][1] := 0;
  exception
    when Standard::constraint_error =&gt;
      x := x + 1;
  end;
  begin
    my_array_array[1][0] := 0;
  exception
    when Standard::constraint_error =&gt;
      x := x + 1;
  end;
  if (x /= 3) then
    raise Standard::constraint_error;
  end if;
end;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesExceptions"><info><title>Exceptions</title></info>

<para>
Exception type declared in the domain mod file.
<programlisting>

Exception my_exception

</programlisting>
<programlisting>

declare
  handled : boolean;
begin
  handled := false;
  begin
    raise my_exception;
  exception
    when my_exception =&gt;
      handled := true;
  end;
  if (not handled) then
    raise Standard::constraint_error;
  end if;
end;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesDeviceOutput"><info><title>Device Output</title></info>

<para>
<programlisting>

declare
  s : string;
  i : integer;
  r : real;
  b1 : boolean;
  b2 : boolean;
  e : Calendar::month_type;
  test : device;
  res : string;

begin

  s := "Hello";
  i := 123;
  r := 45.67;
  b1 := true;
  b2 := false;
  e := Calendar::MARCH;

  // Test single writes
  Device_IO::create_file("output.tst", true);
  Device_IO::open("output.tst", Device_IO::OUT, test);
  test &lt;&lt; s;
  test &lt;&lt; i;
  test &lt;&lt; r;
  test &lt;&lt; b1;
  test &lt;&lt; b2;
  test &lt;&lt; e;
  Device_IO::close(test);

  Device_IO::open("output.tst", Device_IO::IN, test);
  test &gt;&gt; res;
  Device_IO::close(test);

  if res /= "Hello12345.67truefalseMARCH" then 
    console &lt;&lt; res;
    raise Standard::constraint_error;
  end if;

  // Test concatenated writes
  Device_IO::create_file("output.tst", true);
  Device_IO::open("output.tst", Device_IO::OUT, test);
  test &lt;&lt; s &lt;&lt; i &lt;&lt; r &lt;&lt; b1 &lt;&lt; b2 &lt;&lt; e;
  Device_IO::close(test);

  Device_IO::open("output.tst", Device_IO::IN, test);
  test &gt;&gt; res;
  Device_IO::close(test);

  if res/= "Hello12345.67truefalseMARCH" then 
    console &lt;&lt; res;
    raise Standard::constraint_error;
  end if;

  Device_IO::delete_file("output.tst");

  console &lt;&lt; "TEST PASSED" &lt;&lt; endl;

end;

</programlisting>
</para>
</section>
<section xml:id="MASLExamplesDeviceInput"><info><title>Device Input</title></info>

<para>
<programlisting>

declare
 s : string;
  i : integer;
  r : real;
  b1 : boolean;
  b2 : boolean;
  e1 : Calendar::month_type;
  e2 : Calendar::month_type;
  test : device;
  res : string;
  p1 : positive;
  p2 : positive;
 passed : boolean;
begin

  // Test single element reads
  Device_IO::create_file("input.tst", true);
  Device_IO::open("input.tst", Device_IO::OUT, test );
  test &lt;&lt;  "Hello 123   45.67   true false \n MARCH 2 -2 aaa";
  Device_IO::close(test);

  Device_IO::open("input.tst", Device_IO::IN, test );

  test &gt;&gt; s;
  if s /= "Hello" then 
    raise Standard::constraint_error;
  end if;

  test &gt;&gt; i;
  if i /= 123 then
    raise Standard::constraint_error;
  end if;

  test &gt;&gt; r;
  if r &lt; 45.66669 or r &gt; 45.67001 then
    raise Standard::constraint_error;
  end if;

  test &gt;&gt; b1;
  if not b1 then
    raise Standard::constraint_error;
  end if;

  test &gt;&gt; b2;
  if b2 then
    raise Standard::constraint_error;
  end if;

  test &gt;&gt; e1;
  if e1 /= Calendar::MARCH then
    raise Standard::constraint_error;
  end if;

  test &gt;&gt; p1;
  if p1 /= 2 then
    raise Standard::constraint_error;
  end if;

  begin
    passed := false;
    test &gt;&gt; p2;
  exception
    when Standard::constraint_error =&gt;
      passed := true;
  end;
  if passed = false then
    raise Standard::constraint_error;
  end if;
 
  begin
    passed := false;
    test &gt;&gt; e2;
  exception
    when Standard::constraint_error =&gt;
      passed := true;
  end;
  if passed = false then
    raise Standard::constraint_error;
  end if;

  if Device_IO::eof(test) = false then
    raise Standard::constraint_error;
  end if;

  Device_IO::close(test);

  // Test concatenated reads
  Device_IO::open("input.tst", Device_IO::IN, test );
  test &gt;&gt; s &gt;&gt; i &gt;&gt; r &gt;&gt; b1 &gt;&gt; b2 &gt;&gt; e1 &gt;&gt; p1;

  if s /= "Hello" then 
    raise Standard::constraint_error;
  end if;

  if i /= 123 then
    raise Standard::constraint_error;
  end if;

  if r &lt; 45.66669 or r &gt; 45.67001 then
    raise Standard::constraint_error;
  end if;

  if not b1 then
    raise Standard::constraint_error;
  end if;

  if b2 then
    raise Standard::constraint_error;
  end if;

  if e1 /= Calendar::MARCH then
    raise Standard::constraint_error;
  end if;

  if p1 /= 2 then
    raise Standard::constraint_error;
  end if;
  Device_IO::close(test);
  Device_IO::delete_file("input.tst");

  console &lt;&lt; "TEST PASSED" &lt;&lt; endl;

end;

</programlisting>
</para>
</section>
</chapter>
