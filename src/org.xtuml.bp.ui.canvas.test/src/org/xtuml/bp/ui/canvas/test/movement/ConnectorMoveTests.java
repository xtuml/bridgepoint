//=====================================================================
//
//File:      $RCSfile: ConnectorMoveTests.java,v $
//Version:   $Revision: 1.7 $
//Modified:  $Date: 2013/05/10 05:54:03 $
//
// NOTE: This file was generated, but is maintained by hand.
// Generated by: UnitTestGenerator.pl
// Version:      1.10
// Matrix:       connector_move.txt
//
//(c) Copyright 2007-2014 by Mentor Graphics Corp. All rights reserved.
//
//=====================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License.  You may obtain a copy 
// of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the 
// License for the specific language governing permissions and limitations under
// the License.
//=====================================================================

package org.xtuml.bp.ui.canvas.test.movement;

import java.util.Collection;
import java.util.List;

import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.gef.GraphicalEditPart;
import org.eclipse.gef.editparts.AbstractConnectionEditPart;
import org.eclipse.gef.editparts.ZoomManager;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.ui.PlatformUI;

import org.xtuml.bp.core.Association_c;
import org.xtuml.bp.core.CorePlugin;
import org.xtuml.bp.core.InteractionParticipant_c;
import org.xtuml.bp.core.Lifespan_c;
import org.xtuml.bp.core.Message_c;
import org.xtuml.bp.core.Package_c;
import org.xtuml.bp.core.PackageableElement_c;
import org.xtuml.bp.core.SynchronousMessage_c;
import org.xtuml.bp.core.TimingMark_c;
import org.xtuml.bp.core.common.BridgePointPreferencesStore;
import org.xtuml.bp.core.common.ClassQueryInterface_c;
import org.xtuml.bp.core.common.NonRootModelElement;
import org.xtuml.bp.core.common.PersistableModelComponent;
import org.xtuml.bp.core.util.WorkspaceUtil;
import org.xtuml.bp.test.common.UITestingUtilities;
import org.xtuml.bp.ui.canvas.Connector_c;
import org.xtuml.bp.ui.canvas.GraphicalElement_c;
import org.xtuml.bp.ui.canvas.test.CanvasTest;
import org.xtuml.bp.ui.canvas.test.anchors.GraphicalAnchorTests;
import org.xtuml.bp.ui.graphics.editor.GraphicalEditor;
import org.xtuml.bp.ui.graphics.parts.ConnectorEditPart;

public class ConnectorMoveTests extends CanvasTest {
	public static boolean generateResults = false;
	public static boolean useDrawResults = false;

	String test_id = "";

	protected String getResultName() {
		return getClass().getSimpleName() + "_" + test_id;
	}

	protected GraphicalEditor fActiveEditor;
	private PointList originalPointList;
	private PointList originalOtherPointList;
	private Point originalSourcePoint;
	private Point originalTargetPoint;
	private boolean diagramZoomed;
	private ConnectorEditPart testPart;
	private static boolean initialized;

	protected GraphicalEditor getActiveEditor() {
		return fActiveEditor;
	}

	public ConnectorMoveTests(String subTypeClassName, String subTypeArg0) {
		super(subTypeClassName, subTypeArg0);
	}

	protected String getTestId(String src, String dest, String count) {
		return "test_" + src + "_" + dest + "_" + count;
	}

	protected void setUp() throws Exception {
		super.setUp();
		ConnectorEditPart.setToleranceForTests(15);
		// load the test model
		if (!initialized) {
			// set the core plugin to debugging as
			// there are some benign consistency errors
			// causing failures
			// These errors will be resolved when full
			// generic package support is complete
			CorePlugin.getDefault().setDebugging(true);
			
			WorkspaceUtil.setAutobuilding(false);

			loadProject("ConnectorMoveTests");

			CorePlugin.disableParseAllOnResourceChange();

			PersistableModelComponent sys_comp = m_sys
					.getPersistableComponent();
			sys_comp.loadComponentAndChildren(new NullProgressMonitor());
			initialized = true;
		} else {
			// undo the last change
			if (m_sys.getTransactionManager().getUndoAction().isEnabled()) {
				m_sys.getTransactionManager().getUndoAction().run();
			}
		}
	}

	protected void tearDown() throws Exception {
		super.tearDown();
		testPart = null;
		diagramZoomed = false;
		originalPointList = null;
		originalOtherPointList = null;
		originalSourcePoint = null;
		originalTargetPoint = null;
		fActiveEditor = null;
		ConnectorEditPart.setToleranceForTests(-1);
		PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage()
				.closeAllEditors(false);
	}

	/**
	 * "CDEF" is one of the degrees of freedom as specified in this issues test
	 * matrix. This routine gets the "CDEF" instance from the given name.
	 * 
	 * @param element
	 *            The degree of freedom instance to retrieve
	 * @return A model element used in the test as specified by the test matrix
	 */
	NonRootModelElement selectCDEF(String element) {
		// there is no CDEF instances for selection
		return null;
	}

	/**
	 * "AB" is one of the degrees of freedom as specified in this issues test
	 * matrix. This routine gets the "AB" instance from the given name.
	 * 
	 * @param element
	 *            The degree of freedom instance to retrieve
	 * @return A model element used in the test as specified by the test matrix
	 */
	NonRootModelElement selectAB(String element) {
		NonRootModelElement uut = null;
		Package_c testPackage = getPackageContainerForTest();
		if (test_id.contains("A1B1") || test_id.contains("A1B3")) {
			Association_c association = getTestAssociation(testPackage);
			uut = association;
		} else if (test_id.contains("A2B3")) {
			TimingMark_c mark = getTestTimingMark(testPackage);
			uut = mark;
		} else {
			SynchronousMessage_c message = getTestMessage(testPackage);
			uut = message;
		}
		if (uut == null) {
			fail("Unable to locate test element for test: " + test_id);
		}
		return uut;
	}

	private TimingMark_c getTestTimingMark(Package_c testPackage) {
		Lifespan_c span = Lifespan_c.getOneSQ_LSOnR930(InteractionParticipant_c
				.getManySQ_PsOnR8001(PackageableElement_c
						.getManyPE_PEsOnR8000(testPackage)));
		TimingMark_c mark = TimingMark_c.getOneSQ_TMOnR931(span,
				new ClassQueryInterface_c() {

					@Override
					public boolean evaluate(Object arg0) {
						return ((TimingMark_c) arg0).getName().equals(
								"TestConnector");
					}
				});
		return mark;
	}

	private SynchronousMessage_c getTestMessage(Package_c testPackage) {
		SynchronousMessage_c testSync = SynchronousMessage_c
				.getOneMSG_SMOnR1018(Message_c
						.getManyMSG_MsOnR8001(PackageableElement_c
								.getManyPE_PEsOnR8000(testPackage)),
						new ClassQueryInterface_c() {

							@Override
							public boolean evaluate(Object arg0) {
								return ((SynchronousMessage_c) arg0).getName()
										.equals("TestConnector");
							}
						});
		return testSync;
	}

	private Association_c getTestAssociation(Package_c testPackage) {
		Association_c testAssoc = Association_c.getOneR_RELOnR8001(
				PackageableElement_c.getManyPE_PEsOnR8000(testPackage),
				new ClassQueryInterface_c() {

					@Override
					public boolean evaluate(Object arg0) {
						return ((Association_c) arg0).getNumb() == 1;
					}
				});
		return testAssoc;
	}

	private Package_c getPackageContainerForTest() {
		Package_c root = Package_c.getOneEP_PKGOnR1401(m_sys);
		Collection<?> rootChildren = root.getPersistableComponent().getChildren();
		for(Object child : rootChildren) {
			PersistableModelComponent sysChild = (PersistableModelComponent) child;
			if (sysChild.getRootModelElement().getName().equals(
					getParentPackageNameFromTestId())) {
				NonRootModelElement parent = sysChild.getRootModelElement();
				Collection<?> children = parent.getPersistableComponent()
						.getChildren();
				for (Object parentChild : children) {
					PersistableModelComponent childComp = (PersistableModelComponent) parentChild;
					if (childComp.getRootModelElement().getName().equals(
							getPackageNameFromTestId())) {
						return (Package_c) childComp.getRootModelElement();
					}
				}				
			}
		}
		return null;
	}

	protected String getParentPackageNameFromTestId() {
		String[] split = test_id.split("_");
		return split[1];
	}

	protected String getPackageNameFromTestId() {
		String[] split = test_id.split("_");
		return split[2];
	}

	/**
	 * This routine performs the action associated with a matrix cell. The
	 * parameters represent model instances aquired based on the specifed column
	 * instance and row instance.
	 * 
	 * @param columnInstance
	 *            Model instance from the column
	 * @param rowInstance
	 *            Model instance from the row
	 */
	void AB_CDEF_Action(NonRootModelElement columnInstance,
			NonRootModelElement rowInstance) {
		// the action is to move the connector or segment
		ConnectorEditPart testPart = getTestPart(columnInstance);
		int segmentOver = 0;
		if (test_id.contains("D3")) {
			segmentOver = 1;
			if (test_id.contains("C1")) {
				segmentOver = 0;
			}
		} else if (test_id.contains("D2")) {
			segmentOver = 2;
			if (test_id.contains("C2")) {
				segmentOver = 1;
			}
		}
		moveConnector(testPart, segmentOver);
	}

	private void moveConnector(ConnectorEditPart testPart, int segmentOver) {
		// for all cases simply move the connector/segment up by 24
		Point delta = new Point(0, -24);
		// cache the original points for comparison
		originalPointList = testPart.getConnectionFigure().getPoints()
				.getCopy();
		// cache the other connector if this is an E2 variation
		if(test_id.contains("E2")) {
			originalOtherPointList = getOtherPartForTest()
					.getConnectionFigure().getPoints().getCopy();
		}
		// cache any source or target connectors anchored to us
		Connection targetCon = getTargetConnectorForTestPart(testPart);
		if (targetCon != null) {
			originalTargetPoint = targetCon.getPoints().getLastPoint();
		}
		Connection sourceCon = getSourceConnectorForTestPart(testPart);
		if (sourceCon != null) {
			originalSourcePoint = sourceCon.getPoints().getFirstPoint();
		}
		// now perform the move, by pressing down on the middle-middle of the
		// segment over
		UITestingUtilities.clearGraphicalSelection();
		UITestingUtilities.addElementToGraphicalSelection(testPart);
		if(test_id.contains("E2")) {
			// add other element to selection
			UITestingUtilities
					.addElementToGraphicalSelection(getOtherPartForTest());
		}
		Point mousePoint = getSegment(testPart, segmentOver).getMidpoint();
		testPart.getFigure().translateToAbsolute(mousePoint);
		UITestingUtilities.doMouseMove(mousePoint.x, mousePoint.y);
		UITestingUtilities.doMousePress(mousePoint.x, mousePoint.y);
		UITestingUtilities.doMouseMove(mousePoint.x + delta.x, mousePoint.y
				+ delta.y);
		UITestingUtilities.doMouseRelease(mousePoint.x + delta.x, mousePoint.y
				+ delta.y);
	}

	private PointList getSegment(ConnectorEditPart testPart, int segmentOver) {
		List<?> lineSegs = PointListUtilities.getLineSegments(testPart
				.getConnectionFigure().getPoints().getCopy());
		LineSeg seg = (LineSeg) lineSegs.get(segmentOver);
		PointList segmentPoints = new PointList(new int[] { seg.getOrigin().x,
				seg.getOrigin().y, seg.getTerminus().x, seg.getTerminus().y });
		
		return new PointList(new int[] { segmentPoints.getFirstPoint().x,
				segmentPoints.getFirstPoint().y, segmentPoints.getMidpoint().x,
				segmentPoints.getMidpoint().y });
	}

	private AbstractConnectionEditPart getOtherPartForTest() {
		GraphicalElement_c[] others = GraphicalElement_c
				.getManyGD_GEsOnR1(getActiveEditor().getModel());
		Object object = null;
		for (int i = 0; i < others.length; i++) {
			NonRootModelElement represents = (NonRootModelElement) others[i]
					.getRepresents();
			if (represents instanceof Association_c) {
				Association_c assoc = (Association_c) represents;
				if (assoc.getNumb() == 2) {
					object = Connector_c.getOneGD_CONOnR2(others[i]);
					break;
				}
			}
			if (represents.getName().equals("OtherConnector")) {
				object = Connector_c.getOneGD_CONOnR2(others[i]);
				break;
			}
		}
		return (AbstractConnectionEditPart) UITestingUtilities
				.getEditorPartFor(object);
	}

	private ConnectorEditPart getTestPart(NonRootModelElement columnInstance) {
		if (testPart == null) {
			// open the editor for the test
			fActiveEditor = UITestingUtilities.getGraphicalEditorFor(
					columnInstance, false, true);
			adjustZoom();
			testPart = (ConnectorEditPart) UITestingUtilities
					.getEditorPartFor(getConnectorInstance(columnInstance));
		}
		return testPart;
	}

	private Connector_c getConnectorInstance(NonRootModelElement testElement) {
		GraphicalElement_c[] elements = GraphicalElement_c
				.getManyGD_GEsOnR1(fActiveEditor.getModel());
		GraphicalElement_c element = null;
		for(int i = 0; i < elements.length; i++) {
			if(elements[i].getRepresents() == testElement) {
				element = elements[i];
			}
		}
		assertNotNull("Unable to find graphical element for testing.", element);
		return Connector_c.getOneGD_CONOnR2(element);
	}

	private void adjustZoom() {
		// we want to zoom all, then set zoom to 100% for
		// easier positional calculations
		// fill the available space with the editor
		// as nothing else is interesting to this
		// test
		if(!PlatformUI.getWorkbench().getActiveWorkbenchWindow()
				.getActivePage().isPageZoomed()) {
			PlatformUI.getWorkbench().getActiveWorkbenchWindow()
					.getActivePage().toggleZoom(
							PlatformUI.getWorkbench()
									.getActiveWorkbenchWindow()
									.getActivePage()
									.getActivePartReference());
		}
		if(!diagramZoomed) { 
			// disable grid snapping to allow exact
			// positions
			CorePlugin.getDefault().getPreferenceStore().setValue(
					BridgePointPreferencesStore.SNAP_TO_GRID, false);
			getActiveEditor().configureGridOptions();
			ZoomManager zoomManager = (ZoomManager) getActiveEditor()
					.getAdapter(ZoomManager.class);
			getActiveEditor().zoomAll();
			//zoomManager.setZoom(1);
			while (PlatformUI.getWorkbench().getDisplay().readAndDispatch())
				;
			diagramZoomed = true;
		}
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_targetConnectionEndMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		assertNotNull("No source point was cached for testing.",
				originalTargetPoint);
		Connection targetCon = getTargetConnectorForTestPart(getTestPart(source));
		boolean result = !targetCon.getPoints().getLastPoint().equals(
				originalTargetPoint);
		if (result) {
			// additionally assure that the point is still on the line
			result = GraphicalAnchorTests.isPointOnPointList(
					getTestPart(source).getConnectionFigure().getPoints(),
					targetCon.getPoints().getLastPoint());
		}
		return result;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_firstBendpointMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		ConnectorEditPart testPart = getTestPart(source);
		Point point = testPart.getConnectionFigure().getPoints().getPoint(1);
		Point point2 = originalPointList.getPoint(1);
		testPart.getConnectionFigure().translateToAbsolute(point);
		testPart.getConnectionFigure().translateToAbsolute(point2);
		int difference = point.getDifference(point2).height;
		return  Math.abs(difference) - 24 < 5;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_sourceConnectionEndMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		assertNotNull("No source point was cached for testing.",
				originalSourcePoint);
		Connection sourceCon = getSourceConnectorForTestPart(getTestPart(source));
		boolean result = !sourceCon.getPoints().getFirstPoint().equals(
				originalSourcePoint);
		if (result) {
			// additionally assure that the point is still on the line
			result = GraphicalAnchorTests.isPointOnPointList(
					getTestPart(source).getConnectionFigure().getPoints(),
					sourceCon.getPoints().getFirstPoint());
		}
		return result;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_sourceConnectionEndNotMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		assertNotNull("No source point was cached for testing.",
				originalSourcePoint);
		Connection sourceCon = getSourceConnectorForTestPart(getTestPart(source));
		return sourceCon.getPoints().getFirstPoint()
				.equals(originalSourcePoint);
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_endAnchorMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		ConnectorEditPart testPart = getTestPart(source);
		Point point = testPart.getConnectionFigure().getPoints().getLastPoint();
		Point point2 = originalPointList.getLastPoint();
		testPart.getConnectionFigure().translateToAbsolute(point);
		testPart.getConnectionFigure().translateToAbsolute(point2);
		return (point.getDifference(point2).height) - 24 < 5;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_targetConnectionEndNotMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		assertNotNull("No target point was cached for testing.",
				originalTargetPoint);
		Connection target = getTargetConnectorForTestPart(getTestPart(source));
		return target.getPoints().getLastPoint().equals(originalTargetPoint);
	}

	private Connection getTargetConnectorForTestPart(ConnectorEditPart testPart) {
		List<?> targetConnections = testPart.getTargetConnections();
		if(targetConnections != null && !targetConnections.isEmpty()) {
			return (Connection) ((GraphicalEditPart) targetConnections.get(0))
					.getFigure();
		}
		return null;
	}

	private Connection getSourceConnectorForTestPart(ConnectorEditPart testPart) {
		List<?> sourceConnections = testPart.getSourceConnections();
		if(sourceConnections != null && !sourceConnections.isEmpty()) {
			return (Connection) ((GraphicalEditPart) sourceConnections.get(0))
					.getFigure();
		}
		return null;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_startAnchorMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		ConnectorEditPart testPart = getTestPart(source);
		Point point = testPart.getConnectionFigure().getPoints()
				.getFirstPoint();
		Point point2 = originalPointList.getFirstPoint();
		testPart.getConnectionFigure().translateToAbsolute(point);
		testPart.getConnectionFigure().translateToAbsolute(point2);
		return (point.getDifference(point2).height) - 24 < 5;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_secondBendpointMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		ConnectorEditPart testPart = getTestPart(source);
		Point point = testPart.getConnectionFigure().getPoints().getPoint(2);
		Point point2 = originalPointList.getPoint(2);
		testPart.getConnectionFigure().translateToAbsolute(point);
		testPart.getConnectionFigure().translateToAbsolute(point2);
		return (point.getDifference(point2).height) - 24 < 5;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_allPointsMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		// all points should move the y delta which is -24
		ConnectorEditPart testPart = getTestPart(source);
		return allPointsMoved(testPart.getConnectionFigure().getPoints(),
				originalPointList);
	}

	private boolean allPointsMoved(PointList points, PointList otherPoints) {
		for (int i = 0; i < points.size(); i++) {
			Point point = points.getPoint(i);
			Point point2 = otherPoints.getPoint(i);
			int difference = ((point.getDifference(point2).height) - 24);
			// try the other direction as well
			if(difference < 0) {
				Math.abs(difference);
			}
			if (difference > 5) {
				return false;
			}
		}
		return true;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_otherSelectedConnectorMoved(NonRootModelElement source,
			NonRootModelElement destination) {
		// all points in the other connection should have moved -24
		AbstractConnectionEditPart otherPart = getOtherPartForTest();
		PointList otherPoints = otherPart.getConnectionFigure().getPoints();
		testPart.getConnectionFigure().translateToAbsolute(otherPoints);
		testPart.getConnectionFigure().translateToAbsolute(originalOtherPointList);
		return allPointsMoved(originalOtherPointList, otherPoints);
	}

}
