//=====================================================================
//
//File:      $RCSfile: RectilinearRoutingTests.java,v $
//Version:   $Revision: 1.3 $
//Modified:  $Date: 2013/01/10 22:44:41 $
//
// NOTE: This file was generated, but is maintained by hand.
// Generated by: UnitTestGenerator.pl
// Version:      1.12
// Matrix:       rectilinear_routing.txt
//
//(c) Copyright 2007-2014 by Mentor Graphics Corp. All rights reserved.
//
//=====================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License.  You may obtain a copy 
// of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the 
// License for the specific language governing permissions and limitations under
// the License.
//=====================================================================

package org.xtuml.bp.ui.canvas.test.routing;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.draw2d.Connection;
import org.eclipse.draw2d.PolylineConnection;
import org.eclipse.draw2d.geometry.Point;
import org.eclipse.draw2d.geometry.PointList;
import org.eclipse.gef.editparts.AbstractGraphicalEditPart;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.LineSeg;
import org.eclipse.gmf.runtime.draw2d.ui.geometry.PointListUtilities;
import org.eclipse.gmf.runtime.draw2d.ui.internal.routers.OrthogonalRouterUtilities;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.ui.PlatformUI;

import org.xtuml.bp.core.CorePlugin;
import org.xtuml.bp.core.Ooaofooa;
import org.xtuml.bp.core.common.BridgePointPreferencesStore;
import org.xtuml.bp.core.common.NonRootModelElement;
import org.xtuml.bp.core.ui.Selection;
import org.xtuml.bp.test.common.UITestingUtilities;
import org.xtuml.bp.ui.canvas.Connector_c;
import org.xtuml.bp.ui.canvas.GraphicalElement_c;
import org.xtuml.bp.ui.canvas.Model_c;
import org.xtuml.bp.ui.canvas.Shape_c;
import org.xtuml.bp.ui.canvas.test.CanvasTest;
import org.xtuml.bp.ui.canvas.test.actions.OpenTestEditorAction;
import org.xtuml.bp.ui.graphics.editor.GraphicalEditor;
import org.xtuml.bp.ui.graphics.editor.ModelEditor;
import org.xtuml.bp.ui.graphics.parts.ConnectorEditPart;
import org.xtuml.bp.ui.graphics.parts.DiagramEditPart;
import org.xtuml.bp.ui.graphics.parts.ShapeEditPart;
import org.xtuml.bp.utilities.ui.CanvasUtilities;

public class RectilinearRoutingTests extends CanvasTest {
	public static boolean generateResults = false;
	public static boolean useDrawResults = false;

	String test_id = "";

	protected String getResultName() {
		return getClass().getSimpleName() + "_" + test_id;
	}

	protected static GraphicalEditor fActiveEditor;
	private ConnectorEditPart testElement;
	private ConnectorEditPart otherElement;
	private ConnectorEditPart otherCreationElement;
	private PointList previousPoints;
	private PointList otherElementPreviousPoints;
	private List<AbstractGraphicalEditPart> terminals;

	protected GraphicalEditor getActiveEditor() {
		return fActiveEditor;
	}

	public RectilinearRoutingTests(String subTypeClassName, String subTypeArg0) {
		super(null, subTypeArg0);
	}

	protected String getTestId(String src, String dest, String count) {
		return "test_" + count;
	}

	protected void setUp() throws Exception {
		super.setUp();
		Ooaofooa.disableChangeNotification();
		Ooaofooa.setPersistEnabled(false);
		CorePlugin.getDefault().getPreferenceStore().setValue(BridgePointPreferencesStore.USE_DEFAULT_NAME_FOR_CREATION,
				true);
		// enable rectilinear routing
		CorePlugin.getDefault().getPreferenceStore().setValue(
				BridgePointPreferencesStore.DEFAULT_ROUTING_STYLE,
				BridgePointPreferencesStore.RECTILINEAR_ROUTING);
		// close any other editors
		PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage()
				.closeAllEditors(false);
		// open the test editor
		Selection.getInstance().clear();
		Selection.getInstance().addToSelection(m_sys);
		OpenTestEditorAction action = new OpenTestEditorAction();
		action.run(null);
		fActiveEditor = ((ModelEditor) PlatformUI.getWorkbench()
				.getActiveWorkbenchWindow().getActivePage().getActiveEditor())
				.getGraphicalEditor();
		PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage()
				.toggleZoom(
						PlatformUI.getWorkbench().getActiveWorkbenchWindow()
								.getActivePage().getActivePartReference());
		fActiveEditor.getSite().getShell().setSize(1280, 1024);
		while (PlatformUI.getWorkbench().getDisplay().readAndDispatch())
			;
	}

	protected void tearDown() throws Exception {
		if(fActiveEditor != null) {
			Model_c model = fActiveEditor.getModel();
			GraphicalElement_c[] elements = GraphicalElement_c
					.getManyGD_GEsOnR1(model);
			for (int i = 0; i < elements.length; i++) {
				elements[i].Dispose();
			}
			fActiveEditor.refresh();
			Ooaofooa.enableChangeNotification();
			fActiveEditor = null;
		}
		super.tearDown();
	}

	@Override
	protected void initialSetup() throws Exception {

	}

	@Override
	public String getName() {
		StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
		for(StackTraceElement trace : stackTrace) {
			if(trace.getMethodName().contains("doTest")) {
				return trace.getMethodName();
			}
		}
		return super.getName();
	}

	/**
	 * "GH" is one of the degrees of freedom as specified in this issues test
	 * matrix. This routine gets the "GH" instance from the given name.
	 * 
	 * @param element
	 *            The degree of freedom instance to retrieve
	 * @return A model element used in the test as specified by the test matrix
	 */
	NonRootModelElement selectCD(String element) {
		// nothing to select
		return null;
	}

	/**
	 * "ABCDEF" is one of the degrees of freedom as specified in this issues
	 * test matrix. This routine gets the "ABCDEF" instance from the given name.
	 * 
	 * @param element
	 *            The degree of freedom instance to retrieve
	 * @return A model element used in the test as specified by the test matrix
	 */
	NonRootModelElement selectAB(String element) {
		createAndConfigureTestElement(element);
		return null;
	}

	private NonRootModelElement createAndConfigureTestElement(String element) {
		String key = getElementIdFromTestString(element);
		testElement = createElementForKey(key);
		configureTestElement();
		return null;
	}

	private void configureTestElement() {
		PointList points = testElement.getConnectionFigure().getPoints();
		Point aPoint = points.getFirstPoint().getCopy();
		Point bPoint = points.getLastPoint().getCopy();
		if (getName().contains("B2")) {
			// need to add another connector to test multiple selection
			LineSeg seg = new LineSeg(aPoint, bPoint);
			Point start = aPoint.getCopy();
			start.y = start.y - 24;
			Point end = bPoint.getCopy();
			end.y = end.y - 24;
			if (seg.isVertical()) {
				start = aPoint.getCopy();
				start.x = start.x - 24;
				end = bPoint.getCopy();
				end.x = end.x - 24;
				if (testElement.getConnectionFigure().getSourceAnchor()
						.getOwner() != null
						&& testElement.getConnectionFigure().getSourceAnchor()
								.getOwner() instanceof Connection) {
					start = aPoint.getCopy();
					end = bPoint.getCopy();
					if(getName().contains("D4")) {
						start.y = ((PolylineConnection) testElement
								.getConnectionFigure().getSourceAnchor()
								.getOwner()).getPoints().getBounds()
								.getBottom().y;
						end.y = start.y + 100;
					} else {
						start.y = ((PolylineConnection) testElement
								.getConnectionFigure().getSourceAnchor()
								.getOwner()).getPoints().getBounds().y;
						end.y = start.y - 100;						
					}
				}
				if (testElement.getConnectionFigure().getTargetAnchor()
						.getOwner() != null
						&& testElement.getConnectionFigure().getTargetAnchor()
								.getOwner() instanceof Connection) {
					start = aPoint.getCopy();
					end = bPoint.getCopy();
					if (getName().contains("D4")) {
						start.y = ((PolylineConnection) testElement
								.getConnectionFigure().getTargetAnchor()
								.getOwner()).getPoints().getBounds()
								.getBottom().y;
						end.y = start.y + 100;
					} else {
						start.y = ((PolylineConnection) testElement
								.getConnectionFigure().getTargetAnchor()
								.getOwner()).getPoints().getBounds().y;
						end.y = start.y - 100;
					}			
				}
			}
			testElement.getFigure().translateToAbsolute(start);
			testElement.getFigure().translateToAbsolute(end);
			UITestingUtilities.createConnectorInDiagram(getActiveEditor(),
					start.getSWTPoint(), end.getSWTPoint(), "Connector");
			Model_c model = getActiveEditor().getModel();
			GraphicalElement_c[] elements = GraphicalElement_c
					.getManyGD_GEsOnR1(model);
			GraphicalElement_c newElement = elements[elements.length - 1];
			otherElement = (ConnectorEditPart) getActiveEditor()
					.getGraphicalViewer().getEditPartRegistry().get(
							Connector_c.getOneGD_CONOnR2(newElement));
		}
	}

	private ConnectorEditPart createElementForKey(String key) {
		terminals = createTerminalElements(key);
		Object aTerminal = terminals.get(0);
		Object otherTerminal = terminals.get(1);
		boolean adjustStart = false;
		boolean adjustEnd = false;
		if (key.contains("A4") || key.contains("A5")) {
			adjustStart = true;
		}
		if (key.contains("A1") || key.contains("A2")) {
			adjustEnd = true;
		}
		Point aPoint = null;
		Point bPoint = null;
		if (aTerminal instanceof ConnectorEditPart) {
			// for connectors use the midpoint
			aPoint = ((ConnectorEditPart) aTerminal).getConnectionFigure()
					.getPoints().getMidpoint();
		} else if (aTerminal instanceof DiagramEditPart) {
			// for white space, locate the other terminal (will not
			// be whitespace) and create a horizontal line
			Point otherPoint = ((AbstractGraphicalEditPart) otherTerminal)
					.getFigure().getBounds().getCenter();
			if(otherTerminal instanceof ConnectorEditPart) {
				otherPoint = ((ConnectorEditPart) otherTerminal)
						.getConnectionFigure().getPoints().getMidpoint();
			}
			aPoint = otherPoint.getCopy();
			aPoint.x = aPoint.x - 200;
		} else {
			// for shapes draw from center to center
			ShapeEditPart shape = (ShapeEditPart) aTerminal;
			aPoint = shape.getFigure().getBounds().getCenter();
		}
		if (otherTerminal instanceof DiagramEditPart) {
			// for white space, locate the other terminal (will not
			// be whitespace) and create a horizontal line
			Point otherPoint = ((AbstractGraphicalEditPart) aTerminal)
					.getFigure().getBounds().getCenter();
			if(aTerminal instanceof ConnectorEditPart) {
				otherPoint = ((ConnectorEditPart) aTerminal)
						.getConnectionFigure().getPoints().getMidpoint();
			}
			bPoint = otherPoint.getCopy();
			bPoint.x = bPoint.x + 200;
		} else if (otherTerminal instanceof ConnectorEditPart) {
			bPoint = ((ConnectorEditPart) otherTerminal).getConnectionFigure()
					.getPoints().getMidpoint();
		} else {
			// for shapes draw from center to center
			ShapeEditPart shape = (ShapeEditPart) otherTerminal;
			bPoint = shape.getFigure().getBounds().getCenter();
		}
		// create a connector at the determined points
		if (adjustStart) {
			if (getName().contains("D2") || getName().contains("D1")) {
				// connection needs to come from
				// the east
				aPoint = bPoint.getCopy();
				aPoint.x = aPoint.x + 200;
			} else if (getName().contains("D3")) {
				// from the west
				aPoint = bPoint.getCopy();
				aPoint.x = aPoint.x - 200;
			} else if (getName().contains("D4")) {
				// from the north
				if (otherTerminal instanceof ConnectorEditPart) {
					aPoint = ((ConnectorEditPart) otherTerminal)
							.getConnectionFigure().getPoints().getFirstPoint()
							.getCopy();
					aPoint.y = aPoint.y - 200;
				} else {
					aPoint = ((AbstractGraphicalEditPart) otherTerminal)
							.getFigure().getBounds().getTop();
					aPoint.y = aPoint.y - 200;
				}
			} else if (getName().contains("D5")) {
				// from the south
				if (otherTerminal instanceof ConnectorEditPart) {
					aPoint = ((ConnectorEditPart) otherTerminal)
							.getConnectionFigure().getPoints().getLastPoint()
							.getCopy();
					aPoint.y = aPoint.y + 150;
				} else {
					aPoint = ((AbstractGraphicalEditPart) otherTerminal)
							.getFigure().getBounds().getBottom();
					aPoint.y = aPoint.y + 200;
				}
			}
		}
		if (adjustEnd) {
			if (getName().contains("D2") || getName().contains("D1")) {
				// connection needs to come from
				// the east
				bPoint = aPoint.getCopy();
				bPoint.x = bPoint.x + 200;
			} else if (getName().contains("D3")) {
				// from the west
				bPoint = aPoint.getCopy();
				bPoint.x = bPoint.x - 200;
			} else if (getName().contains("D4")) {
				// from the north
				if (aTerminal instanceof ConnectorEditPart) {
					bPoint = ((ConnectorEditPart) aTerminal)
							.getConnectionFigure().getPoints().getFirstPoint()
							.getCopy();
					bPoint.y = bPoint.y - 200;
				} else {
					bPoint = ((AbstractGraphicalEditPart) aTerminal)
							.getFigure().getBounds().getTop();
					bPoint.y = bPoint.y - 200;
				}
			} else if (getName().contains("D5")) {
				// from the south
				if (aTerminal instanceof ConnectorEditPart) {
					bPoint = ((ConnectorEditPart) aTerminal)
							.getConnectionFigure().getPoints().getLastPoint()
							.getCopy();
					bPoint.y = bPoint.y + 150;
				} else {
					bPoint = ((AbstractGraphicalEditPart) aTerminal)
							.getFigure().getBounds().getBottom();
					bPoint.y = bPoint.y + 200;
				}
			}
		}
		((AbstractGraphicalEditPart) aTerminal).getFigure()
				.translateToAbsolute(aPoint);
		((AbstractGraphicalEditPart) otherTerminal).getFigure()
				.translateToAbsolute(bPoint);
		UITestingUtilities.createConnectorInDiagram(getActiveEditor(), aPoint
				.getSWTPoint(), bPoint.getSWTPoint(), "Connector");
		fActiveEditor.refresh();
		Model_c model = getActiveEditor().getModel();
		GraphicalElement_c[] elements = GraphicalElement_c
				.getManyGD_GEsOnR1(model);
		GraphicalElement_c newElement = elements[elements.length - 1];
		if (getName().contains("C1")) {
			// need to test offset creation as well
			// create another connector above the main one
			aPoint.translate(0, -24);
			bPoint.translate(0, -48);
			UITestingUtilities.createConnectorInDiagram(getActiveEditor(),
					aPoint.getSWTPoint(), bPoint.getSWTPoint(), "Connector");
			fActiveEditor.refresh();
			elements = GraphicalElement_c.getManyGD_GEsOnR1(model);
			GraphicalElement_c otherNewElement = elements[elements.length - 1];
			otherCreationElement = (ConnectorEditPart) getActiveEditor()
					.getGraphicalViewer().getEditPartRegistry().get(
							Connector_c.getOneGD_CONOnR2(otherNewElement));
		}
		return (ConnectorEditPart) getActiveEditor().getGraphicalViewer()
				.getEditPartRegistry().get(
						Connector_c.getOneGD_CONOnR2(newElement));
	}

	private List<AbstractGraphicalEditPart> createTerminalElements(String key) {
		while(PlatformUI.getWorkbench().getDisplay().readAndDispatch());
		// create terminal combinations
		List<AbstractGraphicalEditPart> terminals = new ArrayList<AbstractGraphicalEditPart>();
		String aKey = "A" + key.charAt(key.indexOf("A") + 1);
		if (aKey.equals("A1")) {
			UITestingUtilities.createShapeInDiagram(getActiveEditor(),
					new Rectangle(200, 200, 200, 200), "Shape");
			fActiveEditor.refresh();
			GraphicalElement_c[] elements = GraphicalElement_c
					.getManyGD_GEsOnR1(getActiveEditor().getModel());
			GraphicalElement_c newElement = elements[elements.length - 1];
			Shape_c shape = Shape_c.getOneGD_SHPOnR2(newElement);
			ShapeEditPart shapePart = (ShapeEditPart) getActiveEditor()
					.getGraphicalViewer().getEditPartRegistry().get(shape);
			terminals.add(shapePart);
			terminals.add((AbstractGraphicalEditPart) getActiveEditor()
					.getGraphicalViewer().getContents());
		} else if (aKey.equals("A2")) {
			UITestingUtilities.createConnectorInDiagram(getActiveEditor(),
					new Point(250, 300).getSWTPoint(), new Point(250, 600)
							.getSWTPoint(), "Connector");
			fActiveEditor.refresh();
			GraphicalElement_c[] elements = GraphicalElement_c
					.getManyGD_GEsOnR1(getActiveEditor().getModel());
			GraphicalElement_c newElement = elements[elements.length - 1];
			Connector_c connector = Connector_c.getOneGD_CONOnR2(newElement);
			ConnectorEditPart conPart = (ConnectorEditPart) getActiveEditor()
					.getGraphicalViewer().getEditPartRegistry().get(connector);
			terminals.add(conPart);
			terminals.add((AbstractGraphicalEditPart) getActiveEditor()
					.getGraphicalViewer().getContents());
		} else if (aKey.equals("A3")) {
			// add diagram edit part
			terminals.add((AbstractGraphicalEditPart) getActiveEditor()
					.getGraphicalViewer().getContents());
			// need a shape, cannot do diagram to diagram
			UITestingUtilities.createShapeInDiagram(getActiveEditor(),
					new Rectangle(400, 200, 200, 200), "Shape");
			fActiveEditor.refresh();
			GraphicalElement_c[] elements = GraphicalElement_c
					.getManyGD_GEsOnR1(getActiveEditor().getModel());
			GraphicalElement_c newElement = elements[elements.length - 1];
			Shape_c shape = Shape_c.getOneGD_SHPOnR2(newElement);
			ShapeEditPart shapePart = (ShapeEditPart) getActiveEditor()
					.getGraphicalViewer().getEditPartRegistry().get(shape);
			terminals.add(shapePart);
		} else if (aKey.equals("A4")) {
			terminals.add((AbstractGraphicalEditPart) getActiveEditor()
					.getGraphicalViewer().getContents());
			UITestingUtilities.createShapeInDiagram(getActiveEditor(),
					new Rectangle(200, 200, 200, 200), "Shape");
			fActiveEditor.refresh();
			GraphicalElement_c[] elements = GraphicalElement_c
					.getManyGD_GEsOnR1(getActiveEditor().getModel());
			GraphicalElement_c newElement = elements[elements.length - 1];
			Shape_c shape = Shape_c.getOneGD_SHPOnR2(newElement);
			ShapeEditPart shapePart = (ShapeEditPart) getActiveEditor()
					.getGraphicalViewer().getEditPartRegistry().get(shape);
			terminals.add(shapePart);
		} else if (aKey.equals("A5")) {
			terminals.add((AbstractGraphicalEditPart) getActiveEditor()
					.getGraphicalViewer().getContents());
			UITestingUtilities.createConnectorInDiagram(getActiveEditor(),
					new Point(250, 300).getSWTPoint(), new Point(250, 600)
							.getSWTPoint(), "Connector");
			fActiveEditor.refresh();
			GraphicalElement_c[] elements = GraphicalElement_c
					.getManyGD_GEsOnR1(getActiveEditor().getModel());
			GraphicalElement_c newElement = elements[elements.length - 1];
			Connector_c connector = Connector_c.getOneGD_CONOnR2(newElement);
			ConnectorEditPart conPart = (ConnectorEditPart) getActiveEditor()
					.getGraphicalViewer().getEditPartRegistry().get(connector);
			terminals.add(conPart);
		} else if (aKey.equals("A6")) {
			// need a shape, cannot do diagram to diagram
			UITestingUtilities.createShapeInDiagram(getActiveEditor(),
					new Rectangle(400, 200, 200, 200), "Shape");
			fActiveEditor.refresh();
			GraphicalElement_c[] elements = GraphicalElement_c
					.getManyGD_GEsOnR1(getActiveEditor().getModel());
			GraphicalElement_c newElement = elements[elements.length - 1];
			Shape_c shape = Shape_c.getOneGD_SHPOnR2(newElement);
			ShapeEditPart shapePart = (ShapeEditPart) getActiveEditor()
					.getGraphicalViewer().getEditPartRegistry().get(shape);
			terminals.add(shapePart);
			// add diagram edit part
			terminals.add((AbstractGraphicalEditPart) getActiveEditor()
					.getGraphicalViewer().getContents());
		}
		return terminals;
	}

	private String getElementIdFromTestString(String element) {
		String aKey = "A" + element.charAt(element.indexOf("A") + 1);
		String bKey = "B" + element.charAt(element.indexOf("B") + 1);
		return aKey + bKey;
	}

	/**
	 * This routine performs the action associated with a matrix cell. The
	 * parameters represent model instances aquired based on the specifed column
	 * instance and row instance.
	 * 
	 * @param columnInstance
	 *            Model instance from the column
	 * @param rowInstance
	 *            Model instance from the row
	 */
	void CD_AB_Action(NonRootModelElement columnInstance,
			NonRootModelElement rowInstance) {
		previousPoints = testElement.getConnectionFigure().getPoints()
				.getCopy();
		if (otherElement != null) {
			otherElementPreviousPoints = otherElement.getConnectionFigure()
					.getPoints().getCopy();
		}
		boolean start = getName().contains("A1") || getName().contains("A2")
				|| getName().contains("A3");
		AbstractGraphicalEditPart terminal = (AbstractGraphicalEditPart) terminals
				.get(0);
		if (!start) {
			terminal = (AbstractGraphicalEditPart) terminals.get(1);
		}
		org.eclipse.draw2d.geometry.Rectangle terminalBounds = terminal.getFigure().getBounds().getCopy();
		testElement.getConnectionFigure().translateToAbsolute(terminalBounds);
		// for C1D1, connectors will have been created
		// already
		// for C2 move a segment
		if (getName().contains("C2") || getName().contains("C3")) {
			UITestingUtilities.clearGraphicalSelection();
			if (getName().contains("B2")) {
				UITestingUtilities.addElementToGraphicalSelection(otherElement);
			}
			UITestingUtilities.addElementToGraphicalSelection(testElement);
		}
		if (getName().contains("C2")) {
			LineSeg seg = null;
			// if A1-A3 move the start segment
			if (start) {
				List<?> segments = PointListUtilities
						.getLineSegments(testElement.getConnectionFigure()
								.getPoints());
				seg = (LineSeg) segments.get(0);
			} else {
				// otherwise use the last segment
				List<?> segments = PointListUtilities
						.getLineSegments(testElement.getConnectionFigure()
								.getPoints());
				seg = (LineSeg) segments.get(segments.size() - 1);
			}
			Point location = new Point(
					(seg.getTerminus().x + seg.getOrigin().x) / 2, seg
							.getOrigin().y);
			if(seg.isVertical()) {
				location = new Point(seg.getOrigin().x,
						(seg.getTerminus().y + seg.getOrigin().y) / 2);
			}
			if(!start) {
				location = new Point((seg.getOrigin().x + seg.getTerminus().x) / 2, seg
						.getTerminus().y);
				if(seg.isVertical()) {
					location = new Point(seg.getTerminus().x,
							(seg.getOrigin().y + seg.getTerminus().y) / 2);					
				}
			}
			testElement.getConnectionFigure().translateToAbsolute(location);
			// perform operation depending on degree
			if (getName().contains("D1")) {
				// move within the same side
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, location.y + 12);
				CanvasUtilities.doMouseRelease(location.x, location.y + 12);
			} else if (getName().contains("D4")) {
				// to the east side
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(terminalBounds
						.getRight().x + 12, location.y);
				CanvasUtilities.doMouseRelease(terminalBounds
						.getRight().x + 12, location.y);
			} else if (getName().contains("D5")) {
				// to the west side
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(terminalBounds
						.getLeft().x - 12, location.y);
				CanvasUtilities.doMouseRelease(terminalBounds
						.getLeft().x - 12, location.y);
			} else if (getName().contains("D2")) {
				// to north side
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, terminalBounds.y - 12);
				CanvasUtilities.doMouseRelease(location.x, terminalBounds.y - 12);
			} else if (getName().contains("D3")) {
				// to south side
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, terminalBounds.getBottom().y + 12);
				CanvasUtilities.doMouseRelease(location.x, terminalBounds.getBottom().y + 12);
			}
		}
		// for C3 move the endpoint, then the created bendpoint (this tests that
		// rectilinear routing is occuring for end point move as well as sets up
		// the test for the bendpoint moving
		if (getName().contains("C3")) {
			PointList points = testElement.getConnectionFigure().getPoints();
			Point location = null;
			// if A1-A3 move the start segment
			if (start) {
				location = points.getFirstPoint();
			} else {
				location = points.getLastPoint();
			}
			testElement.getConnectionFigure().translateToAbsolute(location);
			// perform operation depending on degree
			if (getName().contains("D1")) {
				// move within the same side
				// first move the end point
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, location.y + 12);
				CanvasUtilities.doMouseRelease(location.x, location.y + 12);
				points = testElement.getConnectionFigure().getPoints();
				// then get the created bendpoint and move it
				location = points.getPoint(1);
				if (!start) {
					location = points.getPoint(points.size() - 2);
				}
				testElement.getConnectionFigure().translateToAbsolute(location);
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, location.y + 12);
				CanvasUtilities.doMouseRelease(location.x, location.y + 12);
			} else if (getName().contains("D4")) {
				// if the terminal is a connector we must move the end in whitespace
				if(terminal instanceof ConnectorEditPart) {
					location = points.getLastPoint();
					if(!start) {
						location = points.getFirstPoint();
					}
					testElement.getConnectionFigure().translateToAbsolute(location);
					CanvasUtilities.doMouseMove(location.x, location.y);
					CanvasUtilities.doMousePress(location.x, location.y);
					CanvasUtilities.doMouseMove(location.x - 12, location.y);
					CanvasUtilities.doMouseRelease(location.x - 12, location.y);
				} else { 
					// east side
					CanvasUtilities.doMouseMove(location.x, location.y);
					CanvasUtilities.doMousePress(location.x, location.y);
					CanvasUtilities.doMouseMove(location.x + 12, location.y);
					CanvasUtilities.doMouseRelease(location.x + 12, location.y);
				}
				// then get the created bendpoint and move it
				points = testElement.getConnectionFigure().getPoints();
				location = points.getPoint(1);
				if (!start) {
					location = points.getPoint(points.size() - 2);
				}
				testElement.getConnectionFigure().translateToAbsolute(location);
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(terminalBounds.getRight().x + 12, location.y);
				CanvasUtilities.doMouseRelease(terminalBounds.getRight().x + 12, location.y);
			} else if (getName().contains("D5")) {
				// west side
				// if the terminal is a connector we must move the end in whitespace
				if(terminal instanceof ConnectorEditPart) {
					location = points.getLastPoint();
					if(!start) {
						location = points.getFirstPoint();
					}
					testElement.getConnectionFigure().translateToAbsolute(location);
					CanvasUtilities.doMouseMove(location.x, location.y);
					CanvasUtilities.doMousePress(location.x, location.y);
					CanvasUtilities.doMouseMove(location.x + 12, location.y);
					CanvasUtilities.doMouseRelease(location.x + 12, location.y);
				} else { 
					CanvasUtilities.doMouseMove(location.x, location.y);
					CanvasUtilities.doMousePress(location.x, location.y);
					CanvasUtilities.doMouseMove(location.x - 12, location.y);
					CanvasUtilities.doMouseRelease(location.x - 12, location.y);
				}
				// then get the created bendpoint and move it
				points = testElement.getConnectionFigure().getPoints();
				location = points.getPoint(1);
				if (!start) {
					location = points.getPoint(points.size() - 2);
				}
				testElement.getConnectionFigure().translateToAbsolute(location);
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(terminalBounds.x - 12, location.y);
				CanvasUtilities.doMouseRelease(terminalBounds.x - 12, location.y);
			} else if (getName().contains("D2")) {
				// north side
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, location.y - 12);
				CanvasUtilities.doMouseRelease(location.x, location.y - 12);
				// then get the created bendpoint and move it
				points = testElement.getConnectionFigure().getPoints();
				location = points.getPoint(1);
				if (!start) {
					location = points.getPoint(points.size() - 2);
				}
				testElement.getConnectionFigure().translateToAbsolute(location);
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, terminalBounds.y - 12);
				CanvasUtilities.doMouseRelease(location.x, terminalBounds.y - 12);
			} else if (getName().contains("D3")) {
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, location.y + 12);
				CanvasUtilities.doMouseRelease(location.x, location.y + 12);
				// then get the created bendpoint and move it
				points = testElement.getConnectionFigure().getPoints();
				location = points.getPoint(1);
				if (!start) {
					location = points.getPoint(points.size() - 2);
				}
				testElement.getConnectionFigure().translateToAbsolute(location);
				CanvasUtilities.doMouseMove(location.x, location.y);
				CanvasUtilities.doMousePress(location.x, location.y);
				CanvasUtilities.doMouseMove(location.x, terminalBounds.getBottom().y + 12);
				CanvasUtilities.doMouseRelease(location.x, terminalBounds.getBottom().y + 12);
			}
		}
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_segmentNewSideNorth(NonRootModelElement source,
			NonRootModelElement destination) {
		while(PlatformUI.getWorkbench().getDisplay().readAndDispatch());
		// the connector should have an additional point, and should come
		// out of the east side of the terminal
		PointList points = testElement.getConnectionFigure().getPoints();
		if (points.size() <= previousPoints.size()) {
			return false;
		}
		boolean isStart = getName().contains("A1") || getName().contains("A2")
				|| getName().contains("A3");
		if (isStart) {
			Point firstPoint = points.getFirstPoint();
			Point expectedPoint = terminals.get(0).getFigure().getBounds()
					.getCenter();
			expectedPoint.y = terminals.get(0).getFigure().getBounds()
					.getTop().y;
			if(terminals.get(0) instanceof ConnectorEditPart) {
				expectedPoint = ((Connection) terminals.get(0).getFigure())
						.getPoints().getFirstPoint();
			}
			if (!firstPoint.equals(expectedPoint)) {
				return false;
			}
			Point nextPoint = points.getPoint(1);
			if (nextPoint.x != expectedPoint.x) {
				return false;
			}
			if (nextPoint.y >= expectedPoint.y) {
				return false;
			}
		} else {
			Point lastPoint = points.getLastPoint();
			Point expectedPoint = terminals.get(1).getFigure().getBounds()
					.getCenter();
			expectedPoint.y = terminals.get(1).getFigure().getBounds()
					.getTop().y;
			if(terminals.get(1) instanceof ConnectorEditPart) {
				expectedPoint = ((Connection) terminals.get(1).getFigure())
						.getPoints().getFirstPoint();
			}
			if (!lastPoint.equals(expectedPoint)) {
				return false;
			}
			Point nextPoint = points.getPoint(points.size() - 2);
			if (nextPoint.x != expectedPoint.x) {
				return false;
			}
			if (nextPoint.y >= expectedPoint.y) {
				return false;
			}
		}
		return true;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_segmentNewSideWest(NonRootModelElement source,
			NonRootModelElement destination) {
		// the connector should have an additional point, and should come
		// out of the west side of the terminal
		PointList points = testElement.getConnectionFigure().getPoints();
		if (points.size() <= previousPoints.size()) {
			return false;
		}
		boolean isStart = getName().contains("A1") || getName().contains("A2")
				|| getName().contains("A3");
		if (isStart) {
			Point firstPoint = points.getFirstPoint();
			Point expectedPoint = terminals.get(0).getFigure().getBounds()
					.getLeft();
			expectedPoint.y = terminals.get(0).getFigure().getBounds()
					.getCenter().y;
			if(terminals.get(0) instanceof ConnectorEditPart) {
				expectedPoint = ((Connection) terminals.get(0).getFigure())
						.getPoints().getMidpoint();
			}
			if (!firstPoint.equals(expectedPoint)) {
				return false;
			}
			Point nextPoint = points.getPoint(1);
			if (nextPoint.y != expectedPoint.y) {
				return false;
			}
			if (nextPoint.x >= expectedPoint.x) {
				return false;
			}
		} else {
			Point lastPoint = points.getLastPoint();
			Point expectedPoint = terminals.get(1).getFigure().getBounds()
					.getLeft();
			expectedPoint.y = terminals.get(1).getFigure().getBounds()
					.getCenter().y;
			if(terminals.get(1) instanceof ConnectorEditPart) {
				expectedPoint = ((Connection) terminals.get(1).getFigure())
						.getPoints().getMidpoint();
			}
			if (!lastPoint.equals(expectedPoint)) {
				return false;
			}
			Point nextPoint = points.getPoint(points.size() - 2);
			if (nextPoint.y != expectedPoint.y) {
				return false;
			}
			if (nextPoint.x >= expectedPoint.x) {
				return false;
			}
		}
		return true;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_segmentNewSideSouth(NonRootModelElement source,
			NonRootModelElement destination) {
		// the connector should have an additional point, and should come
		// out of the south side of the terminal
		PointList points = testElement.getConnectionFigure().getPoints();
		if (points.size() <= previousPoints.size()) {
			return false;
		}
		boolean isStart = getName().contains("A1") || getName().contains("A2")
				|| getName().contains("A3");
		if (isStart) {
			Point firstPoint = points.getFirstPoint();
			Point expectedPoint = terminals.get(0).getFigure().getBounds()
					.getBottom();
			expectedPoint.x = terminals.get(0).getFigure().getBounds()
					.getCenter().x;
			if(terminals.get(0) instanceof ConnectorEditPart) {
				expectedPoint = ((Connection) terminals.get(0).getFigure())
						.getPoints().getLastPoint();
			}
			if (!firstPoint.equals(expectedPoint)) {
				return false;
			}
			Point nextPoint = points.getPoint(1);
			if (nextPoint.y <= expectedPoint.y) {
				return false;
			}
			if (nextPoint.x != expectedPoint.x) {
				return false;
			}
		} else {
			Point lastPoint = points.getLastPoint();
			Point expectedPoint = terminals.get(1).getFigure().getBounds()
					.getBottom();
			expectedPoint.x = terminals.get(1).getFigure().getBounds()
					.getCenter().x;
			if(terminals.get(1) instanceof ConnectorEditPart) {
				expectedPoint = ((Connection) terminals.get(1).getFigure())
						.getPoints().getLastPoint();
			}
			if (!lastPoint.equals(expectedPoint)) {
				return false;
			}
			Point nextPoint = points.getPoint(points.size() - 2);
			if (nextPoint.y <= expectedPoint.y) {
				return false;
			}
			if (nextPoint.x != expectedPoint.x) {
				return false;
			}
		}
		return true;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_lineOrthogonal(NonRootModelElement source,
			NonRootModelElement destination) {
		boolean isStart = getName().contains("A1") || getName().contains("A2")
				|| getName().contains("A3");
		boolean result = OrthogonalRouterUtilities.isRectilinear(testElement
				.getConnectionFigure().getPoints());
		if(result) {
			if (getName().contains("C1D1")) {
				// just need to check the other creation element, it should have
				// four points and be rectilinear
				PointList points = otherCreationElement.getConnectionFigure()
						.getPoints();
				if (points.size() != 4) {
					fail("The created element did not contain the expected amount of segments");
				}
				result = OrthogonalRouterUtilities.isRectilinear(points);
				if (!result) {
					fail("The created element was not rectilinear.");
				}
			} else if (getName().contains("D1")) {
				result = checkResult_segmentSameSide(source, destination);
				if (!result) {
					if (isStart) {
						fail("The first segment did not remain on the same side of the terminal.");
					} else {
						fail("The last segment did not remain on the same side of the terminal.");
					}
				}
				if(getName().contains("C3")) {
					// should result in added bendpoints
					if(testElement.getConnectionFigure().getPoints().size() != 4) {
						fail("Moving the endpoint did create a rectilinear line.");
					}
				} else {
					if (testElement.getConnectionFigure().getPoints().size() != previousPoints
							.size()) {
						fail("Operation did not result in the same number of segments");
					}
				}
			}
			if (getName().contains("B2")) {
				// make sure that the other segment was moved
				PointList points = otherElement.getConnectionFigure().getPoints();
				if (points.equals(otherElementPreviousPoints)) {
					fail("Multiple selection move did not work, other selected element was not moved.");
				}
			}
		}
		return result;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_segmentNewSideEast(NonRootModelElement source,
			NonRootModelElement destination) {
		// the connector should have an additional point, and should come
		// out of the south side of the terminal
		PointList points = testElement.getConnectionFigure().getPoints();
		if (points.size() <= previousPoints.size()) {
			return false;
		}
		boolean isStart = getName().contains("A1") || getName().contains("A2")
				|| getName().contains("A3");
		if (isStart) {
			Point firstPoint = points.getFirstPoint();
			Point expectedPoint = terminals.get(0).getFigure().getBounds()
					.getRight();
			expectedPoint.y = terminals.get(0).getFigure().getBounds()
					.getCenter().y;
			if(terminals.get(0) instanceof ConnectorEditPart) {
				expectedPoint = ((Connection) terminals.get(0).getFigure())
						.getPoints().getMidpoint();
			}
			if (!firstPoint.equals(expectedPoint)) {
				return false;
			}
			Point nextPoint = points.getPoint(1);
			if (nextPoint.x <= expectedPoint.x) {
				return false;
			}
			if (nextPoint.y != expectedPoint.y) {
				return false;
			}
		} else {
			Point lastPoint = points.getLastPoint();
			Point expectedPoint = terminals.get(1).getFigure().getBounds()
					.getRight();
			expectedPoint.y = terminals.get(1).getFigure().getBounds()
					.getCenter().y;
			if(terminals.get(1) instanceof ConnectorEditPart) {
				expectedPoint = ((Connection) terminals.get(1).getFigure())
						.getPoints().getMidpoint();
			}
			if (!lastPoint.equals(expectedPoint)) {
				return false;
			}
			Point nextPoint = points.getPoint(points.size() - 2);
			if (nextPoint.x <= expectedPoint.x) {
				return false;
			}
			if (nextPoint.y != expectedPoint.y) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_segmentSameSide(NonRootModelElement source,
			NonRootModelElement destination) {
		boolean isStart = getName().contains("A1") || getName().contains("A2")
				|| getName().contains("A3");
		List<?> lineSegments = PointListUtilities.getLineSegments(testElement
				.getConnectionFigure().getPoints());
		List<?> oldSegments = PointListUtilities
				.getLineSegments(previousPoints);
		if (isStart) {
			LineSeg start = (LineSeg) lineSegments.get(0);
			LineSeg oldStart = (LineSeg) oldSegments.get(0);
			if (oldStart.isHorizontal()) {
				if (start.getOrigin().x != oldStart.getOrigin().x) {
					return false;
				}
			} else {
				if (start.getOrigin().y != oldStart.getOrigin().y) {
					return false;
				}
			}
		} else {
			LineSeg end = (LineSeg) lineSegments.get(lineSegments.size() - 1);
			LineSeg oldEnd = (LineSeg) oldSegments.get(oldSegments.size() - 1);
			if (oldEnd.isHorizontal()) {
				if (end.getTerminus().x != oldEnd.getTerminus().x) {
					return false;
				}
			} else {
				if (end.getTerminus().y != oldEnd.getTerminus().y) {
					return false;
				}
			}
		}
		return true;
	}

}
