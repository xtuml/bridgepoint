.//=====================================================================
.//
.// File:      $RCSfile: create_explorer_view.inc,v $
.// Version:   $Revision: 1.79 $
.// Modified:  $Date: 2013/01/10 23:15:39 $
.//
.// (c) Copyright 2006-2014 by Mentor Graphics Corp. All rights reserved.
.//
.//=====================================================================
.// Licensed under the Apache License, Version 2.0 (the "License"); you may not
.// use this file except in compliance with the License.  You may obtain a copy
.// of the License at
.//
.//      http://www.apache.org/licenses/LICENSE-2.0
.//
.// Unless required by applicable law or agreed to in writing, software
.// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
.// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
.// License for the specific language governing permissions and limitations under
.// the License.
.//=====================================================================
.//
.// This file is responsible for creating the Explorer View
.// It is generated so that filters are defined for each tree
.// node, giving the user the ultimate flexibility over what
.// they want to see.
.//
.function create_explorer_view
  .param string path
  .//
  .assign viewer_name = "ExplorerView"
  .assign attr_result = viewer_name  
package org.xtuml.bp.ui.explorer;
//======================================================================
//
// File: ${path}/${viewer_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      $$Revision: 1.79 $$
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp.  All rights reserved.
//
//======================================================================
//
// This class is the main entry point for the Model Explorer View.
// It is responsible for building the presentation to the user and
// for provideing the interface to the Eclipse infrastructure.
//
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.*;
import org.eclipse.jface.action.*;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.jface.viewers.*;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.swt.widgets.TreeItem;
import org.eclipse.ui.*;
import org.eclipse.ui.actions.*;
import org.eclipse.ui.part.ViewPart;
import org.eclipse.ui.views.framelist.*;
import org.eclipse.ui.views.properties.IPropertySheetPage;
import org.eclipse.ui.views.properties.PropertySheetPage;
import org.osgi.framework.Bundle;

import org.xtuml.bp.core.*;
import org.xtuml.bp.core.common.*;
import org.xtuml.bp.core.ui.*;
import org.xtuml.bp.core.util.*;
import org.xtuml.bp.ui.explorer.ui.actions.ExplorerCopyAction;
import org.xtuml.bp.ui.explorer.ui.actions.ExplorerCutAction;
import org.xtuml.bp.ui.explorer.ui.actions.ExplorerPasteAction;
import org.xtuml.bp.ui.properties.BridgepointPropertySheetPage;
import org.xtuml.bp.ui.properties.ModelPropertySourceProvider;

import org.xtuml.bp.ui.text.activity.ActivityEditorInput;
import org.xtuml.bp.ui.text.masl.MASLEditorInput;
import org.xtuml.bp.ui.text.masl.MASLPartListener;
import org.eclipse.jface.preference.IPreferenceStore;

/**
 * ExplorerView allows the user to navigate the BridgePoint
 * metamodel. It provides a tree view analogous to that provided
 * by the Java Package Explorer.
 * 
 * @see ViewPart
 */
public class ${viewer_name} extends ViewPart implements IModelViewerProvider {
  private static final String COLLAPSE = "Collapse All";
  private static final String OPEN = "open";
  private static final String HIDE_STATICS = "Hide Static Members";
  .select many tree_nodes from instances of T_TNS
  .for each node in tree_nodes 
  private static final String HIDE_$U_{node.CategoryName} = "Hide ${node.CategoryName}";
  .end for
  private FrameList frames;
  protected static ExplorerTreeViewer treeViewer;
  protected ModelLabelProvider labelProvider;
  protected MenuManager menuManager;
  protected Action collapseAll, linkWithEditor;
  protected Action back, fwd, up;
  protected Action cut, copy, paste;
  protected Action undo, redo;
  protected Action open, delete, rename; 
  protected Action fileImport, fileExport;
  protected Action treeRefresh;
  protected Action hideStatics;
  protected Action\
  .for each node in tree_nodes 
 hide$r{node.CategoryName}\
    .if (not_last tree_nodes)
,\
    .else
;
    .end if
  .end for
  protected FilterSelectionAction filters;
  protected ViewerFilter filterStatics;
  protected ViewerFilter\
  .for each node in tree_nodes 
 filter$r{node.CategoryName}\
    .if (not_last tree_nodes)
,\
    .else
;
    .end if
  .end for

  private IModelChangeListener m_modelChangeListener;
  private ITransactionListener m_transactionListener;
  private ISelectionChangedListener m_selChangedListener;
  private IPartListener m_partListener;
  private ISelectionChangedListener m_postSelectionChangedListener;

    private static Selection selection = Selection.getInstance();
    
  /**
   * The constructor.
   */
  public ${viewer_name}() {
  }
  /**
   * Returns the tree viewer for the Explorer window
   * @see org.xtuml.bp.core.common.IModelViewerProvider#getTreeViewer()
   */
  public TreeViewer getTreeViewer() {
    return treeViewer;
  }
  
  public static TreeViewer getExplorerTreeViewer() {
    return treeViewer;
  }
  /*
   * @see IWorkbenchPart#createPartControl(Composite)
   */
  public void createPartControl(Composite parent) {
    // Create the view's layout
    FillLayout layout = new FillLayout();
    parent.setLayout(layout);
    treeViewer = new ExplorerTreeViewer(parent);
    treeViewer.setContentProvider(new ModelContentProvider());
    labelProvider = new ModelLabelProvider();
    treeViewer.setLabelProvider(labelProvider);
    // This call must be disabled until eclipse bug 117534 is fixed
    // Otherwise there are problems when a component file is reloaded
    // TODO mfp issue 30 should add a unit test, and allow other unit tests
    // (specifically core) to execute with the following line commented out
    treeViewer.setUseHashlookup(true);
    treeViewer.setComparer(new IElementComparer() {

            public int hashCode(Object element) {
                return System.identityHashCode(element);
            }

            public boolean equals(Object a, Object b) {
                return a == b;
            }

        });
    // Create menu, toolbar and filters.
    createActions();
    createMenus();
    createToolbar();
    createFilters();
    hookListeners();
    initLabelProvider(treeViewer);
	treeViewer.setInput(Ooaofooa.getDefaultInstance());
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.DELETE.getId(),
      delete);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.RENAME.getId(),
      rename);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.COPY.getId(),
      copy);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.CUT.getId(),
      cut);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.UNDO.getId(),
      undo);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.REDO.getId(),
      redo);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.PASTE.getId(),
      paste);
    // Set help for the view 
    PlatformUI.getWorkbench().getHelpSystem().setHelp(treeViewer.getControl(), IModelExplorerHelpContextIds.modelExplorerId);
  }
  /**
   * Hook up all the listeners needed by Model Explorer
   */    
  protected void hookListeners() {
		m_partListener = new IPartListener() {

			public void partActivated(IWorkbenchPart part) {
				// update the system selection if the part
				// activated is an instance of this class
				if (part instanceof ExplorerView)
						  if(!getTreeViewer().getTree().isDisposed()) {
						// if link with editor is set the selection will
						// already by up to date, otherwise set the current
						// selection to that of this viewers
						if (!linkWithEditor.isChecked()) {
							selection.setSelection(treeViewer.getSelection());
							}
						}
					}

			public void partDeactivated(IWorkbenchPart part) {}

			public void partBroughtToTop(IWorkbenchPart part) {}

			public void partClosed(IWorkbenchPart part) {}

			public void partOpened(IWorkbenchPart part) {}

	};
    getSite().getPage().addPartListener(m_partListener);
    treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
        // Transfer the selection to the model
        selection.setSelection(event.getSelection());
      }
    });
    m_selChangedListener = new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
	  	keyActionsActivation();
        if (!getTreeViewer().getTree().isDisposed()) {
		 if (getSite().getPage().getActivePart() != ExplorerView.this)
          if (linkWithEditor.isChecked()){
            // transfer the selection to the tree, but avoid having the tree 
            // viewer report its selection change to its listeners, as if what the 
            // model is reporting as selected is not contained in the tree
            // (such as when a connector is selected), we don't want the
            // tree's newly empty selection being propagated back to the model 
            // by the treeview-listener, above; see issue 453 for more context
            IStructuredSelection selection = (IStructuredSelection)event.getSelection();
            // adapt the selection if necessary
            selection = adaptSelection(selection);
            setTreeSelection(treeViewer, selection);
          }
        }
      }
    };
    selection.addSelectionChangedListener(m_selChangedListener);
    m_postSelectionChangedListener = new ISelectionChangedListener() {
    	
		@Override
		public void selectionChanged(SelectionChangedEvent event) {
			ISelection selection= event.getSelection();
			// If the selection is the same as the one that triggered the last
			// open event then do nothing. The editor already got revealed.
			if (linkWithEditor.isChecked()) {
				linkToEditor((IStructuredSelection)selection);
			}
		}
	};
    getTreeViewer().addPostSelectionChangedListener(m_postSelectionChangedListener);
    m_modelChangeListener = new ModelChangeAdapter() {
        public void modelChanged(ModelChangedEvent event) {
                performDefault(event, null);
        }
        public void modelElementAboutToBeDeleted(ModelChangedEvent event) {
                //we are not interested                
        }
        public void modelElementAboutToBeReloaded(ModelChangedEvent event) {
                //we are not interested                
        }
        public void modelElementReloaded(ModelChangedEvent event) {
            TreeViewer viewer = getTreeViewer();
            if (!viewer.getTree().isDisposed()) {
                Object modelElement = event.getModelElement();
                if (classInTree(modelElement)) {
                    // clear the selection to remove any references to 
                    // the old (pre-reloaded) model element
                    Selection.getInstance().clear();
                    UIUtil.refreshViewer(viewer);
                }
            }
        }
		public void modelElementLoaded(ModelChangedEvent event) {
				if (!getTreeViewer().getTree().isDisposed()) {
					Object modelElement = event.getModelElement();

					if(modelElement instanceof SystemModel_c){
						TreeViewer viewer = getTreeViewer();
						UIUtil.refreshViewer(viewer);
					}
				}
		}
		public void modelElementUnloaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				ExplorerTreeViewer viewer = (ExplorerTreeViewer) getTreeViewer();
                Object parent = getParent(modelElement);
                //when system model is unloaded perform a full refresh
				if (modelElement instanceof SystemModel_c)
						UIUtil.refreshViewer(viewer, null);
				else if (parent != null)
						UIUtil.refreshViewer(viewer, parent);
			}
		}
		protected Object getParent(Object modelElement){       
            ExplorerTreeViewer viewer = (ExplorerTreeViewer) getTreeViewer();
            Object parent=null;                
            TreeItem treeItem = viewer.findTreeItem(modelElement);

            if (treeItem != null) {
                TreeItem parentItem = treeItem.getParentItem();
                if (parentItem != null) {
                   parent = parentItem.getData();
                } else {
                   parent = treeItem.getData();
                }
            }
            return parent;
        }
            
        /* (non-Javadoc)
         * @see org.xtuml.bp.core.common.IModelChangeListener#modelElementRelationChanged(org.xtuml.bp.core.common.ModelChangedEvent, org.xtuml.bp.core.common.IModelDelta)
         */
        public void modelElementRelationChanged(ModelChangedEvent event,
            IModelDelta delta)
        {
            // there is nothing to do (including calling performDefault), since 
            // relationships aren't shown in this view 
        }
    };
	Ooaofooa.getDefaultInstance().addModelChangeListener(m_modelChangeListener);
	m_transactionListener = new ITransactionListener() {
			@Override
			public void transactionCancelled(Transaction transaction) {
				// Do Nothing
			}

			@Override
			public void transactionEnded(Transaction transaction) {
				PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
					
					@Override
					public void run() {
						getExplorerTreeViewer().refresh();	
					}
				});
			}

			@Override
			public void transactionStarted(Transaction transaction) {
				// Do nothing
			}
		};
	TransactionManager.getSingleton().addTransactionListener(m_transactionListener);
    treeViewer.addOpenListener(new IOpenListener() {
      public void open(OpenEvent event) {
        handleOpen();
      }
    });
  }
  
  	/**
	 * Links to editor (if option enabled)
	 * @param selection the selection
	 */
	private void linkToEditor(IStructuredSelection selection) {
		if (!isActivePart())
			return;
		if (getSite().getPage().getActiveEditor() != null) {
			IEditorPart activeEditor = getSite().getPage().getActiveEditor();
			if (!Selection.getInstance().getSelection().isEmpty()) {
			   	// If there is a tree selection then 
			   	// sync the current core selection with the editor's
				activeEditor.getEditorSite().getSelectionProvider()
					..setSelection(Selection.getInstance().getSelection());
			} else {
				// If there is a editor selection then set the tree selection and
                // expend the tree to the selection
				if (activeEditor instanceof ILinkWithEditorListener) {
					NonRootModelElement nrme = ((ILinkWithEditorListener) activeEditor).getFirstSelectedElement();
					if (nrme != null) {
						selection = adaptSelection(new StructuredSelection(nrme));
						setTreeSelection(treeViewer, selection);
					}
				}
			}
			// call client link selection handling
			if(activeEditor instanceof ILinkWithEditorListener) {
				((ILinkWithEditorListener) activeEditor).notifySelectionLink();
			}
		}
	}

	private boolean isActivePart() {
		return this == getSite().getPage().getActivePart();
	}
	
  	protected IStructuredSelection adaptSelection(
			IStructuredSelection selection) {
		ArrayList<Object> adapted = new ArrayList<Object>();
		for(Object selected : selection.toList()) {
			Object adapter = Platform.getAdapterManager().getAdapter(selected, NonRootModelElement.class);
			if(adapter != null) {
				adapted.add(adapter);
			} else {
				adapted.add(selected);
			}
		}
		return new StructuredSelection(adapted);
	}
	
  private static void setTreeSelection(ExplorerTreeViewer tv, IStructuredSelection sel) {
    tv.setSelectionToWidget(sel, true);

    // scroll to reveal all elements of the new selection
    for (Iterator iterator = sel.iterator(); iterator.hasNext();) {
      Object element = iterator.next();
      if(element != null){
      tv.reveal(element);
      }
    }
  }
  public static final boolean classInTree( Object o )
  {
  .// declare two empty inst_ref_set<O_OBJ>'s
  .select many all_referenced_class_set from instances of O_OBJ where (selected.Name == "-1" )
  .assign empty_class_set = all_referenced_class_set
  .//
  .for each node in tree_nodes 
    .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .assign all_referenced_class_set = all_referenced_class_set | class
  .end for
  .//
  .// add any classes that are only called out in T_TNS.NamingAttributeRelChain
  .//
  .for each node in tree_nodes
    .invoke arcc = add_rel_chain_classes( empty_class_set, node.NamingAttributeRelChain )
    .assign all_referenced_class_set = all_referenced_class_set | arcc.class_set
  .end for
  .//
  .// now do the same thing for T_TPS.ParentChildRelChain
  .//
  .select many parent_nodes from instances of T_TPS
  .for each parent in parent_nodes 
    .invoke arcc = add_rel_chain_classes( empty_class_set, parent.ParentChildRelChain )
    .assign all_referenced_class_set = all_referenced_class_set | arcc.class_set
  .end for
  .//
  .// special case classes
  .select any class from instances of O_OBJ where (selected.Key_Lett == "O_RATTR")
  .assign all_referenced_class_set = all_referenced_class_set | class
  .select any class from instances of O_OBJ where (selected.Key_Lett == "O_REF")
  .assign all_referenced_class_set = all_referenced_class_set | class
  .//
  .for each class in all_referenced_class_set 
    .invoke cn = get_class_name( class )
    if ( o instanceof ${cn.body} ) return true;
  .end for
    return false;
  }
  /**
   * Create the Actions provided by Model Explorer
   */
  protected void createActions() {
    frames = new FrameList(new TreeViewerFrameSource(getTreeViewer()));
    back = new BackAction(frames) {
      public void run() {
      }
    };
    fwd = new ForwardAction(frames) {
      public void run() {
      }
    };
    up = new UpAction(frames) {
      public void run() {
      }
    };
    collapseAll = new Action(COLLAPSE) {
      public void run() {
        getTreeViewer().collapseAll();
      }
    };
    collapseAll.setToolTipText(COLLAPSE);
    collapseAll.setImageDescriptor(CorePlugin.getImageDescriptor("collapseall.gif")); //$$NON-NLS-1$$
    PlatformUI.getWorkbench().getHelpSystem().setHelp(collapseAll, IModelExplorerHelpContextIds.COLLAPSE_ALL_ACTION);
    linkWithEditor = new Action(IWorkbenchActionConstants.SHOW_IN) {
      public void run() {
        IStructuredSelection selection = Selection.getInstance().getStructuredSelection();
        getTreeViewer().setSelection(selection);
        for (Iterator iterator = selection.iterator(); iterator.hasNext();) {
          Object element = iterator.next();
          getTreeViewer().reveal(element);
        }
      }
    };
    linkWithEditor.setChecked(false);
    linkWithEditor.setText("Link With Editor");
    linkWithEditor.setToolTipText("Link with Editor");
    linkWithEditor.setImageDescriptor(CorePlugin.getImageDescriptor("synced.gif")); //$$NON-NLS-1$$
    // 'New' is provided as a sub-menu only. See 'createMenus'
    open = new Action(OPEN){
      public void run(){
        handleOpen();
      }
    };
    open.setText("Open");
    open.setToolTipText("Open this model Element");
    // 'Open With' is provided as a sub-menu only. See 'createMenus'
	undo = TransactionManager.getSingleton().getUndoAction();
	redo = TransactionManager.getSingleton().getRedoAction();
	cut = new ExplorerCutAction(getTreeViewer());
	copy = new ExplorerCopyAction(getTreeViewer());
	paste = new ExplorerPasteAction();
    // Delete and Rename are retargetable actions defined by core.
    //
    delete = CorePlugin.getDeleteAction();
    rename = CorePlugin.getRenameAction(treeViewer);
    //
		fileImport = CorePlugin.getResourceImportAction();
		fileExport = CorePlugin.getResourceExportAction();
    hideStatics = new Action(HIDE_STATICS) {
      public void run() {
        updateFilter(hideStatics);
      }
    };
	treeRefresh = new Action(ActionFactory.REFRESH.getId()) {
		public void run() {
			RefreshAction ra = new RefreshAction(
				CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getShell());
			ra.run();
			getTreeViewer().refresh();
		}
	};
	treeRefresh.setText("Refresh");
	treeRefresh.setToolTipText("Refresh the tree");
	treeRefresh.setImageDescriptor(
		CorePlugin.getImageDescriptor("refresh.gif")); //$$NON-NLS-1$$
	treeRefresh.setAccelerator(SWT.F5);
	treeRefresh.setActionDefinitionId("org.eclipse.ui.file.refresh"); //$$NON-NLS-1$$
	getSite().getKeyBindingService().registerAction(treeRefresh);

    hideStatics.setChecked(false);
    hideStatics.setToolTipText(HIDE_STATICS);
  .for each node in tree_nodes
    hide$r{node.CategoryName} = new Action(HIDE_$U_{node.CategoryName}) {
      public void run() {
        updateFilter(hide$r{node.CategoryName});
      }
    };
    hide$r{node.CategoryName}.setChecked(false);
    hide$r{node.CategoryName}.setToolTipText(HIDE_$U_{node.CategoryName});
  .end for
    filters = new FilterSelectionAction(this, "Filters...");
    filters.setImageDescriptor(CorePlugin.getImageDescriptor("filter_ps.gif")); //$$NON-NLS-1$$
  }
  /**
   * Create the menus for the Model Explorer
   */  
  protected void createMenus() {
    // Context Menu
    MenuManager menuManager = new MenuManager("#PopupMenu"); //$$NON-NLS-1$$
    menuManager.setRemoveAllWhenShown(true);
    final MenuManager createMenuManager = new MenuManager("Ne&w", "org.xtuml.bp.ui.newroot"); //$$NON-NLS-2$$
    final MenuManager openMenuManager = new MenuManager("Open Wit&h", "org.xtuml.bp.ui.openroot"); //$$NON-NLS-2$$
	final MenuManager classesMenu = new MenuManager("Classes", "org.xtuml.bp.ui.classroot"); //$$NON-NLS-2$$
	final MenuManager componentsMenu = new MenuManager("Components", "org.xtuml.bp.ui.componentroot"); //$$NON-NLS-2$$
	final MenuManager externalMenu = new MenuManager("External", "org.xtuml.bp.ui.externalroot"); //$$NON-NLS-2$$
	final MenuManager interactionMenu = new MenuManager("Interaction", "org.xtuml.bp.ui.interactionroot"); //$$NON-NLS-2$$
	final MenuManager activityMenu = new MenuManager("Activity", "org.xtuml.bp.ui.activityroot");//$$NON-NLS-2$$
	final MenuManager typesMenu = new MenuManager("Types", "org.xtuml.bp.ui.typeroot"); //$$NON-NLS-2$$
	final MenuManager useCaseMenu = new MenuManager("Usecase", "org.xtuml.bp.ui.usecaseroot"); //$$NON-NLS-2$$
    
    menuManager.addMenuListener(new IMenuListener() {
      public void menuAboutToShow(IMenuManager mgr) {
        mgr.add(createMenuManager);
        createMenuManager.removeAll();
        createMenuManager.add(new GroupMarker("org.xtuml.bp.ui.newmenu")); //$$NON-NLS-1$$
	   
        createMenuManager.add(activityMenu);
		activityMenu.removeAll();
		activityMenu.add(new GroupMarker("org.xtuml.bp.ui.newactivitymenu") );

		createMenuManager.add(classesMenu);
		classesMenu.removeAll();
		classesMenu.add(new GroupMarker("org.xtuml.bp.ui.newclassmenu") );

		createMenuManager.add(componentsMenu);
		componentsMenu.removeAll();
		componentsMenu.add(new GroupMarker("org.xtuml.bp.ui.newcomponentmenu") );

		createMenuManager.add(externalMenu);
		externalMenu.removeAll();
		externalMenu.add(new GroupMarker("org.xtuml.bp.ui.newexternalmenu") );

		createMenuManager.add(interactionMenu);
		interactionMenu.removeAll();
		interactionMenu.add(new GroupMarker("org.xtuml.bp.ui.newinteractionmenu") );

		createMenuManager.add(typesMenu);
		typesMenu.removeAll();
		typesMenu.add(new GroupMarker("org.xtuml.bp.ui.newtypemenu") );

		createMenuManager.add(useCaseMenu);
		useCaseMenu.removeAll();
		useCaseMenu.add(new GroupMarker("org.xtuml.bp.ui.newusecasemenu") );
        
        createMenuManager.add(new NewWizardMenu(getSite().getWorkbenchWindow()));
        mgr.add(open);
        mgr.add(openMenuManager);
        openMenuManager.removeAll();
        openMenuManager.add(new GroupMarker("org.xtuml.bp.ui.openmenu")); //$$NON-NLS-1$$
        mgr.add(new Separator("org.xtuml.bp.ui.context-internal")); //$$NON-NLS-1$$
        mgr.add(new Separator("org.xtuml.bp.ui.context-internal-end")); //$$NON-NLS-1$$
		mgr.add(new Separator());
		mgr.add(undo);
		mgr.add(redo);
        mgr.add(new Separator());
        mgr.add(cut);
		cut.setEnabled(cut.isEnabled());
        mgr.add(copy);
		copy.setEnabled(copy.isEnabled());
        mgr.add(paste);
		paste.setEnabled(paste.isEnabled());
        mgr.add(new Separator());
        mgr.add(delete);
        mgr.add(rename);
        mgr.add(new Separator());
        mgr.add(fileImport);
        mgr.add(fileExport);
		mgr.add(new Separator());
		mgr.add(treeRefresh);
        // If this is omitted, the platform complains because
        // it can't allow third party plug-ins to extend the menu
        // This is important for those who wish to use change
        // management plugins because Team menu items are added here.
        mgr.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
      }
    });
    Menu menu = menuManager.createContextMenu(treeViewer.getTree());
    treeViewer.getTree().setMenu(menu);
    getSite().setSelectionProvider(selection);
    getSite().registerContextMenu(menuManager, selection);
    // Titlebar Menu
    IMenuManager rootMenuManager = getViewSite().getActionBars().getMenuManager();
    rootMenuManager.setRemoveAllWhenShown(true);
    rootMenuManager.addMenuListener(new IMenuListener() {
      public void menuAboutToShow(IMenuManager mgr) {
        fillMenu(mgr);
      }
    });
    fillMenu(rootMenuManager);
  }
  /**
   * Fill the Explorer's Titlebar dropdown menu 
   */  
  protected void fillMenu(IMenuManager rootMenuManager) {
    // These actions are being presented in the menu and so should have an icon
    hideStatics.setImageDescriptor(CorePlugin.getImageDescriptor("static_co.gif")); //$$NON-NLS-1$$
    rootMenuManager.add(hideStatics);
    hideOperations.setImageDescriptor(CorePlugin.getImageDescriptor("methpub_obj_co.gif")); //$$NON-NLS-1$$
    rootMenuManager.add(hideOperations);
    rootMenuManager.add(filters);
    rootMenuManager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
    rootMenuManager.add(linkWithEditor);
  }
  /**
   * Create the view filters for the Explorer window
   */
  .select any op_class from instances of O_OBJ where (selected.Key_Lett == "O_TFR")
  .invoke op = get_class_name(op_class)
  .select any fn_class from instances of O_OBJ where (selected.Key_Lett == "S_SYNC")
  .invoke fn = get_class_name(fn_class)
  protected void createFilters() {
    filterStatics = new ViewerFilter() {
      public boolean select(Viewer viewer, Object parentElement, Object element) {
        if (element instanceof ${op.body}) {
          return (((${op.body})element).getInstance_based() == Scope_c.Instance);
        }
        if (element instanceof ${fn.body}) {
          return false;
        }
        return true;
      }
    };
  .for each node in tree_nodes
    .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke cn = get_class_name( class )
    filter$r{node.CategoryName} = new ViewerFilter() {
      public boolean select(Viewer viewer, Object parentElement, Object element) {
        return !(element instanceof ${cn.body});
      }
    };
    .end for
    FiltersContentProvider contentProvider = new FiltersContentProvider();
    String [] selections = contentProvider.getInitialSelections();
    updateFilters(selections); 
  }
  /**
   * Update the Explorer's view filters 
   */
  protected void updateFilters(String[] filters){
  .for each node in tree_nodes
    hide$r{node.CategoryName}.setChecked(false);
    updateFilter(hide$r{node.CategoryName});
  .end for
    for (int i=0; i <  filters.length; i++){
  .for each node in tree_nodes
      if (filters[i].equals("${node.CategoryName}")) {
        hide$r{node.CategoryName}.setChecked(true);
        updateFilter(hide$r{node.CategoryName});
      }
  .end for
    }
  }
  /**
   * Update a single filter
   */
  /* Multiple filters can be enabled at a time. */
  protected void updateFilter(Action action) {
    if(action == hideStatics) {
      if(action.isChecked()) {
        treeViewer.addFilter(filterStatics);
      } else {
        treeViewer.removeFilter(filterStatics);
      }
      return;
    }
    .for each node in tree_nodes
    if(action == hide$r{node.CategoryName}) {
      if(action.isChecked()) {
        treeViewer.addFilter(filter$r{node.CategoryName});
      } else {
        treeViewer.removeFilter(filter$r{node.CategoryName});
      }
      return;
    }
    .end for
  }
  /**
   * Create the tool bar for the Model Explorer 
   */  
  protected void createToolbar() {
    IActionBars actionBars = getViewSite().getActionBars();
    actionBars.setGlobalActionHandler(ActionFactory.BACK.getId(), back);
    actionBars.setGlobalActionHandler(
       ActionFactory.FORWARD.getId(),
       fwd);
    actionBars.setGlobalActionHandler(ActionFactory.UP.getId(), up);
    IToolBarManager toolBarManager = actionBars.getToolBarManager();
    toolBarManager.add(back);
    toolBarManager.add(fwd);
    toolBarManager.add(up);
    toolBarManager.add(new Separator());
    toolBarManager.add(collapseAll);
    toolBarManager.add(linkWithEditor);
  }
  /*
   * @see IWorkbenchPart#setFocus()
   */
  public void setFocus() {
    Viewer viewer = getTreeViewer();
    if (viewer != null) {
      Control c = viewer.getControl();
      if (!c.isFocusControl()) {
        c.setFocus();
        c.update();
		viewer.refresh();
      }
    }
  }
  /**
   * Returns an adapter if available
   * @see IAdaptable#getAdapter
   */
  public Object getAdapter(Class adapter) {
    if (adapter.equals(IPropertySheetPage.class)) {
      return getPropertySheet();
    }
    return super.getAdapter(adapter);
  }
  /**
   * return a property sheet if available
   */
  protected IPropertySheetPage getPropertySheet() {
        PropertySheetPage pss =  new BridgepointPropertySheetPage();
        pss.setPropertySourceProvider(new ModelPropertySourceProvider());
        return pss;
  }
  /**
   * Fire up an editor
   */
  private IEditorPart handleOpen() {
    
    IStructuredSelection sel =  selection.getStructuredSelection();
	if (sel.isEmpty())
	{
		return null;
	}
	  Object current = sel.iterator().next();
		// see if the current element should open
		// something other than itself
		current = EditorUtil.getElementToEdit(current);
		
    String name = current.getClass().getName();
    //
    // Get the registry
    //
    IExtensionRegistry reg = Platform.getExtensionRegistry();
    //
    // Get all the plugins that have extended this point
    //
    IExtensionPoint extPt = reg.getExtensionPoint("org.xtuml.bp.core.editors"); //$$NON-NLS-1$$
    IExtension[] exts = extPt.getExtensions();
    // Repeat for each extension until we find a default editor
    for (int i=0; i < exts.length; i++) {
      IConfigurationElement[] elems = exts[i].getConfigurationElements();
      for (int j=0; j < elems.length; j++) {
        // Find the editor elements
        if (elems[j].getName().equals("editor")){                                  //$$NON-NLS-1$$
          IConfigurationElement[] edElems = elems[j].getChildren();
          for (int k=0; k < edElems.length; k++) {
            //
            // Is this editor the default for the current model element ?
            //
            if (edElems[k].getName().equals("defaultFor") &&                       //$$NON-NLS-1$$
                edElems[k].getAttribute("class").equals(name) ) {                  //$$NON-NLS-1$$
              try {
                //
                // Get the class supplied for the input
                //
                Bundle bundle = Platform.getBundle(elems[j]
                                      ..getDeclaringExtension().getNamespace());
                Class inputClass = bundle.loadClass(
                                       elems[j].getAttribute("input"));//$$NON-NLS-1$$

                String editorId = elems[j].getAttribute("class");
                // check to see if we need to open the MASL editor
                if (editorId.equals(ActivityEditorInput.EDITOR_ID) && MASLEditorInput.isSupported(current) ) {
                        // check empty
                        boolean OALempty = false;
                        boolean MASLempty = false;
                        try {
                            OALempty = ActivityEditorInput.activityEmpty(current);
                            MASLempty = MASLEditorInput.activityEmpty(current);
                        }
                        catch ( CoreException e ) {
                            System.out.println(e);
                        }

                        // There are exactly two situations in which we open up the MASL editor on a double click:
                        // 1. The OAL activity is empty and the MASL activity is not.
                        // 2. Either both are empty or both are populated and the default is the MASL editor
                        if ( OALempty && !MASLempty ) {
                            inputClass = bundle.loadClass("org.xtuml.bp.ui.text.masl.MASLEditorInput");
                            try {
                                    editorId = (String) inputClass.getField("EDITOR_ID").get(null);
                            } catch (NoSuchFieldException e) {
                                    System.out.println(e);
                            }
                        }
                        else if ( ( OALempty && MASLempty ) || ( !OALempty && !MASLempty ) ) {
                            // check to see if MASL is the default
                            /* TODO Levi disabled preference for testing
                            IPreferenceStore store = CorePlugin.getDefault().getPreferenceStore();
                            String option = store.getString(BridgePointPreferencesStore.DEFAULT_ACTIVITY_EDITOR);
                            */
                            String option = "MASL";     // hardcode MASL temporarily to avoid dependance on bp.core
                            if (option.equals("MASL")) {
                                    inputClass = bundle.loadClass("org.xtuml.bp.ui.text.masl.MASLEditorInput");
                                    try {
                                            editorId = (String) inputClass.getField("EDITOR_ID").get(null);
                                    } catch (NoSuchFieldException e) {
                                            System.out.println(e);
                                    }
                            }
                        }
                }

                Class[] type = new Class[1];
                type[0] = Object.class;
                //
                // Dynamically get the method createInstance, the supplied class must implement this
                //
                Method createInstanceMethod = inputClass.getMethod("createInstance", type);          //$$NON-NLS-1$$
                Object[] args = new Object[1];
                args[0] = current;
                //
                // Invoke the method.
                // The method is static; no instance is needed, so first argument is null
                //
                IEditorInput input = (IEditorInput)createInstanceMethod.invoke(null, args);
                //
                // pass the input to the Eclipse editor, along with the class name supplied by
                // the extending plugin.
                //
                if (input != null) {
                    IWorkbenchPage page = (IWorkbenchPage) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
		    if (MASLEditorInput.EDITOR_ID == editorId) {
			page.addPartListener((IPartListener2) new MASLPartListener());
		    }
		    return page.openEditor(input, editorId);
                }
                return null;
              }
              catch (ClassNotFoundException e){
                ExplorerPlugin.logError("Input Class not found", e);//$$NON-NLS-1$$
              }
              catch (NoSuchMethodException e) {
                ExplorerPlugin.logError("Class does not implement static method createInstance", e);//$$NON-NLS-1$$
              }
              catch (InvocationTargetException e) {
                // In the situation where an attempt is made to open an activity editor on an Attribute,
                // we ignore the error.  The reason is that this model element has 2 different editors
                // associated with.  When it is a MDA we open the activity editor, when it is not an
                // MDA we still try to open the activity editor, but there is not one and this exception
                // gets thrown.  We ignore the exception in this situation, and the description editor is
                // then opened as it should be.
                boolean ignoreError = (elems[j].getAttribute("input").contains("ActivityEditorInput") && name.contains("Attribute_c"));
                if (!ignoreError) {
                  ExplorerPlugin.logError("Exception occured on invocation of static method createInstance of the Target", e.getTargetException());//$$NON-NLS-1$$
                }
              }
              catch (IllegalAccessException e) {
                ExplorerPlugin.logError("Target does not support static method createInstance", e);//$$NON-NLS-1$$
              }
              catch (PartInitException e) {
                ExplorerPlugin.logError("Could not activate Editor", e);//$$NON-NLS-1$$
              }
            }
          }
        }
      }
    }

    return null; 
  }
  /**
   * Dispose of the Explorer widget
   */ 
  public void dispose() {
    super.dispose();
    Ooaofooa.removeModelChangeListenerFromAll(m_modelChangeListener);
	TransactionManager.getSingleton().removeTransactionListener(m_transactionListener);
    selection.removeSelectionChangedListener(m_selChangedListener);
		getSite().getPage().removePartListener(m_partListener);
	getTreeViewer().removePostSelectionChangedListener(m_postSelectionChangedListener);
  }
  /**
   * Initialize the Label provider to link it into the chain 
   * of platform label decorators.
   */
  protected void initLabelProvider(TreeViewer viewer){
    viewer.setLabelProvider(
       new DecoratingLabelProvider(
                              (ILabelProvider)viewer.getLabelProvider(),
                              CorePlugin.getDefault().getWorkbench().
                              getDecoratorManager().getLabelDecorator()));
  }

	/**
	 * Sets whether this explorer's selection is linked to that of the 
	 * whichever editor is currently open.  This method is used by
	 * automated test programs to simulate pressing/unpressing the 
	 * "Link with Editor" button of the explorer.
	 */ 
	public void setLinkWithEditor(boolean link)
	{
		linkWithEditor.setChecked(link);
	}
    /**
     * Has this explorer-view behave as if its open-action was just
     * invoked.  Returns the editor that was opened.  For automated test purposes.
     */
    public IEditorPart doOpen() {
        return handleOpen();
    }

    /**
     * Has this explorer-view behave as if its delete-action was just
     * invoked.  For automated test purposes.
     */
    public void doDelete() {
        delete.run();
    }
	/**
     * To disable or Enable rename and delete actions
     * 
     */
	private void keyActionsActivation() {
		IStructuredSelection structuredSelection = Selection.getInstance().getStructuredSelection();
		Object context = structuredSelection.getFirstElement();
		if (context instanceof NonRootModelElement) {
			rename.setEnabled(RenameAction.canRenameAction());
		}
		boolean enableDel = false;
		IStructuredSelection selection = Selection.getInstance().getStructuredSelection();
		if (!selection.isEmpty()) {
			enableDel = true;
			// Iterate through removing elements that are only graphical
			for (Iterator iter = selection.iterator(); iter.hasNext();) {
				Object current = iter.next();
				if (!(current instanceof NonRootModelElement)) {
					enableDel = false;
					break;
				}
			}

		}
		if (enableDel) {
			delete.setEnabled(DeleteAction.canDeleteAction());
		} else {
			delete.setEnabled(enableDel);
		}
	}
}
.end function
.//
.function add_rel_chain_classes
  .param inst_ref_set p_result_set   .// an empty inst_ref_set<O_OBJ>
  .param string p_rel_chain
  .//
  .while ("$r{p_rel_chain}" != "")
    .invoke nav = parse_chain(p_rel_chain, "backward")
    .if (not_empty nav.class)
      .assign cl = nav.class
      .assign p_result_set = p_result_set | cl
    .end if
    .assign p_rel_chain = nav.remainder
  .end while
  .assign attr_class_set = p_result_set
.end function

