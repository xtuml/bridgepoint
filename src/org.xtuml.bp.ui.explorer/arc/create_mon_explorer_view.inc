.//=====================================================================
.//
.// File:      $RCSfile$
.// Version:   $Revision$
.// Modified:  $Date$
.//
.// (c) Copyright 2006-2014 by Mentor Graphics Corp. All rights reserved.
.//
.//=====================================================================
.// Licensed under the Apache License, Version 2.0 (the "License"); you may not
.// use this file except in compliance with the License.  You may obtain a copy
.// of the License at
.//
.//      http://www.apache.org/licenses/LICENSE-2.0
.//
.// Unless required by applicable law or agreed to in writing, software
.// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
.// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
.// License for the specific language governing permissions and limitations under
.// the License.
.//=====================================================================
.//
.// This file is responsible for creating the Monitor View
.// It is generated so that filters are defined for each tree
.// node, giving the user the ultimate flexibility over what
.// they want to see.
.//
.function create_monitor_view
  .param string path
  .//
  .assign viewer_name = "MonitorView"
  .assign attr_result = viewer_name  
  .select many tree_nodes from instances of T_TNS
package org.xtuml.bp.ui.explorer;
//======================================================================
//
// File: ${path}/${viewer_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      $$Revision$$
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp.  All rights reserved.
//
//======================================================================
//
// This class is the main entry point for the Monitor View.
// It is responsible for building the presentation to the user and
// for providing the interface to the Eclipse infrastructure.
//
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Platform;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.GroupMarker;
import org.eclipse.jface.action.IMenuListener;
import org.eclipse.jface.action.IMenuManager;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.viewers.DecoratingLabelProvider;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.IOpenListener;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.OpenEvent;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerFilter;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchActionConstants;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.actions.ExportResourcesAction;
import org.eclipse.ui.actions.ImportResourcesAction;
import org.eclipse.ui.actions.NewWizardMenu;
import org.eclipse.ui.actions.RefreshAction;
import org.eclipse.ui.help.WorkbenchHelp;
import org.eclipse.ui.part.ViewPart;
import org.eclipse.ui.views.properties.IPropertySheetPage;
import org.eclipse.ui.views.properties.PropertySheetPage;
import org.osgi.framework.Bundle;

import org.xtuml.bp.core.*;
import org.xtuml.bp.core.common.*;
import org.xtuml.bp.core.ui.DeleteAction;
import org.xtuml.bp.core.ui.RenameAction;
import org.xtuml.bp.core.ui.Selection;
import org.xtuml.bp.core.util.UIUtil;

import org.xtuml.bp.ui.properties.ModelPropertySourceProvider;

/**
 * ExplorerView allows the user to navigate the BridgePoint
 * metamodel. It provides a tree view analogous to that provided
 * by the Java Package Explorer.
 * 
 * @see ViewPart
 */
public class ${viewer_name} extends ViewPart {
  private static final String COLLAPSE = "Collapse All";
  private static final String OPEN = "open";
  protected ExplorerTreeViewer treeViewer;
  protected MonitorLabelProvider labelProvider;
  protected MenuManager menuManager;
  protected Action collapseAll, linkWithEditor;
  protected Action cut, copy, paste;
  protected Action open, delete, rename; 
  protected Action fileImport, fileExport;
  protected Action treeRefresh;
  protected ViewerFilter filterStatics;

  private IModelChangeListener m_modelChangeListener;
  private ITransactionListener m_transactionListener;
  private ISelectionChangedListener m_selChangedListener;
  private static MonitorView instance = null;

  private static Selection selection = Selection.getInstance();
    
  /**
   * The constructor.
   */
  public ${viewer_name}() {
    instance = this;
  }
  /**
   * Returns the tree viewer for the Explorer window
   */
  public ExplorerTreeViewer getTreeViewer() {
    return treeViewer;
  }

  public static MonitorView instance() {
    if (instance == null) {
      new MonitorView();
    }
    return instance;
  }
  /*
   * @see IWorkbenchPart#createPartControl(Composite)
   */
  public void createPartControl(Composite parent) {
    // Create the view's layout
    FillLayout layout = new FillLayout();
    parent.setLayout(layout);
    treeViewer = new ExplorerTreeViewer(parent, ResourcesPlugin.getWorkspace().getRoot());
    treeViewer.setContentProvider(new MonitorContentProvider());
    labelProvider = new MonitorLabelProvider();
    treeViewer.setLabelProvider(labelProvider);
    treeViewer.setUseHashlookup(true);
    // Create menu, toolbar and filters.
    createActions();
    createMenus();
    createToolbar();
    hookListeners();
    initLabelProvider(treeViewer);
	treeViewer.setInput(Ooaofooa.getDefaultInstance());
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.DELETE.getId(),
      delete);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.RENAME.getId(),
      rename);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.COPY.getId(),
      copy);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.CUT.getId(),
      cut);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.PASTE.getId(),
      paste);
  }
  /**
   * Hook up all the listeners needed by the Monitor View
   */    
  protected void hookListeners() {
    treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
        // Transfer the selection to the model
        selection.setSelection(event.getSelection());
      }
    });
    m_selChangedListener = new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
	  	keyActionsActivation();
        if (!getTreeViewer().getTree().isDisposed()) {
          if (linkWithEditor.isChecked()){
            // transfer the selection to the tree, but avoid having the tree 
            // viewer report its selection change to its listeners, as if what the 
            // model is reporting as selected is not contained in the tree
            // (such as when a connector is selected), we don't want the
            // tree's newly empty selection being propagated back to the model 
            // by the treeview-listener, above; see issue 453 for more context
            IStructuredSelection selection = (IStructuredSelection)event.getSelection();
            ExplorerTreeViewer viewer = getTreeViewer();
            viewer.setSelectionToWidget(selection, true);
            
            // scroll to reveal all elements of the new selection
            for (Iterator iterator = selection.iterator(); iterator.hasNext();) {
              Object element = iterator.next();
              viewer.reveal(element);
            }
          }
        }
      }
    };
    selection.addSelectionChangedListener(m_selChangedListener);
    m_modelChangeListener = new ModelChangeAdapter() {
		public void modelElementLoaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				ExplorerTreeViewer viewer = getTreeViewer();
				Object parent = ((MonitorContentProvider) viewer.getContentProvider()).getParent(modelElement);
				UIUtil.refreshViewer(viewer, parent);
			}
		}
		public void modelElementUnloaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				ExplorerTreeViewer viewer = getTreeViewer();
				Object parent = ((MonitorContentProvider) viewer.getContentProvider()).getParent(modelElement);
				UIUtil.refreshViewer(viewer, parent);
			}
		}
	};
    Ooaofooa.addModelChangeListenerToAll(m_modelChangeListener);
	m_transactionListener = new ITransactionListener() {
			@Override
			public void transactionCancelled(Transaction transaction) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void transactionEnded(Transaction transaction) {
				PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
					
					@Override
					public void run() {
						getTreeViewer().refresh();	
					}
				});
			}

			@Override
			public void transactionStarted(Transaction transaction) {
				// TODO Auto-generated method stub
				
			}
		};
	TransactionManager.getSingleton().addTransactionListener(m_transactionListener);
    treeViewer.addOpenListener(new IOpenListener() {
      public void open(OpenEvent event) {
        handleOpen();
      }
    });
  }
  public static final boolean classInTree( Object o )
  {
  .// declare two empty inst_ref_set<O_OBJ>'s
  .select many all_referenced_class_set from instances of O_OBJ where (selected.Name == "-1" )
  .assign empty_class_set = all_referenced_class_set
  .//
  .for each node in tree_nodes 
    .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .assign all_referenced_class_set = all_referenced_class_set | class
  .end for
  .//
  .// add any classes that are only called out in T_TNS.NamingAttributeRelChain
  .//
  .for each node in tree_nodes
    .invoke arcc = add_rel_chain_classes( empty_class_set, node.NamingAttributeRelChain )
    .assign all_referenced_class_set = all_referenced_class_set | arcc.class_set
  .end for
  .//
  .// now do the same thing for T_TPS.ParentChildRelChain
  .//
  .select many parent_nodes from instances of T_TPS
  .for each parent in parent_nodes 
    .invoke arcc = add_rel_chain_classes( empty_class_set, parent.ParentChildRelChain )
    .assign all_referenced_class_set = all_referenced_class_set | arcc.class_set
  .end for
  .//
  .// special case classes
  .select any class from instances of O_OBJ where (selected.Key_Lett == "O_RATTR")
  .assign all_referenced_class_set = all_referenced_class_set | class
  .select any class from instances of O_OBJ where (selected.Key_Lett == "O_REF")
  .assign all_referenced_class_set = all_referenced_class_set | class
  .//
  .for each class in all_referenced_class_set 
    .invoke cn = get_class_name( class )
    if ( o instanceof ${cn.body} ) return true;
  .end for
    return false;
  }
  /**
   * Create the Actions provided by the Monitor View
   */
  protected void createActions() {
    collapseAll.setToolTipText(COLLAPSE);
    collapseAll.setImageDescriptor(CorePlugin.getImageDescriptor("collapseall.gif")); //$$NON-NLS-1$$
    WorkbenchHelp.setHelp(collapseAll, IModelExplorerHelpContextIds.COLLAPSE_ALL_ACTION);
    linkWithEditor = new Action(IWorkbenchActionConstants.SYNC_EDITOR) {
      public void run() {
        IStructuredSelection selection = (IStructuredSelection)Selection.getInstance().getSelection();
        getTreeViewer().setSelection(selection);
        for (Iterator iterator = selection.iterator(); iterator.hasNext();) {
          Object element = iterator.next();
          getTreeViewer().reveal(element);
        }
      }
    };
    linkWithEditor.setChecked(false);
    linkWithEditor.setText("Link With Editor");
    linkWithEditor.setToolTipText("Link with Editor");
    linkWithEditor.setImageDescriptor(CorePlugin.getImageDescriptor("synced.gif")); //$$NON-NLS-1$$
    // 'New' is provided as a sub-menu only. See 'createMenus'
    open = new Action(OPEN){
      public void run(){
        handleOpen();
      }
    };
    open.setText("Open");
    open.setToolTipText("Open this model Element");
    // 'Open With' is provided as a sub-menu only. See 'createMenus'
	cut = new Action(ActionFactory.CUT.getId()) {
      public void run() {
      }
	};
    cut.setText("Cut");
    cut.setToolTipText("Cut this model Element to the clipboard");
    cut.setImageDescriptor(CorePlugin.getImageDescriptor("cut_edit.gif")); //$$NON-NLS-1$$
    cut.setEnabled(false); // Retargetable Actions work removes this line
    copy = new Action(ActionFactory.COPY.getId()) {
      public void run() {
      }
    };
    copy.setText("Copy");
    copy.setToolTipText("Copy this model Element to the clipboard");
    copy.setImageDescriptor(CorePlugin.getImageDescriptor("copy_edit.gif")); //$$NON-NLS-1$$
    copy.setEnabled(false); // Retargetable Actions work removes this line
    paste = new Action(ActionFactory.PASTE.getId()) {
      public void run() {
      }
    };
    paste.setText("Paste");
    paste.setToolTipText("Paste from the clipboard");
    paste.setImageDescriptor(CorePlugin
        ..getImageDescriptor("paste_edit.gif")); //$$NON-NLS-1$$
    paste.setEnabled(false); // Retargetable Actions work removes this line
    //
    // Delete and Rename are retargetable actions defined by core.
    //
    delete = CorePlugin.getDeleteAction();
    rename = CorePlugin.getRenameAction(treeViewer);
    //
    fileImport = new Action(ActionFactory.IMPORT.getId()){
      public void run(){
		ImportResourcesAction ira = new ImportResourcesAction(
		    CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow());
		ira.run();
      }
    };
    fileImport.setText("Import...");
    fileImport.setToolTipText("Import a BridgePoint file");
    fileImport.setImageDescriptor(CorePlugin.getImageDescriptor("import_wiz.gif")); //$$NON-NLS-1$$
    fileExport = new Action(ActionFactory.EXPORT.getId()){
      public void run(){
		ExportResourcesAction era = new ExportResourcesAction(
		    CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow());
		era.run();
      }
    };
    fileExport.setText("Export...");
    fileExport.setToolTipText("Export a BridgePoint file");
    fileExport.setImageDescriptor(CorePlugin.getImageDescriptor("export_wiz.gif")); //$$NON-NLS-1$$
	treeRefresh = new Action(ActionFactory.REFRESH.getId()) {
		public void run() {
			RefreshAction ra = new RefreshAction(
				CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getShell());
			ra.run();
			getTreeViewer().refresh();
		}
	};
	treeRefresh.setText("Refresh");
	treeRefresh.setToolTipText("Refresh the tree");
	treeRefresh.setImageDescriptor(
		CorePlugin.getImageDescriptor("refresh.gif")); //$$NON-NLS-1$$
	treeRefresh.setAccelerator(SWT.F5);
	treeRefresh.setActionDefinitionId("org.eclipse.ui.file.refresh"); //$$NON-NLS-1$$
	getSite().getKeyBindingService().registerAction(treeRefresh);

  }
  /**
   * Create the menus for the monitor View
   */  
  protected void createMenus() {
    // Context Menu
    MenuManager menuManager = new MenuManager("#PopupMenu"); //$$NON-NLS-1$$
    menuManager.setRemoveAllWhenShown(true);
    final MenuManager createMenuManager = new MenuManager("Ne&w", "org.xtuml.bp.ui.newroot"); //$$NON-NLS-2$$
    final MenuManager openMenuManager = new MenuManager("Open Wit&h", "org.xtuml.bp.ui.openroot"); //$$NON-NLS-2$$
   	
   	final MenuManager classesMenu = new MenuManager("Classes", "org.xtuml.bp.ui.classroot"); //$$NON-NLS-2$$
	final MenuManager componentsMenu = new MenuManager("Components", "org.xtuml.bp.ui.componentroot"); //$$NON-NLS-2$$
	final MenuManager exceptionMenu = new MenuManager("Exceptions", "org.xtuml.bp.ui.exceptionroot"); //$$NON-NLS-2$$
	final MenuManager externalMenu = new MenuManager("External", "org.xtuml.bp.ui.externalroot"); //$$NON-NLS-2$$
	final MenuManager interactionMenu = new MenuManager("Interaction", "org.xtuml.bp.ui.interactionroot"); //$$NON-NLS-2$$
	final MenuManager activityMenu = new MenuManager("Activity", "org.xtuml.bp.ui.activityroot"); //$$NON-NLS-2$$
	final MenuManager typesMenu = new MenuManager("Types", "org.xtuml.bp.ui.typeroot"); //$$NON-NLS-2$$
	final MenuManager useCaseMenu = new MenuManager("Usecase", "org.xtuml.bp.ui.usecaseroot"); //$$NON-NLS-2$$

    menuManager.addMenuListener(new IMenuListener() {
      public void menuAboutToShow(IMenuManager mgr) {
        mgr.add(createMenuManager);
        createMenuManager.removeAll();
        createMenuManager.add(new GroupMarker("org.xtuml.bp.ui.newmenu")); //$$NON-NLS-1$$
        
        createMenuManager.add(activityMenu);
		activityMenu.removeAll();
		activityMenu.add(new GroupMarker("org.xtuml.bp.ui.newactivitymenu") );

		createMenuManager.add(classesMenu);
		classesMenu.removeAll();
		classesMenu.add(new GroupMarker("org.xtuml.bp.ui.newclassmenu") );

		createMenuManager.add(componentsMenu);
		componentsMenu.removeAll();
		componentsMenu.add(new GroupMarker("org.xtuml.bp.ui.newcomponentmenu") );

		createMenuManager.add(exceptionMenu);
		exceptionMenu.removeAll();
		exceptionMenu.add(new GroupMarker("org.xtuml.bp.ui.newexceptionmenu") );

		createMenuManager.add(externalMenu);
		externalMenu.removeAll();
		externalMenu.add(new GroupMarker("org.xtuml.bp.ui.newexternalmenu") );

		createMenuManager.add(interactionMenu);
		interactionMenu.removeAll();
		interactionMenu.add(new GroupMarker("org.xtuml.bp.ui.newinteractionmenu") );

		createMenuManager.add(typesMenu);
		typesMenu.removeAll();
		typesMenu.add(new GroupMarker("org.xtuml.bp.ui.newtypemenu") );

		createMenuManager.add(useCaseMenu);
		useCaseMenu.removeAll();
		useCaseMenu.add(new GroupMarker("org.xtuml.bp.ui.newusecasemenu") );
		
		new NewWizardMenu(createMenuManager, getSite().getWorkbenchWindow(), false);
        mgr.add(open);
        mgr.add(openMenuManager);
        openMenuManager.removeAll();
        openMenuManager.add(new GroupMarker("org.xtuml.bp.ui.openmenu")); //$$NON-NLS-1$$
        mgr.add(new Separator("org.xtuml.bp.ui.context-internal")); //$$NON-NLS-1$$
        mgr.add(new Separator("org.xtuml.bp.ui.context-internal-end")); //$$NON-NLS-1$$
        mgr.add(cut);
        mgr.add(copy);
        mgr.add(paste);
        mgr.add(delete);
        mgr.add(rename);
        mgr.add(new Separator());
        mgr.add(fileImport);
        mgr.add(fileExport);
		mgr.add(new Separator());
		mgr.add(treeRefresh);
        // If this is omitted, the platform complains because
        // it can't allow third party plug-ins to extend the menu
        // This is important for those who wish to use change
        // management plugins because Team menu items are added here.
        mgr.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
      }
    });
    Menu menu = menuManager.createContextMenu(treeViewer.getTree());
    treeViewer.getTree().setMenu(menu);
    getSite().setSelectionProvider(selection);
    getSite().registerContextMenu(menuManager, selection);
    // Titlebar Menu
    IMenuManager rootMenuManager = getViewSite().getActionBars().getMenuManager();
    rootMenuManager.setRemoveAllWhenShown(true);
    rootMenuManager.addMenuListener(new IMenuListener() {
      public void menuAboutToShow(IMenuManager mgr) {
        fillMenu(mgr);
      }
    });
    fillMenu(rootMenuManager);
  }
  /**
   * Fill the Explorer's Titlebar dropdown menu 
   */  
  protected void fillMenu(IMenuManager rootMenuManager) {
    rootMenuManager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
    rootMenuManager.add(linkWithEditor);
  }
  /**
   * Create the tool bar for the Monitor View 
   */  
  protected void createToolbar() {
    IActionBars actionBars = getViewSite().getActionBars();
    IToolBarManager toolBarManager = actionBars.getToolBarManager();
    toolBarManager.add(new Separator());
    toolBarManager.add(collapseAll);
    toolBarManager.add(linkWithEditor);
  }
  /*
   * @see IWorkbenchPart#setFocus()
   */
  public void setFocus() {
  }
  /**
   * Returns an adapter if available
   * @see IAdaptable#getAdapter
   */
  public Object getAdapter(Class adapter) {
    if (adapter.equals(IPropertySheetPage.class)) {
      return getPropertySheet();
    }
    return super.getAdapter(adapter);
  }
  /**
   * return a property sheet if available
   */
  protected IPropertySheetPage getPropertySheet() {
        PropertySheetPage pss =  new PropertySheetPage();
        pss.setPropertySourceProvider(new ModelPropertySourceProvider());
        return pss;
  }
  /**
   * Fire up an editor
   */
  private IEditorPart handleOpen() {
    
    IStructuredSelection sel = (IStructuredSelection) selection.getSelection();
	if (sel.isEmpty())
	{
		return null;
	}
	Object current = sel.iterator().next();    
    String name = current.getClass().getName();
    //
    // Get the registry
    //
    IExtensionRegistry reg = Platform.getExtensionRegistry();
    //
    // Get all the plugins that have extended this point
    //
    IExtensionPoint extPt = reg.getExtensionPoint("org.xtuml.bp.core.editors"); //$$NON-NLS-1$$
    IExtension[] exts = extPt.getExtensions();
    // Repeat for each extension until we find a default editor
    for (int i=0; i < exts.length; i++) {
      IConfigurationElement[] elems = exts[i].getConfigurationElements();
      for (int j=0; j < elems.length; j++) {
        // Find the editor elements
        if (elems[j].getName().equals("editor")){                                  //$$NON-NLS-1$$
          IConfigurationElement[] edElems = elems[j].getChildren();
          for (int k=0; k < edElems.length; k++) {
            //
            // Is this editor the default for the current model element ?
            //
            if (edElems[k].getName().equals("defaultFor") &&                       //$$NON-NLS-1$$
                edElems[k].getAttribute("class").equals(name) ) {                  //$$NON-NLS-1$$
              try {
                //
                // Get the class supplied for the input
                //
                Bundle bundle = Platform.getBundle(elems[j]
                                      ..getDeclaringExtension().getNamespace());
                Class inputClass = bundle.loadClass(
                                       elems[j].getAttribute("input"));//$$NON-NLS-1$$
                Class[] type = new Class[1];
                type[0] = Object.class;
                //
                // Dynamically get the method createInstance, the supplied class must implement this
                //
                Method createInstanceMethod = inputClass.getMethod("createInstance", type);          //$$NON-NLS-1$$
                Object[] args = new Object[1];
                args[0] = current;
                //
                // Invoke the method.
                // The method is static; no instance is needed, so first argument is null
                //
                IEditorInput input = (IEditorInput)createInstanceMethod.invoke(null, args);
                //
                // pass the input to the Eclipse editor, along with the class name supplied by
                // the extending plugin.
                //
                if (input != null) {
                  return PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().openEditor(
                    input,
                    elems[j].getAttribute("class"));                                 //$$NON-NLS-1$$
                }
                return null;
              }
              catch (ClassNotFoundException e){
                ExplorerPlugin.logError("Input Class not found", e);//$$NON-NLS-1$$
              }
              catch (NoSuchMethodException e) {
                ExplorerPlugin.logError("Class does not implement static method createInstance", e);//$$NON-NLS-1$$
              }
              catch (InvocationTargetException e) {
                // In the situation where an attempt is made to open an activity editor on an Attribute,
                // we ignore the error.  The reason is that this model element has 2 different editors
                // associated with.  When it is a MDA we open the activity editor, when it is not an
                // MDA we still try to open the activity editor, but there is not one and this exception
                // gets thrown.  We ignore the exception in this situation, and the description editor is
                // then opened as it should be.
                boolean ignoreError = (elems[j].getAttribute("input").contains("ActivityEditorInput") && name.contains("Attribute_c"));
                if (!ignoreError) {
                  ExplorerPlugin.logError("Exception occured on invocation of static method createInstance of the Target", e.getTargetException());//$$NON-NLS-1$$
                }
              }
              catch (IllegalAccessException e) {
                ExplorerPlugin.logError("Target does not support static method createInstance", e);//$$NON-NLS-1$$
              }
              catch (PartInitException e) {
                ExplorerPlugin.logError("Could not activate Editor", e);//$$NON-NLS-1$$
              }
            }
          }
        }
      }
    }

    return null; 
  }
  /**
   * Dispose of the Explorer widget
   */ 
  public void dispose() {
    super.dispose();
    Ooaofooa.removeModelChangeListenerFromAll(m_modelChangeListener);
	TransactionManager.getSingleton().removeTransactionListener(m_transactionListener);
    selection.removeSelectionChangedListener(m_selChangedListener);
  }
  /**
   * Initialize the Label provider to link it into the chain 
   * of platform label decorators.
   */
  protected void initLabelProvider(TreeViewer viewer){
    viewer.setLabelProvider(
       new DecoratingLabelProvider(
                              (ILabelProvider)viewer.getLabelProvider(),
                              CorePlugin.getDefault().getWorkbench().
                              getDecoratorManager().getLabelDecorator()));
  }

	/**
	 * Sets whether this explorer's selection is linked to that of the 
	 * whichever editor is currently open.  This method is used by
	 * automated test programs to simulate pressing/unpressing the 
	 * "Link with Editor" button of the explorer.
	 */ 
	public void setLinkWithEditor(boolean link)
	{
		linkWithEditor.setChecked(link);
	}
    /**
     * Has this explorer-view behave as if its open-action was just
     * invoked.  Returns the editor that was opened.  For automated test purposes.
     */
    public IEditorPart doOpen() {
        return handleOpen();
    }

    /**
     * Has this explorer-view behave as if its delete-action was just
     * invoked.  For automated test purposes.
     */
    public void doDelete() {
        delete.run();
    }
	
	/**
     * To disable or Enable rename and delete actions
     * 
     */
	private void keyActionsActivation(){
		IStructuredSelection structuredSelection=Selection.getInstance().getStructuredSelection();
     	Object context = structuredSelection.getFirstElement();
     	if(context instanceof  NonRootModelElement ){
     		rename.setEnabled(RenameAction.canRenameAction());
     	}
     	boolean enableDel = false;
		IStructuredSelection selection = Selection.getInstance().getStructuredSelection();
		if (!selection.isEmpty()) {
			enableDel = true;
			// Iterate through removing elements that are only graphical
			for (Iterator iter = selection.iterator(); iter.hasNext();) {
				Object current = iter.next();
				if (!(current instanceof NonRootModelElement)) {
					enableDel = false;
					break;
				}
			}

		}
		if(enableDel){
			delete.setEnabled(DeleteAction.canDeleteAction());
		}else{
			delete.setEnabled(enableDel);
		}

	}
}
.end function
.//
.function add_rel_chain_classes
  .param inst_ref_set p_result_set   .// an empty inst_ref_set<O_OBJ>
  .param string p_rel_chain
  .//
  .while ("$r{p_rel_chain}" != "")
    .invoke nav = parse_chain(p_rel_chain, "backward")
    .if (not_empty nav.class)
      .assign cl = nav.class
      .assign p_result_set = p_result_set | cl
    .end if
    .assign p_rel_chain = nav.remainder
  .end while
  .assign attr_class_set = p_result_set
.end function

