//=====================================================================
//
//File:      $RCSfile: ArrayBaseTest.java,v $
//Version:   $Revision: 1.8 $
//Modified:  $Date: 2013/05/10 04:52:47 $
//
// NOTE: This file was generated, but is maintained by hand.
// Generated by: UnitTestGenerator.pl
// Version:      1.9
// Matrix:       SingleDimensionFixedArrayAssigmentMatrix.txt
//
//(c) Copyright 2007-2014 by Mentor Graphics Corp. All rights reserved.
//
//=====================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License.  You may obtain a copy 
// of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the 
// License for the specific language governing permissions and limitations under
// the License.
//=====================================================================

package org.xtuml.bp.als.oal.test;

import java.io.StringReader;
import java.util.regex.Pattern;

import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.jface.preference.IPreferenceStore;
import org.junit.After;
import org.junit.Before;
import org.junit.runner.RunWith;
import org.xtuml.bp.als.oal.OalLexer;
import org.xtuml.bp.als.oal.OalParser;
import org.xtuml.bp.als.oal.Oal_validate;
import org.xtuml.bp.core.ActionHome_c;
import org.xtuml.bp.core.Action_c;
import org.xtuml.bp.core.Block_c;
import org.xtuml.bp.core.Body_c;
import org.xtuml.bp.core.BridgeBody_c;
import org.xtuml.bp.core.Bridge_c;
import org.xtuml.bp.core.Component_c;
import org.xtuml.bp.core.CorePlugin;
import org.xtuml.bp.core.ExternalEntity_c;
import org.xtuml.bp.core.FunctionBody_c;
import org.xtuml.bp.core.Function_c;
import org.xtuml.bp.core.InstanceStateMachine_c;
import org.xtuml.bp.core.InterfaceReference_c;
import org.xtuml.bp.core.ModelClass_c;
import org.xtuml.bp.core.MooreActionHome_c;
import org.xtuml.bp.core.Oalconstants_c;
import org.xtuml.bp.core.Ooaofooa;
import org.xtuml.bp.core.OperationBody_c;
import org.xtuml.bp.core.Operation_c;
import org.xtuml.bp.core.Port_c;
import org.xtuml.bp.core.ProvidedExecutableProperty_c;
import org.xtuml.bp.core.ProvidedOperationBody_c;
import org.xtuml.bp.core.ProvidedOperation_c;
import org.xtuml.bp.core.Provision_c;
import org.xtuml.bp.core.RequiredExecutableProperty_c;
import org.xtuml.bp.core.RequiredOperationBody_c;
import org.xtuml.bp.core.RequiredOperation_c;
import org.xtuml.bp.core.Requirement_c;
import org.xtuml.bp.core.StateActionBody_c;
import org.xtuml.bp.core.StateMachineState_c;
import org.xtuml.bp.core.StateMachine_c;
import org.xtuml.bp.core.TransitionActionBody_c;
import org.xtuml.bp.core.common.BridgePointPreferencesStore;
import org.xtuml.bp.core.common.ClassQueryInterface_c;
import org.xtuml.bp.core.util.ContainerUtil;
import org.xtuml.bp.test.common.BaseTest;
import org.xtuml.bp.test.common.OrderedRunner;
import org.xtuml.bp.test.common.TestingUtilities;
import org.xtuml.bp.ui.canvas.test.CanvasTest;
import org.xtuml.bp.ui.graphics.editor.GraphicalEditor;

import antlr.RecognitionException;
import antlr.TokenStreamException;
import antlr.TokenStreamRecognitionException;

@RunWith(OrderedRunner.class)
public class ArrayBaseTest extends CanvasTest {
	public static boolean generateResults = false;
	private static boolean m_requiresClear = false;
	private static int m_funcType = 0;
	private static int m_funcNum = 0;
	static public Ooaofooa arrayModelRoot;
    protected final String projectName = "APVT";

	String test_id = "";

	protected String getResultName() {
		return getClass().getSimpleName() + "_" + test_id;
	}

	protected GraphicalEditor fActiveEditor;

	protected GraphicalEditor getActiveEditor() {
		return fActiveEditor;
	}

	public ArrayBaseTest(String subTypeClassName, String subTypeArg0) {
		super(null, subTypeArg0);
	}

	protected String getTestId(String src, String dest, String count) {
		return "test_" + count;
	}

	@Before
	public void setUp() throws Exception {
		super.setUp();
	}

	@Override
	public void initialSetup() throws CoreException {
		TestingUtilities.importTestingProjectIntoWorkspace(projectName);
		project = ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);
		m_sys = getSystemModel(projectName);
		BaseTest.dispatchEvents(0);
		arrayModelRoot = Ooaofooa.getInstance("/APVT/models/APVT/Arrays/Arrays.xtuml");

		IPreferenceStore store = CorePlugin.getDefault().getPreferenceStore();
		store
				.setValue(
						BridgePointPreferencesStore.ALLOW_IMPLICIT_COMPONENT_ADDRESSING,
						true);

		class ComponentNameTest implements ClassQueryInterface_c {
			public boolean evaluate(Object candidate) {
				Component_c selected = (Component_c) candidate;
				return selected.getName().equals("SingleDimensionFixedArrays");
			}
		}
		Component_c comp = Component_c.ComponentInstance(arrayModelRoot,
				new ComponentNameTest());

		populateFunctionInstances();
		populateBridgeInstances();
		class Object_test1_c implements ClassQueryInterface_c {
			Object_test1_c(String id) {
				m_id = id;
			}

			private String m_id;

			public boolean evaluate(Object inst) {
				ModelClass_c selected = (ModelClass_c) inst;
				return selected.getKey_lett().equals(m_id);
			}
		}
		ModelClass_c testObj = ModelClass_c.ModelClassInstance(arrayModelRoot,
				new Object_test1_c("A_T"));//$NON-NLS-1$

		populateTransformerInstances(testObj, false);

		populateInterfaceOperationInstances(comp, "Port1", true);
		populateInterfaceOperationInstances(comp, "Port2", false);
		populateArrayStateActionInstances();
	}
	
	@After
	public void tearDown() throws Exception {
		try {
			super.tearDown();
			ArrayBaseTest.tearDownActionData();
		} catch (RecognitionException re) {
			// do nothing
		} catch (TokenStreamException te) {
			// do nothing
		}
	}

	static public void tearDownActionData() throws RecognitionException,
			TokenStreamException {
		if (m_requiresClear) {
			clearActionData(m_funcType, m_funcNum);
		}
	}

	final static String Failure1 = "Undetected error : Variable already exists as a different type";
	final static String Failure2 = "Undetected error : Variable has incompatible array depth";
	final static String Failure3 = "Undetected error : Variable has index out of bound";
	final static String Failure4 = "Undetected error : Variable has an incompatible array length for dimension 0";
	final static String Failure5 = "Undetected error : Negative array indexes are not allowed";
	final static String Failure6 = "Undetected error : The rvalue contains an Array Index Out of Bounds";
	final static String Failure7 = "Undetected error : The rvalue has incompatible array depth";
	final static String ParamFailure1 = "Undetected error : Parameter has been assigned value of different type.";
	final static String ParamFailure2 = "Undetected error : Parameter has incompatible array depth.";
	final static String ParamFailure3 = "Undetected error : Parameter contains an Array Index Out of Bounds.";
	final static String ParamFailure4 = "Undetected error : Parameter has an incompatible array length for dimension 0";
	final static String ReturnFailure1 = "Undetected error : Invalid data type returned for operation.";
	final static String ReturnFailure2 = "Undetected error : Return type has incompatible array depth.";
	final static String ReturnFailure4 = "Undetected error : Return type has an incompatible array length for dimension 0";
	final static String ReturnFailureBridge2 = "Undetected error : Return type has incompatible array depth.";
	final static String ReturnFailureBridge4 = "Undetected error : Return type has an incompatible array length for dimension 0";
	
	final static String Success = "Parser detects error where the OAL is correct";

	static final int ACTIVITY_TYPE_FUNC = 0;
	static final int ACTIVITY_TYPE_BRG = 1;
	static final int ACTIVITY_TYPE_CB_OP = 2;
	static final int ACTIVITY_TYPE_INT_RO = 3;
	static final int ACTIVITY_TYPE_INT_PO = 4;
	static final int ACTIVITY_TYPE_ArraySTATE = 5;

	static public String parseAction(String stmts, int funcType, int funcNum)
			throws RecognitionException, TokenStreamException {
		// m_requiresClear = true;
		m_funcType = funcType;
		m_funcNum = funcNum;
		OalLexer lexer = new OalLexer(new StringReader(stmts));
		OalParser parser;
		parser = new OalParser(arrayModelRoot, lexer);
		try {
			switch (funcType) {
			case ACTIVITY_TYPE_FUNC:
				parser.m_oal_context = new Oal_validate(ContainerUtil
						.getContainer(m_testFunc[funcNum]));
				m_testFunc[funcNum].setAction_semantics_internal(stmts);
				parser.action(m_testFunc[funcNum].getSync_id(),
						Oalconstants_c.FUNCTION_TYPE);
				break;
			case ACTIVITY_TYPE_BRG:
				parser.m_oal_context = new Oal_validate(ContainerUtil
						.getContainer(m_testBrg[funcNum]));
				m_testBrg[funcNum].setAction_semantics_internal(stmts);
				parser.action(m_testBrg[funcNum].getBrg_id(),
						Oalconstants_c.BRIDGE_TYPE);
				break;
			case ACTIVITY_TYPE_CB_OP:
				parser.m_oal_context = new Oal_validate(ContainerUtil
						.getContainer(m_testCBTfr[funcNum]));
				m_testCBTfr[funcNum].setAction_semantics_internal(stmts);
				parser.action(m_testCBTfr[funcNum].getTfr_id(),
						Oalconstants_c.OPERATION_TYPE);
				break;
			case ACTIVITY_TYPE_INT_RO:
				parser.m_oal_context = new Oal_validate(ContainerUtil
						.getContainer(m_testReqOpr[funcNum]));
				m_testReqOpr[funcNum].setAction_semantics_internal(stmts);
				parser.action(m_testReqOpr[funcNum].getId(),
						Oalconstants_c.REQ_OPERATION_TYPE);
				break;
			case ACTIVITY_TYPE_INT_PO:
				parser.m_oal_context = new Oal_validate(ContainerUtil
						.getContainer(m_testProvOpr[funcNum]));
				m_testProvOpr[funcNum].setAction_semantics_internal(stmts);
				parser.action(m_testProvOpr[funcNum].getId(),
						Oalconstants_c.PROV_OPERATION_TYPE);
				break;

			case ACTIVITY_TYPE_ArraySTATE:
				parser.m_oal_context = new Oal_validate(ContainerUtil
						.getContainer(m_arrayStateAction[funcNum]));
				TransitionActionBody_c tab2 = TransitionActionBody_c
						.getOneACT_TABOnR688(m_arrayStateAction[funcNum]);
				if (tab2 != null) {
					Body_c body = Body_c.getOneACT_ACTOnR698(tab2);
					body.Dispose();
				}
				m_arrayStateAction[funcNum].setAction_semantics_internal(stmts);
				parser.action(m_arrayStateAction[funcNum].getAct_id(),
						Oalconstants_c.STATE_TYPE);
				break;
			default:
				fail("parseAction: Unknown Activity type constant");
			}
		} catch (TokenStreamException e) {
			Block_c.Clearcurrentscope(arrayModelRoot,
					parser.m_oal_context.m_act_id);
			if (e instanceof TokenStreamRecognitionException) {
				TokenStreamRecognitionException tsre = (TokenStreamRecognitionException) e;
				parser.reportError(tsre.recog);
			} else {
				fail("Token stream exception in parser");
			}
		} catch (RecognitionException e) {
			Block_c.Clearcurrentscope(arrayModelRoot,
					parser.m_oal_context.m_act_id);
			parser.reportError(e);
		} catch (InterruptedException ie) {
		}
		return parser.m_output;
	}

	static public void clearActionData(int funcType, int funcNum)
			throws RecognitionException, TokenStreamException {
		switch (funcType) {
		case ACTIVITY_TYPE_FUNC:
			Body_c actact = Body_c.getOneACT_ACTOnR698(FunctionBody_c
					.getOneACT_FNBOnR695(m_testFunc[funcNum]));
			if (actact != null) {
				actact.Clear_blocks();
			}
			break;
		case ACTIVITY_TYPE_BRG:
			actact = Body_c.getOneACT_ACTOnR698(BridgeBody_c
					.getOneACT_BRBOnR697(m_testBrg[funcNum]));
			if (actact != null) {
				actact.Clear_blocks();
			}
			break;
		case ACTIVITY_TYPE_CB_OP:
			actact = Body_c.getOneACT_ACTOnR698(OperationBody_c
					.getOneACT_OPBOnR696(m_testCBTfr[funcNum]));
			if (actact != null) {
				actact.Clear_blocks();
			}
			break;
		case ACTIVITY_TYPE_INT_RO:
			actact = Body_c.getOneACT_ACTOnR698(RequiredOperationBody_c
					.getOneACT_ROBOnR685(m_testReqOpr[funcNum]));
			if (actact != null) {
				actact.Clear_blocks();
			}
			break;
		case ACTIVITY_TYPE_INT_PO:
			actact = Body_c.getOneACT_ACTOnR698(ProvidedOperationBody_c
					.getOneACT_POBOnR687(m_testProvOpr[funcNum]));
			if (actact != null) {
				actact.Clear_blocks();
			}
			break;
		case ACTIVITY_TYPE_ArraySTATE:
			actact = Body_c.getOneACT_ACTOnR698(StateActionBody_c
					.getOneACT_SABOnR691(m_arrayStateAction[funcNum]));
			if (actact != null) {
				actact.Clear_blocks();
			}
		default:
			fail("clearAction: Unknown Activity type constant");
		}
		m_requiresClear = false;
	}

	static public final int TEST_VOID_NO_PARM = 0;
	static public final int void_paramRef_int_SF_test1 = 1;
	static public final int void_paramRef_int_SF_test2 = 2;
	static public final int void_paramRef_int_SF_test3 = 3;
	static public final int int_SF_Param_test1 = 4;
	static public final int int_SF_Param_test2 = 5;
	static public final int int_SF_Param_test3 = 6;
	static private String funcs[] = { "testVoidNoParam",
			"voidParamRefIntSFtTest1",//$NON-NLS-1$
			"voidParamRefIntSFtTest2",//$NON-NLS-1$
			"voidParamRefIntSFtTest3",//$NON-NLS-1$
			"intSFParamTest1",//$NON-NLS-1$
			"intSFParamTest2",//$NON-NLS-1$
			"intSFParamTest3" };//$NON-NLS-1$

	public static Function_c[] m_testFunc = new Function_c[funcs.length];
	public static Bridge_c[] m_testBrg = new Bridge_c[funcs.length];
	public static Operation_c[] m_testCBTfr = new Operation_c[funcs.length];
	public static Operation_c[] m_testIBTfr = new Operation_c[funcs.length];
	public static RequiredOperation_c[] m_testReqOpr = new RequiredOperation_c[funcs.length];
	public static ProvidedOperation_c[] m_testProvOpr = new ProvidedOperation_c[funcs.length];

	private void populateInterfaceOperationInstances(Component_c comp,
			String portName, boolean Required) {

		Port_c[] ports = Port_c.getManyC_POsOnR4010(comp);
		for (int i = 0; i < ports.length; ++i) {
			if (ports[i].getName().equalsIgnoreCase(portName)) {
				// BirdgePoint support only single interface reference for a
				// port
				// so select One interface reference only
				InterfaceReference_c intRef = InterfaceReference_c
						.getOneC_IROnR4016(ports[i]);

				Requirement_c req = Requirement_c.getOneC_ROnR4009(intRef);
				Provision_c prov = Provision_c.getOneC_POnR4009(intRef);
				String[] interfaceOperations;
				if (req != null && Required) { // Required Interface
					RequiredExecutableProperty_c[] REPs = RequiredExecutableProperty_c
							.getManySPR_REPsOnR4500(req);
					for (int j = 0; j < funcs.length; ++j) {

						class ReqOperation_test1_c implements
								ClassQueryInterface_c {
							ReqOperation_test1_c(String p) {
								m_p = p;
							}

							private String m_p;

							public boolean evaluate(Object inst) {
								RequiredOperation_c selected = (RequiredOperation_c) inst;
								return selected.getName().equals(m_p);
							}
						}

						RequiredOperation_c testOpr = RequiredOperation_c
								.getOneSPR_ROOnR4502(REPs,
										new ReqOperation_test1_c(funcs[j]));
						if (testOpr != null) {
							if (m_testReqOpr[j] == null) {
								m_testReqOpr[j] = testOpr;
							}
						} else
							fail("Missing Interface Operation " + m_testReqOpr[j]);//$NON-NLS-1$

					}
					return;
				} else if (prov != null && !Required) { // Provided Interface
					ProvidedExecutableProperty_c[] PEPs = ProvidedExecutableProperty_c
							.getManySPR_PEPsOnR4501(prov);
					for (int j = 0; j < funcs.length; ++j) {

						class ProvOperation_test1_c implements
								ClassQueryInterface_c {
							ProvOperation_test1_c(String p) {
								m_p = p;
							}

							private String m_p;

							public boolean evaluate(Object inst) {
								ProvidedOperation_c selected = (ProvidedOperation_c) inst;
								return selected.getName().equals(m_p);
							}
						}

						ProvidedOperation_c testOpr = ProvidedOperation_c
								.getOneSPR_POOnR4503(PEPs,
										new ProvOperation_test1_c(funcs[j]));
						if (testOpr != null) {
							if (m_testProvOpr[j] == null) {
								m_testProvOpr[j] = testOpr;
							}
						} else
							fail("Missing Interface Operation " + m_testReqOpr[j]);//$NON-NLS-1$
					}
					return;
				} else {
					fail("Port" + portName + "is defined as" + (Required ? "Provided" : "Required") + "interface.");//$NON-NLS-1$
				}
			}
		}
		fail("Can not find port " + portName);//$NON-NLS-1$		
	}

	private void populateFunctionInstances() {
		class Function_test1_c implements ClassQueryInterface_c {
			Function_test1_c(String p) {
				m_p = p;
			}

			private String m_p;

			public boolean evaluate(Object inst) {
				Function_c selected = (Function_c) inst;
				return selected.getName().equals(m_p);
			}
		}
		for (int i = 0; i < funcs.length; ++i) {
			Function_c testFunc = Function_c.FunctionInstance(arrayModelRoot,
					new Function_test1_c(funcs[i]));
			if (testFunc != null) {
				if (m_testFunc[i] == null)
					m_testFunc[i] = testFunc;
			} else
				fail("Missing function " + funcs[i]);//$NON-NLS-1$
		}
	}

	private void populateBridgeInstances() {
		class EE_test1_c implements ClassQueryInterface_c {
			EE_test1_c(String p) {
				m_p = p;
			}

			private String m_p;

			public boolean evaluate(Object inst) {
				ExternalEntity_c selected = (ExternalEntity_c) inst;
				return selected.getKey_lett().equals(m_p);
			}
		}
		ExternalEntity_c testEE = ExternalEntity_c.ExternalEntityInstance(
				arrayModelRoot, new EE_test1_c("T"));//$NON-NLS-1$
		if (testEE == null)
			fail("Unknown external entity T");//$NON-NLS-1$
		class Bridge_test1_c implements ClassQueryInterface_c {
			Bridge_test1_c(String p) {
				m_p = p;
			}

			private String m_p;

			public boolean evaluate(Object inst) {
				Bridge_c selected = (Bridge_c) inst;
				return selected.getName().equals(m_p);
			}
		}
		for (int i = 0; i < funcs.length; ++i) {
			Bridge_c testFunc = Bridge_c.BridgeInstance(arrayModelRoot,
					new Bridge_test1_c(funcs[i]));
			if (testFunc != null) {
				if (m_testBrg[i] == null)
					m_testBrg[i] = testFunc;
			} else
				fail("Missing bridge " + funcs[i]);//$NON-NLS-1$
		}
	}

	private void populateTransformerInstances(ModelClass_c testObj,
			boolean instanceBased) {
		for (int i = 0; i < funcs.length; ++i) {
			Operation_c[] testObjTrans = Operation_c
					.getManyO_TFRsOnR115(testObj);
			Operation_c testTrans = null;
			for (int tfrInstCount = 0; tfrInstCount < testObjTrans.length; tfrInstCount++) {
				Operation_c selected = testObjTrans[tfrInstCount];
				if (selected.getName().equals(funcs[i])) {
					testTrans = testObjTrans[tfrInstCount];
					break;
				}
			}
			if (testTrans != null) {
				if (instanceBased) {
					if (m_testIBTfr[i] == null)
						m_testIBTfr[i] = testTrans;
				} else {
					if (m_testCBTfr[i] == null)
						m_testCBTfr[i] = testTrans;
				}
			} else
				fail("Missing operation " + testObj.getKey_lett() + "::" + funcs[i]);//$NON-NLS-1$//$NON-NLS-2$
		}
	}

	public static Action_c[] m_arrayStateAction = new Action_c[3];
	static public final int State_StateOne = 0;
	static public final int State_StateTwo = 1;
	static public final int State_StateThree = 2;

	private void populateArrayStateActionInstances() {
		class Object_test1_c implements ClassQueryInterface_c {
			Object_test1_c(String p) {
				m_p = p;
			}

			private String m_p;

			public boolean evaluate(Object inst) {
				ModelClass_c selected = (ModelClass_c) inst;
				return selected.getName().equals(m_p);
			}
		}
		ModelClass_c obj = ModelClass_c.ModelClassInstance(arrayModelRoot,
				new Object_test1_c("ArrayOne"));//$NON-NLS-1$
		InstanceStateMachine_c ism = InstanceStateMachine_c
				.getOneSM_ISMOnR518(obj);
		StateMachine_c sm_i = StateMachine_c.getOneSM_SMOnR517(ism);
		StateMachineState_c[] states = StateMachineState_c
				.getManySM_STATEsOnR501(sm_i);
		Action_c i_acts[] = Action_c.getManySM_ACTsOnR514(ActionHome_c
				.getManySM_AHsOnR513(MooreActionHome_c
						.getManySM_MOAHsOnR511(states)));
		for (int i = 0; i < i_acts.length; ++i) {
			ActionHome_c ah = ActionHome_c.getOneSM_AHOnR514(i_acts[i]);
			MooreActionHome_c moah = MooreActionHome_c.getOneSM_MOAHOnR513(ah);
			StateMachineState_c st = StateMachineState_c
					.getOneSM_STATEOnR511(moah);
			if (st.getName().equals("StateOne"))//$NON-NLS-1$
				m_arrayStateAction[State_StateOne] = i_acts[i];
			else if (st.getName().equals("StateTwo"))//$NON-NLS-1$
				m_arrayStateAction[State_StateTwo] = i_acts[i];
			else if (st.getName().equals("StateThree"))//$NON-NLS-1$
				m_arrayStateAction[State_StateThree] = i_acts[i];

		}

	}

	/**
	 * "TRVD" is one of the degrees of freedom as specified in this issues test
	 * matrix. This routine gets the "TRVD" instance from the given name.
	 * 
	 * @param element
	 *            The degree of freedom instance to retrieve
	 * @return A model element used in the test as specified by the test matrix
	 */
	String selectTRVD(String element) {
		return element;
	}

	/**
	 * "TLVD" is one of the degrees of freedom as specified in this issues test
	 * matrix. This routine gets the "TLVD" instance from the given name.
	 * 
	 * @param element
	 *            The degree of freedom instance to retrieve
	 * @return A model element used in the test as specified by the test matrix
	 */
	String selectTLVD(String element) {
		return element;
	}

	/**
	 * "T" is one of the degrees of freedom as specified in this issues test
	 * matrix. This routine gets the "T" instance from the given name.
	 * 
	 * @param element
	 *            The degree of freedom instance to retrieve
	 * @return A model element used in the test as specified by the test matrix
	 */
	String selectT(String element) {
		String ele = "";
		if (element.equalsIgnoreCase("T1")) {
			ele = "T1";
		} else
			assertTrue(
					"An instance with degree of freedom type \"T\" was not found.  Instance Name: "
							+ element + ".", !ele.isEmpty());
		return ele;
	}

	private static String[] leftValueDimension = { "extra fieled", "[0]",
			"[3]", "[6]", "[3]", "[3]", "[3]", "[3]", "[3]", "[3]" };
	private static String[] leftValueIndexValue = { "extra field", "", "", "",
			"[4]", "[-1]", "[3]", "[5]", "[0]", "[1][5]" };
	private static String[] rightValueDimension = { "extra fieled", "[0]",
			"[3]", "[6]", "[3]", "[3]", "[3]", "[3]", "[3]", "[3]" };
	private static String[] rightValueIndexValue = { "extra field", "", "", "",
			"[4]", "[-1]", "[3]", "[5]", "[0]", "[1][5]" };

	private static int activity_type;
	private static int activity_name;

	/**
	 * This routine performs the action associated with a matrix cell. The
	 * parameters represent model instances aquired based on the specifed column
	 * instance and row instance.
	 * 
	 * @param columnInstance
	 *            Model instance from the column
	 * @param rowInstance
	 *            Model instance from the row
	 * @return TODO
	 * @throws RecognitionException
	 *             TODO
	 * @throws TokenStreamException
	 *             TODO
	 */

	String T_TLVD_Action(String rightValue, String leftValue)
			throws RecognitionException, TokenStreamException {
		String act = "";
		String result = "";
		int leftValueDim = -1;

		// get activity type
		activity_type = selectActivityType(rightValue, leftValue);

		// set default activity name

		activity_name = ArrayBaseTest.TEST_VOID_NO_PARM;
		// get the instance number of dimension
		leftValueDim = getDimensionValue(leftValue);

		// create the variable array
		if (rightValue.equalsIgnoreCase("T1")) {
			act = "integer=1;\n";
		}
		act = act.concat(OALCodeBuilder("=integer;", leftValue, leftValueDim));

		// Action
		result = ArrayBaseTest.parseAction(act, activity_type, activity_name);

		return result;
	}

	// SelectActivityTtpe get the right context to be used in parsering
	// it can be Function/Class Operation/Bridge/Inteface Operation - provided
	// or required-
	int selectActivityType(String rightValue, String leftValue) {
		if (rightValue.equals("T1") || rightValue.contains("RV")) {
			if (leftValue.contains("LV1D") || leftValue.contains("LV2D")
					|| leftValue.contains("LV7D") || leftValue.contains("LV12")
					|| leftValue.contains("LV13") || leftValue.contains("LV15")
					|| leftValue.contains("LV14")) {
				if (rightValue.contains("RV3D")) {
					return ArrayBaseTest.ACTIVITY_TYPE_CB_OP;
				} else if (rightValue.contains("RV4D")) {
					return ArrayBaseTest.ACTIVITY_TYPE_FUNC;
				} else if (rightValue.contains("RV5D")) {
					return ArrayBaseTest.ACTIVITY_TYPE_INT_RO;
				} else if (rightValue.contains("RV6D")) {
					return ArrayBaseTest.ACTIVITY_TYPE_BRG;
				} else if (rightValue.contains("RV7D")) {
					return ArrayBaseTest.ACTIVITY_TYPE_ArraySTATE;
				} else {
					return ArrayBaseTest.ACTIVITY_TYPE_FUNC;
				}

			} else if (leftValue.contains("LV3D") || leftValue.contains("LV8D")) {
				return ArrayBaseTest.ACTIVITY_TYPE_CB_OP;
			} else if (leftValue.contains("LV4D") || leftValue.contains("LV9D")) {
				return ArrayBaseTest.ACTIVITY_TYPE_FUNC;
			} else if (leftValue.contains("LV5D") || leftValue.contains("LV11")) {
				return ArrayBaseTest.ACTIVITY_TYPE_INT_RO;
			} else if (leftValue.contains("LV6D") || leftValue.contains("LV10")) {
				return ArrayBaseTest.ACTIVITY_TYPE_BRG;
			} else if (leftValue.contains("LV14")) {
				return ArrayBaseTest.ACTIVITY_TYPE_INT_PO;
			}
		}

		return -1;
	}

	// GetDimensionValue used to get the number of the dimension instance
	// e.g. T1LV1D5 : return value is 5
	int getDimensionValue(String instance) {
		int dim;
		if (instance.length() == 8) {
			dim = Integer.parseInt(String.valueOf(instance.charAt(7)));
		} else {
			dim = Integer.parseInt(String.valueOf(instance.charAt(6)));
		}
		return dim;
	}

	/**
	 * This routine performs the action associated with a matrix cell. The
	 * parameters represent model instances aquired based on the specifed column
	 * instance and row instance.
	 * 
	 * @param columnInstance
	 *            Model instance from the column
	 * @param rowInstance
	 *            Model instance from the row
	 * @return TODO
	 * @throws RecognitionException
	 *             TODO
	 * @throws TokenStreamException
	 *             TODO
	 */
	String TRVD_TLVD_Action(String rightValue, String leftValue)
			throws RecognitionException, TokenStreamException {
		String act = "";
		String result = "";
		int leftValueDim = -1;
		int rightValueDim = -1;

		// get activity type
		activity_type = selectActivityType(rightValue, leftValue);

		// set default activity name
		activity_name = ArrayBaseTest.TEST_VOID_NO_PARM;

		leftValueDim = getDimensionValue(leftValue);
		rightValueDim = getDimensionValue(rightValue);

		// right side is Variable Array
		if (rightValue.contains("RV1D")) {
			act = "rightArray" + rightValueDimension[rightValueDim] + "=1;\n";
			act = act.concat(OALCodeBuilder("=rightArray"
					+ rightValueIndexValue[rightValueDim] + ";", leftValue,
					leftValueDim));
		}
		// Right side is Attribute array
		else if (rightValue.contains("RV2D")) {

			if (rightValue.contains("D1")) {
				act = act
						.concat("create object instance rightValuetest of A_AO;\n");
			} else if (rightValue.contains("D3")) {
				act = act
						.concat("create object instance rightValuetest of A_AH;\n");
			} else {
				act = act
						.concat("create object instance rightValuetest of A_AT;\n");
			}
			act = act.concat(OALCodeBuilder("=rightValuetest.array"
					+ rightValueIndexValue[rightValueDim] + ";", leftValue,
					leftValueDim));
		}
		// right side is Function/Operation/Bridge/Interface Operation parameter
		else if (rightValue.contains("RV3D") || rightValue.contains("RV4D")
				|| rightValue.contains("RV5D") || rightValue.contains("RV6D")) {

			if (rightValue.contains("D1")) {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test1;
			} else if (rightValue.contains("D3")) {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test3;
			} else {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test2;
			}

			act = "\n";
			if ((leftValue.contains("LV10D")) || (leftValue.contains("LV9D"))
					|| (leftValue.contains("LV8D"))
					|| (leftValue.contains("LV11D")))
				if (rightValue.contains("D1")) {
					act = act.concat(OALCodeBuilder("=param.array1"
							+ rightValueIndexValue[rightValueDim] + ";",
							leftValue, leftValueDim));
				} else if (rightValue.contains("D3")) {
					act = act.concat(OALCodeBuilder("=param.array7"
							+ rightValueIndexValue[rightValueDim] + ";",
							leftValue, leftValueDim));
				} else {
					act = act.concat(OALCodeBuilder("=param.array4"
							+ rightValueIndexValue[rightValueDim] + ";",
							leftValue, leftValueDim));
				}

			else
				act = act.concat(OALCodeBuilder("=param.array"
						+ rightValueIndexValue[rightValueDim] + ";", leftValue,
						leftValueDim));

		}
		// right side is event parameter
		else if (rightValue.contains("RV7D")) {

			if (rightValue.contains("D1")) {
				activity_name = ArrayBaseTest.State_StateOne;
			} else if (rightValue.contains("D3")) {
				activity_name = ArrayBaseTest.State_StateThree;
			} else {
				activity_name = ArrayBaseTest.State_StateTwo;
			}
			act = "\n";
			act = act.concat(OALCodeBuilder("=param.array"
					+ rightValueIndexValue[rightValueDim] + ";", leftValue,
					leftValueDim));
			act = act.replace("voidParamRefIntSFtTest", "voidParamIntSFtTest");

		}
		// right side is function/operation/birdge/interface operation return
		// value
		else if (rightValue.contains("RV8D") || rightValue.contains("RV9D")
				|| rightValue.contains("RV10D") || rightValue.contains("RV11D")) {

			act = "\n";
			String temp = "";
			if (rightValue.contains("RV8D")) {
				temp = "=A_T";
			} else if (rightValue.contains("RV10")) {
				temp = "=T";
			} else if (rightValue.contains("RV11")) {
				temp = "=Port2";
			} else {
				temp = "=";
			}

			// call the Function/Operation/Bridge/Property based on dimension
			// number
			if (rightValue.contains("D1")) {
				act = act.concat(OALCodeBuilder(temp
						+ " ::intSFNoParamTest1();", leftValue, leftValueDim));
			} else if (rightValue.contains("D2")) {
				act = act.concat(OALCodeBuilder(temp
						+ " ::intSFNoParamTest2();", leftValue, leftValueDim));
			} else if (rightValue.contains("D3")) {
				act = act.concat(OALCodeBuilder(temp
						+ " ::intSFNoParamTest3();", leftValue, leftValueDim));
			}
			act = act.replace("voidParamRefIntSFtTest", "voidParamIntSFtTest");

		}

		// Action
		result = ArrayBaseTest.parseAction(act, activity_type, activity_name);
		return result;
	}

	String OALCodeBuilder(String rightValue, String leftValue, int leftValueDim) {

		String act = "";
		if (leftValue.contains("LV1D")) { // Variable Array

			act = act.concat("array" + leftValueDimension[leftValueDim]
					+ "=1;\n");
			act = act.concat("array" + leftValueIndexValue[leftValueDim]
					+ rightValue);

		} else if (leftValue.contains("LV2D")) { // Attribute Array

			if (leftValue.contains("D1")) {
				act = act.concat("create object instance test of A_AO;\ntest.");
			} else if (leftValue.contains("D3")) {
				act = act.concat("create object instance test of A_AH;\ntest.");
			} else {
				act = act.concat("create object instance test of A_AT;\ntest.");
			}
			act = act.concat("array" + leftValueIndexValue[leftValueDim]
					+ rightValue);
		}

		else if (leftValue.contains("LV3D") || leftValue.contains("LV4D")
				|| leftValue.contains("LV6D")) { // Function/Bridge/Operation
													// parameter

			act = act.concat("\n");
			act = act.concat("param.array" + leftValueIndexValue[leftValueDim]
					+ rightValue);
			if (leftValue.contains("D1")) {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test1;
			} else if (leftValue.contains("D3")) {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test3;
			} else {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test2;
			}
		} else if (leftValue.contains("LV7D")) { // Event Parameter

			act = act.concat("create object instance test of A_AO;\n");
			if (leftValue.contains("D1")) {
				act = act.concat("generate A_AO1:oneParamInt_SF_test1(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ")to test;");
			} else if (leftValue.contains("D2")) {
				act = act.concat("generate A_AO2:oneParamInt_SF_test2(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ")to test;");
			} else if (leftValue.contains("D3")) {
				act = act.concat("generate A_AO3:oneParamInt_SF_test3(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ")to test;");
			}

		} else if (leftValue.contains("LV8D") || leftValue.contains("LV9D")
				|| leftValue.contains("LV10") || leftValue.contains("LV11")) { // Function/Bridge/Operation/InterfaceOperation
			// return
			// value

			if (leftValue.contains("D1")) {
				activity_name = ArrayBaseTest.int_SF_Param_test1;
			} else if (leftValue.contains("D2")) {
				activity_name = ArrayBaseTest.int_SF_Param_test2;
			} else if (leftValue.contains("D3")) {
				activity_name = ArrayBaseTest.int_SF_Param_test3;
			}
			act = act.concat("\n");
			act = act.concat("return "
					+ rightValue.substring(1, rightValue.length()));
		} else if (leftValue.contains("LV12") || leftValue.contains("LV13")
				|| leftValue.contains("LV15")) { // Function/Bridge/Operation
													// argument

			// Set the prefix before call if need ( only function does not need
			// )
			act = act.concat("\n");
			if (leftValue.contains("LV12")) {
				act = act.concat("A_T");
			} else if (leftValue.contains("LV15")) {
				act = act.concat("T");
			}

			// call the Function/Operation/Bridge/Property based on dimension
			// number
			if (leftValue.contains("D1")) {
				act = act.concat("::voidParamRefIntSFtTest1(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ");");
			} else if (leftValue.contains("D2")) {
				act = act.concat("::voidParamRefIntSFtTest2(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ");");
			} else if (leftValue.contains("D3")) {
				act = act.concat("::voidParamRefIntSFtTest3(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ");");
			}

		} else if (leftValue.contains("LV5")) {
			act = act.concat("\n");
			act = act.concat("param.array" + leftValueIndexValue[leftValueDim]
					+ rightValue);
			if (leftValue.contains("D1")) {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test1;
			} else if (leftValue.contains("D3")) {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test3;
			} else {
				activity_name = ArrayBaseTest.void_paramRef_int_SF_test2;
			}

			// } else if (leftValue.contains("LV11")) {
			//			
			// if (leftValue.contains("D1")){
			// activity_name = ArrayBaseTest.int_SF_Param_test1 ;
			// }
			// else if (leftValue.contains("D2")){
			// activity_name = ArrayBaseTest.int_SF_Param_test2;
			// }
			// else if (leftValue.contains("D3")){
			// activity_name = ArrayBaseTest.int_SF_Param_test3;
			// }
			// act = act.concat("\n");
			// act = act.concat("return "+rightValue.substring(1,
			// rightValue.length()));

		} else if (leftValue.contains("LV14")) {

			act = act.concat("\n");
			if (leftValue.contains("D1")) {
				act = act.concat("Port2::voidParamRefIntSFtTest1(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ");");
			} else if (leftValue.contains("D2")) {
				act = act.concat("Port2::voidParamRefIntSFtTest2(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ");");
			} else if (leftValue.contains("D3")) {
				act = act.concat("Port2::voidParamRefIntSFtTest3(array:"
						+ rightValue.substring(1, rightValue.length() - 1)
						+ ");");
			}
		}

		return act;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_Failure1(String source, String destination,
			String result) {
		boolean Failure1 = false;
		// TODO: Implement
		return !Failure1;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_Failure2(String source, String destination,
			String result) {
		boolean Failure2 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d+: (Variable|Attribute) ->array<- has incompatible ((array depth)|(dimension size with the rvalue)).\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		Failure2 = match.matches();
		return Failure2;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_Failure3(String source, String destination,
			String result) {
		boolean Failure3 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d+: (Variable|Attribute) ->array<- contains an Array Index Out of Bounds.\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		Failure3 = match.matches();
		return Failure3;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ParamFailure3(String source, String destination,
			String result) {
		boolean ParamFailure3 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d+: Parameter (->array<- )?contains an Array Index Out of Bounds.\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ParamFailure3 = match.matches();
		return ParamFailure3;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ReturnFailure4(String source, String destination,
			String result) {
		boolean ReturnFailure4 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d+: Return type has an incompatible array length for dimension 0.\nline 3:\\d+: expecting Semicolon, found 'null'\n:3:\\d+-\\d+: Return value required by ((class|interface) operation|function|bridge)\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ReturnFailure4 = match.matches();
		return ReturnFailure4;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ReturnFailureBridge4(String source, String destination,
			String result) {
		boolean ReturnFailureBridge4 = false;
		Pattern resultPatten = Pattern
		.compile(":3:\\d+-\\d+: Return type has an incompatible array length for dimension 0.\nline 3:\\d+: expecting Semicolon, found 'null'\n:3:\\d+-\\d+: Return value required by bridge\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ReturnFailureBridge4 = match.matches();
		return ReturnFailureBridge4;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ParamFailure4(String source, String destination,
			String result) {
		boolean ParamFailure4 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d+: Parameter (->array<- )?has an incompatible array length for dimension 0.\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ParamFailure4 = match.matches();
		return ParamFailure4;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_Failure4(String source, String destination,
			String result) {
		boolean Failure4 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d+: (Variable|Attribute) ->array<- has an incompatible array length for dimension 0.\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		Failure4 = match.matches();
		return Failure4;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ReturnFailure2(String source, String destination,
			String result) {
		boolean ReturnFailure2 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d+: Return type has incompatible array depth.\nline 3:\\d+: expecting Semicolon, found 'null'\n:3:\\d+-\\d+: Return value required by ((class|interface) operation|function|bridge)\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ReturnFailure2 = match.matches();
		return ReturnFailure2;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ReturnFailureBridge2(String source, String destination,
			String result) {
		boolean ReturnFailureBridge2 = false;
		Pattern resultPatten = Pattern
		.compile(":3:\\d+-\\d+: Return type has incompatible array depth.\nline 3:\\d+: expecting Semicolon, found 'null'\n:3:\\d+-\\d+: Return value required by bridge\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ReturnFailureBridge2 = match.matches();
		return ReturnFailureBridge2;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_Failure5(String source, String destination,
			String result) {
		boolean Failure5 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d+: Negative Array Index value is not allowed.\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		Failure5 = match.matches();
		return Failure5;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ReturnFailure1(String source, String destination,
			String result) {
		boolean ReturnFailure1 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d*: Invalid data type returned for operation.\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ReturnFailure1 = match.matches();
		return ReturnFailure1;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_Failure6(String source, String destination,
			String result) {
		boolean Failure6 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d*: The rvalue contains an Array Index Out of Bounds.\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		Failure6 = match.matches();
		return Failure6;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ParamFailure1(String source, String destination,
			String result) {
		boolean ParamFailure1 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d*: Parameter ->array<- has been assigned value of different type..\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ParamFailure1 = match.matches();
		return ParamFailure1;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_Success(String source, String destination, String result) {
		boolean Success = false;
		if (result.equalsIgnoreCase("")) {
			Success = true;
		}
		return Success;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_Failure7(String source, String destination,
			String result) {
		boolean Failure7 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d*: The rvalue has incompatible array depth.\nline 3:\\d+: expecting Semicolon, found 'null'\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		Failure7 = match.matches();
		return Failure7;
	}

	/**
	 * This function verifies an expected result.
	 * 
	 * @param source
	 *            A model element instance aquired through a action taken on a
	 *            column of the matrix.
	 * @param destination
	 *            A model element instance aquired through a action taken taken
	 *            on a row of the matrix.
	 * @param result
	 *            TODO
	 * @return true if the test succeeds, false if it fails
	 */
	boolean checkResult_ParamFailure2(String source, String destination,
			String result) {
		boolean ParamFailure2 = false;
		Pattern resultPatten = Pattern
				.compile(":3:\\d+-\\d*: Parameter (->array<- )?has incompatible array depth.\n(line 3:\\d+: (unexpected token: null|expecting TOK_RPAREN, found ';')\\n)?line 3:\\d+: (expecting Semicolon, found 'null'|expecting TOK_RPAREN, found 'to')\n");
		java.util.regex.Matcher match = resultPatten.matcher(result);
		ParamFailure2 = match.matches();
		return ParamFailure2;
	}

}
