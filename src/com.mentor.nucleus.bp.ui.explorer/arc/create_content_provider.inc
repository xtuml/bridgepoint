.//=====================================================================
.//
.// File:      $RCSfile: create_content_provider.inc,v $
.// Version:   $Revision: 1.16 $
.// Modified:  $Date: 2013/01/10 23:15:37 $
.//
.// (c) Copyright 2003-2013 Mentor Graphics Corporation All rights reserved.
.//
.//=====================================================================
.// This document contains information proprietary and confidential to
.// Project Technology, Inc. and is not for external distribution.
.//=====================================================================
.//
.// This file is responsible for creating the adapter that decouples the
.// client model objects from the tree viewer by delegating the job of
.// finding a parent of an element or the children of an element to the
.// correct (generated) adapter.
.//
.function create_content_provider
  .param string path
  .//
  .assign provider_name = "ModelContentProvider"
  .assign attr_result = provider_name  
package com.mentor.nucleus.bp.ui.explorer;
//======================================================================
//
// File: ${path}/${provider_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      $$Revision: 1.16 $$
//
// (c) Copyright 2003-2013 Mentor Graphics Corporation  All rights reserved.
//
//======================================================================
//
// This class is an adapter that decouples the client model objects from
// the tree viewer by delegating the job of finding a parent of an element
// or the children of an element to the correct adapter.
//
import java.util.ArrayList;
import java.util.List;

import org.eclipse.jface.viewers.ITreeContentProvider;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import com.mentor.nucleus.bp.core.common.NonRootModelElement;
import com.mentor.nucleus.bp.core.common.ModelElementFileFacade;
import com.mentor.nucleus.bp.core.*;
import com.mentor.nucleus.bp.core.sorter.*;
import com.mentor.nucleus.bp.ui.explorer.adapters.*;

public class ${provider_name} implements ITreeContentProvider {
  protected TreeViewer viewer;
  protected static MetadataSortingManager.ISorter sorter = new AlphaSorter();
  /**
   * @see IContentProvider#dispose()
   */
  public void dispose() {
    // No resources allocated, nothing to dispose.
  }
  /**
   * @see IContentProvider#inputChanged(Viewer, Object, Object)
   */
  /**
   * Notifies this content provider that the given viewer's input
   * has been switched to a different element.
   * <p>
   * A typical use for this method is registering the content provider as a listener
   * to changes on the new input (using model-specific means), and deregistering the viewer
   * from the old input. In response to these change notifications, the content provider
   * propagates the changes to the viewer.
   * </p>
   *
   * @param viewer the viewer
   * @param oldInput the old input element, or <code>null</code> if the viewer
   *   did not previously have an input
   * @param newInput the new input element, or <code>null</code> if the viewer
   *   does not have an input
   */
  public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
    // Singleton model, nothing to do
  }
  .select many tree_nodes from instances of T_TNS
  /**
   * @see ITreeContentProvider#getChildren(Object)
   */
  public Object[] getChildren(Object parentElement) {
  	if(parentElement instanceof MultipleOccurrenceElement) {
		parentElement = ((MultipleOccurrenceElement) parentElement).getElement();
	}
    if (parentElement instanceof Ooaofooa) {
      return RootAdapter.getInstance().getChildren(parentElement);
    }
  .for each node in tree_nodes
    .select any node_class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke result = get_class_name(node_class)
    if (parentElement instanceof ${result.body}) {
      return $Cr{node.CategoryName}Adapter.getInstance().getChildren(parentElement);
    }
  .end for
    return null;
  }
  /**
   * @see ITreeContentProvider#getParent(Object)
   */
  public Object getParent(Object element) {
  	if(element instanceof MultipleOccurrenceElement) {
		element = ((MultipleOccurrenceElement) element).getElement();
	}
    if (element instanceof Ooaofooa) {
      return RootAdapter.getInstance().getParent(element);
    }
  .for each node in tree_nodes
    .select any node_class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke result = get_class_name(node_class)
    if (element instanceof ${result.body}) {
      return $Cr{node.CategoryName}Adapter.getInstance().getParent(element);
    }
  .end for
     if (element instanceof ModelElementFileFacade) {
      return ((ModelElementFileFacade)element).getModelElement();
     }
    return null;
  }
  /**
   * @see ITreeContentProvider#hasChildren(Object)
   */
  public boolean hasChildren(Object element) {
	if(element instanceof MultipleOccurrenceElement) {
		element = ((MultipleOccurrenceElement) element).getElement();
	}
    if (element instanceof Ooaofooa) {
      return RootAdapter.getInstance().hasChildren(element);
    }
  .for each node in tree_nodes
    .select any node_class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke result = get_class_name(node_class)
     if (element instanceof ${result.body}) {
     .invoke is_compRoot = is_componentRootElementKL(node.Key_Lett)
    .if(is_compRoot.result)
     if(((NonRootModelElement)element).getFile()!=null){
        .//determin do we have to display tree item represening file 
       if(((NonRootModelElement)element).getFile().exists())
           return true;
       }
     .end if
     return $Cr{node.CategoryName}Adapter.getInstance().hasChildren(element);
     }
  .end for
    // Unknown element
    return false;
  }
  /**
   * @see IStructuredContentProvider#getElements(Object)
   */
  public Object[] getElements(Object inputElement) {
    return getChildren(inputElement);
  }
	
  public static void sort(Object[] elements){
    sorter.sort(elements);
  }  
}
.end function
