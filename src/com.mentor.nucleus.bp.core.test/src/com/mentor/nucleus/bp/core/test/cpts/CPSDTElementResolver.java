//=====================================================================
//
//File:      $RCSfile$
//Version:   $Revision$
//Modified:  $Date$
//
// NOTE: This file was generated, but is maintained by hand.
// Generated by: $RCSfile$
// Version:      $Revision$
//
//(c) Copyright 2007-2014 by Mentor Graphics Corp. All rights reserved.
//
//=====================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License.  You may obtain a copy 
// of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the 
// License for the specific language governing permissions and limitations under
// the License.
//=====================================================================
package com.mentor.nucleus.bp.core.test.cpts;

import java.util.Iterator;

import org.eclipse.core.runtime.Path;

import com.mentor.nucleus.bp.core.ClassStateMachine_c;
import com.mentor.nucleus.bp.core.Domain_c;
import com.mentor.nucleus.bp.core.InstanceStateMachine_c;
import com.mentor.nucleus.bp.core.ModelClass_c;
import com.mentor.nucleus.bp.core.Ooaofooa;
import com.mentor.nucleus.bp.core.StateMachineEvent_c;
import com.mentor.nucleus.bp.core.SubsystemInSubsystem_c;
import com.mentor.nucleus.bp.core.Subsystem_c;
import com.mentor.nucleus.bp.core.SystemModel_c;
import com.mentor.nucleus.bp.core.common.ClassQueryInterface_c;
import com.mentor.nucleus.bp.core.common.InstanceList;
import com.mentor.nucleus.bp.core.common.NonRootModelElement;
import com.mentor.nucleus.bp.core.common.PersistenceManager;
import com.mentor.nucleus.bp.core.inspector.IModelClassInspector;
import com.mentor.nucleus.bp.core.inspector.ModelInspector;
import com.mentor.nucleus.bp.ui.explorer.ModelContentProvider;

public class CPSDTElementResolver {

	public static boolean full_run = false;
	
	public static class ParentChildContainer {
		public Class<?> fParent;

		public Class<?> fChild;

		public String fParentKeyLetters;
		
		public String fChildKeyLetters;
		
		public ParentChildContainer(Class<?> parent, Class<?> child, String parent_key_letters, String child_key_letters) {
			fParent = parent;
			fChild = child;
			fParentKeyLetters = parent_key_letters;
			fChildKeyLetters = child_key_letters;
		}
	}

	public static String getElementName(String name, boolean source) {
		ParentChildContainer pcContainer = getParentChildContainer(name);
		Class<?> child_class = pcContainer.fChild;

		String elementType = "";
		if (source)
			elementType = "source";
		else
			elementType = "destination";

		// the name of the element in
		// the test model
		// e.g, source_ComponentPackage_c
		if(child_class == InstanceStateMachine_c.class) {
			return "Instance State Machine";
		} else if (child_class == ClassStateMachine_c.class) {
			return "Class State Machine";			
		}
		return elementType + "_" + child_class.getSimpleName();
	}
	
	private static ParentChildContainer getParentChildContainer(String name) {
		if(!full_run) {
			return CPSDTParentChildResolver
					.getParentChildContainer(name);
		} else {
			return com.mentor.nucleus.bp.core.test.cpts_full.CPSDTParentChildResolver
					.getParentChildContainer(name);
		}
	}

	public static NonRootModelElement getElement(String name,
			SystemModel_c testSystem, boolean source, boolean falseDestination,
			NonRootModelElement sourceElement) {
		Class<?> parent_class = null;
		Class<?> child_class = null;
		ParentChildContainer pcContainer = getParentChildContainer(name);
		parent_class = pcContainer.fParent;
		child_class = pcContainer.fChild;

		String elementType = "";
		if (source)
			elementType = "source";
		else
			elementType = "destination";

		name = getElementName(name, source);
		
		final String finalName = name;

		if (child_class == SystemModel_c.class) {
			SystemModel_c system = SystemModel_c.SystemModelInstance(Ooaofooa
					.getDefaultInstance(), new ClassQueryInterface_c() {

				public boolean evaluate(Object candidate) {
					return ((SystemModel_c) candidate).getName().equals(
							finalName);
				}

			});
			return system;
		} else {
			Ooaofooa[] roots = Ooaofooa.getInstances();
			for (int i = 0; i < roots.length; i++) {
				if (Path.fromPortableString(roots[i].getId()).segment(0)
						.toString().equals(testSystem.getName())) {
					// found a model-root that is under this test system
					InstanceList list = roots[i].getInstanceList(child_class);
					Iterator<NonRootModelElement> elements = list
							.iterator();
					while (elements.hasNext()) {
						NonRootModelElement current = elements
								.next();
						boolean match = current.getName().equalsIgnoreCase(name);
						if(current instanceof StateMachineEvent_c) {
							match = ((StateMachineEvent_c) current).getMning().equalsIgnoreCase(name);
						}
						// if the element is not a file root, we need to find the
						// correct destination for compare purposes
						// such a destination is named destination_DestinationClassName_c_ChildClassName_c
				   		if (!PersistenceManager.getHierarchyMetaData().isComponentRoot(
				   				sourceElement) && !falseDestination) {
				   			if(!source) {
								if (current.getName().equals(
										name
												+ "_"
												+ sourceElement.getName()
														.replaceAll("source_",
																"").replaceAll(
																"_c.*", "_c"))) {
					   				match = true;
					   			} else {
					   				match = false;
					   			}
				   			} else {
				   				// use startsWith, as some elements use a label that will have other
				   				// data at the end
				   				if(current.getName().equals(name + "_dup")) {
				   					match = false;
				   				} else {
				   					if(current.getName().startsWith(name)) {
				   						match = true;
				   					}
				   				}
				   			}
				   		}
						if(current instanceof InstanceStateMachine_c) {
							// only match if the parent class is the
							// one expected, it will be named 
							// destination_InstanceStateMachine_c
							ModelInspector inspector = new ModelInspector();
							IModelClassInspector classInspector = inspector
									.getInspector(child_class);
							NonRootModelElement temp_parent = (NonRootModelElement) classInspector
									.getParent(current);
							if(temp_parent.getName().equals("destination_InstanceStateMachine_c")) {
								match = true;
							}
						}
						if(current instanceof ClassStateMachine_c) {
							// only match if the parent class is the
							// one expected, it will be named 
							// destination_ClassStateMachine_c
							ModelInspector inspector = new ModelInspector();
							IModelClassInspector classInspector = inspector
									.getInspector(child_class);
							NonRootModelElement temp_parent = (NonRootModelElement) classInspector
									.getParent(current);
							if(temp_parent.getName().equals("destination_ClassStateMachine_c")) {
								match = true;
							}							
						}
						if ((match || falseDestination) && current.getClass() == child_class) {
							// see that the parent of this element is
							// what is expected
							// if the child class and parent class
							// are Subsystem_c then we need a special
							// case check for the subsystem parent as
							// the generated inspector will always
							// return the domain
							Object parent = null;
							if (child_class == Subsystem_c.class
									&& parent_class == Subsystem_c.class) {
								Subsystem_c subsystemParent = Subsystem_c
										.getOneS_SSOnR41(SubsystemInSubsystem_c
												.getOneS_SISOnR42((Subsystem_c) current));
								if(subsystemParent == null) continue;
								parent = subsystemParent;
							} else {
								if(child_class == Subsystem_c.class
										&& parent_class == Domain_c.class) { 
									Subsystem_c subsystemParent = Subsystem_c
										.getOneS_SSOnR41(SubsystemInSubsystem_c
											.getOneS_SISOnR42((Subsystem_c) current));
									if(subsystemParent != null) {
										continue;
									}
								}
								ModelInspector inspector = new ModelInspector();
								IModelClassInspector classInspector = inspector
										.getInspector(child_class);
								parent = classInspector.getParent(current);
								if(parent == null) {
									// this is something that is left out of
									// the hierarchy metadata, try the explorer
									// hierarchy data
									ModelContentProvider provider = new ModelContentProvider();
									parent = provider.getParent(current);
								}
							}
							if (parent != null && parent.getClass() == parent_class) {
								NonRootModelElement parentModelElement = (NonRootModelElement) parent;
								// we need a special case for ISM and ASM destinations
								// we need to check the class name
								if(parentModelElement instanceof InstanceStateMachine_c) {
									ModelClass_c clazz = ModelClass_c
											.getOneO_OBJOnR518((InstanceStateMachine_c) parentModelElement);
									if(source && clazz.getName().indexOf("destination") != -1) {
										continue;
									}
								} else if(parentModelElement instanceof ClassStateMachine_c) {
									ModelClass_c clazz = ModelClass_c
											.getOneO_OBJOnR519((ClassStateMachine_c) parentModelElement);
									if(source && clazz.getName().indexOf("destination") != -1) {
										continue;
									}
								} else {
									// if we are looking for a source do not
									// return the element with the same name in
									// the destination container
									if (source && parentModelElement.getName().indexOf(
											"destination") != -1)
										continue;
								}
								return current;
							}
						}
					}
				}
			}
		}

		CopyPasteSourceDestinationTests.selectionFailure = "Unable to find "
				+ elementType
				+ " element.  Make sure the test model contains\nthe test element with the following properties: \n"
				+ "  Element name: " + name + "\n  Element Container: "
				+ parent_class.getSimpleName();

		return null;
	}

}
