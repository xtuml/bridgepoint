/*
 * generated by Xtext 2.9.1
 */
package org.xtuml.bp.ui.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtuml.bp.ui.xtext.myDsl.MyDslPackage;
import org.xtuml.bp.ui.xtext.myDsl.additiveExp;
import org.xtuml.bp.ui.xtext.myDsl.argumentList;
import org.xtuml.bp.ui.xtext.myDsl.arrayBounds;
import org.xtuml.bp.ui.xtext.myDsl.assignStatement;
import org.xtuml.bp.ui.xtext.myDsl.callStatement;
import org.xtuml.bp.ui.xtext.myDsl.choiceList;
import org.xtuml.bp.ui.xtext.myDsl.codeBlock;
import org.xtuml.bp.ui.xtext.myDsl.codeBlockStatement;
import org.xtuml.bp.ui.xtext.myDsl.collectionTypeRef;
import org.xtuml.bp.ui.xtext.myDsl.createArgument;
import org.xtuml.bp.ui.xtext.myDsl.createArgumentList;
import org.xtuml.bp.ui.xtext.myDsl.dictKeyType;
import org.xtuml.bp.ui.xtext.myDsl.dictValueType;
import org.xtuml.bp.ui.xtext.myDsl.domainFunctionDefinition;
import org.xtuml.bp.ui.xtext.myDsl.domainServiceDefinition;
import org.xtuml.bp.ui.xtext.myDsl.elsifBlock;
import org.xtuml.bp.ui.xtext.myDsl.equality;
import org.xtuml.bp.ui.xtext.myDsl.exitStatement;
import org.xtuml.bp.ui.xtext.myDsl.expression;
import org.xtuml.bp.ui.xtext.myDsl.findComparison;
import org.xtuml.bp.ui.xtext.myDsl.findCondition;
import org.xtuml.bp.ui.xtext.myDsl.findExpression;
import org.xtuml.bp.ui.xtext.myDsl.findLogicalAnd;
import org.xtuml.bp.ui.xtext.myDsl.findLogicalOr;
import org.xtuml.bp.ui.xtext.myDsl.findLogicalXor;
import org.xtuml.bp.ui.xtext.myDsl.findName;
import org.xtuml.bp.ui.xtext.myDsl.ifStatement;
import org.xtuml.bp.ui.xtext.myDsl.linkExpression;
import org.xtuml.bp.ui.xtext.myDsl.linkStatement;
import org.xtuml.bp.ui.xtext.myDsl.logicalAnd;
import org.xtuml.bp.ui.xtext.myDsl.logicalOr;
import org.xtuml.bp.ui.xtext.myDsl.logicalXor;
import org.xtuml.bp.ui.xtext.myDsl.multExp;
import org.xtuml.bp.ui.xtext.myDsl.navigateExpression;
import org.xtuml.bp.ui.xtext.myDsl.objectFunctionDefinition;
import org.xtuml.bp.ui.xtext.myDsl.objectServiceDefinition;
import org.xtuml.bp.ui.xtext.myDsl.parameterList;
import org.xtuml.bp.ui.xtext.myDsl.parenthesisedExpression;
import org.xtuml.bp.ui.xtext.myDsl.postfixExpression;
import org.xtuml.bp.ui.xtext.myDsl.postfixNoCallExpression;
import org.xtuml.bp.ui.xtext.myDsl.primaryExpression;
import org.xtuml.bp.ui.xtext.myDsl.rangeExpression;
import org.xtuml.bp.ui.xtext.myDsl.relationalExp;
import org.xtuml.bp.ui.xtext.myDsl.relationshipSpec;
import org.xtuml.bp.ui.xtext.myDsl.serviceVisibility;
import org.xtuml.bp.ui.xtext.myDsl.stateDefinition;
import org.xtuml.bp.ui.xtext.myDsl.stateType;
import org.xtuml.bp.ui.xtext.myDsl.statement;
import org.xtuml.bp.ui.xtext.myDsl.statementList;
import org.xtuml.bp.ui.xtext.myDsl.streamStatement;
import org.xtuml.bp.ui.xtext.myDsl.terminatorFunctionDefinition;
import org.xtuml.bp.ui.xtext.myDsl.terminatorServiceDefinition;
import org.xtuml.bp.ui.xtext.myDsl.typeNameExpression;
import org.xtuml.bp.ui.xtext.myDsl.typeReference;
import org.xtuml.bp.ui.xtext.myDsl.variableDeclaration;
import org.xtuml.bp.ui.xtext.myDsl.whereClause;
import org.xtuml.bp.ui.xtext.myDsl.whileStatement;
import org.xtuml.bp.ui.xtext.services.MASLGrammarAccess;

@SuppressWarnings("all")
public class MASLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MASLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ADDITIVE_EXP:
				sequence_additiveExp(context, (additiveExp) semanticObject); 
				return; 
			case MyDslPackage.ARGUMENT_LIST:
				if (rule == grammarAccess.getArgumentListRule()) {
					sequence_argumentList(context, (argumentList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGenerateStatementRule()) {
					sequence_argumentList_generateStatement(context, (argumentList) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.ARRAY_BOUNDS:
				sequence_arrayBounds(context, (arrayBounds) semanticObject); 
				return; 
			case MyDslPackage.ASSIGN_STATEMENT:
				sequence_assignStatement(context, (assignStatement) semanticObject); 
				return; 
			case MyDslPackage.CALL_STATEMENT:
				sequence_callStatement(context, (callStatement) semanticObject); 
				return; 
			case MyDslPackage.CHOICE_LIST:
				if (rule == grammarAccess.getCaseAlternativeRule()) {
					sequence_caseAlternative_choiceList(context, (choiceList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getChoiceListRule()) {
					sequence_choiceList(context, (choiceList) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.CODE_BLOCK:
				sequence_codeBlock(context, (codeBlock) semanticObject); 
				return; 
			case MyDslPackage.CODE_BLOCK_STATEMENT:
				sequence_codeBlockStatement(context, (codeBlockStatement) semanticObject); 
				return; 
			case MyDslPackage.COLLECTION_TYPE_REF:
				sequence_collectionTypeRef_dictKeyType(context, (collectionTypeRef) semanticObject); 
				return; 
			case MyDslPackage.CREATE_ARGUMENT:
				sequence_createArgument(context, (createArgument) semanticObject); 
				return; 
			case MyDslPackage.CREATE_ARGUMENT_LIST:
				sequence_createArgumentList(context, (createArgumentList) semanticObject); 
				return; 
			case MyDslPackage.DICT_KEY_TYPE:
				sequence_dictKeyType(context, (dictKeyType) semanticObject); 
				return; 
			case MyDslPackage.DICT_VALUE_TYPE:
				sequence_dictValueType(context, (dictValueType) semanticObject); 
				return; 
			case MyDslPackage.DOMAIN_FUNCTION_DEFINITION:
				sequence_domainFunctionDefinition(context, (domainFunctionDefinition) semanticObject); 
				return; 
			case MyDslPackage.DOMAIN_SERVICE_DEFINITION:
				sequence_domainServiceDefinition(context, (domainServiceDefinition) semanticObject); 
				return; 
			case MyDslPackage.ELSIF_BLOCK:
				sequence_elsifBlock(context, (elsifBlock) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY:
				sequence_equality(context, (equality) semanticObject); 
				return; 
			case MyDslPackage.EXIT_STATEMENT:
				sequence_exitStatement(context, (exitStatement) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				if (rule == grammarAccess.getCaseStatementRule()) {
					sequence_caseStatement_expression(context, (expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStreamValueRule()
						|| rule == grammarAccess.getReturnStatementRule()
						|| rule == grammarAccess.getDelayStatementRule()
						|| rule == grammarAccess.getDeleteStatementRule()
						|| rule == grammarAccess.getEraseStatementRule()
						|| rule == grammarAccess.getCancelTimerStatementRule()
						|| rule == grammarAccess.getConditionRule()
						|| rule == grammarAccess.getLoopVariableSpecRule()
						|| rule == grammarAccess.getExpressionRule()) {
					sequence_expression(context, (expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForStatementRule()) {
					sequence_expression_forStatement(context, (expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getScheduleStatementRule()) {
					sequence_expression_scheduleStatement(context, (expression) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.FIND_COMPARISON:
				sequence_findComparison(context, (findComparison) semanticObject); 
				return; 
			case MyDslPackage.FIND_CONDITION:
				sequence_findCondition(context, (findCondition) semanticObject); 
				return; 
			case MyDslPackage.FIND_EXPRESSION:
				sequence_findExpression(context, (findExpression) semanticObject); 
				return; 
			case MyDslPackage.FIND_LOGICAL_AND:
				sequence_findLogicalAnd(context, (findLogicalAnd) semanticObject); 
				return; 
			case MyDslPackage.FIND_LOGICAL_OR:
				sequence_findLogicalOr(context, (findLogicalOr) semanticObject); 
				return; 
			case MyDslPackage.FIND_LOGICAL_XOR:
				sequence_findLogicalXor(context, (findLogicalXor) semanticObject); 
				return; 
			case MyDslPackage.FIND_NAME:
				sequence_findName(context, (findName) semanticObject); 
				return; 
			case MyDslPackage.IF_STATEMENT:
				sequence_ifStatement(context, (ifStatement) semanticObject); 
				return; 
			case MyDslPackage.LINK_EXPRESSION:
				sequence_linkExpression(context, (linkExpression) semanticObject); 
				return; 
			case MyDslPackage.LINK_STATEMENT:
				sequence_linkStatement(context, (linkStatement) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_AND:
				sequence_logicalAnd(context, (logicalAnd) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_OR:
				sequence_logicalOr(context, (logicalOr) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_XOR:
				sequence_logicalXor(context, (logicalXor) semanticObject); 
				return; 
			case MyDslPackage.MULT_EXP:
				sequence_multExp(context, (multExp) semanticObject); 
				return; 
			case MyDslPackage.NAVIGATE_EXPRESSION:
				sequence_navigateExpression(context, (navigateExpression) semanticObject); 
				return; 
			case MyDslPackage.OBJECT_FUNCTION_DEFINITION:
				sequence_objectFunctionDefinition(context, (objectFunctionDefinition) semanticObject); 
				return; 
			case MyDslPackage.OBJECT_SERVICE_DEFINITION:
				sequence_objectServiceDefinition(context, (objectServiceDefinition) semanticObject); 
				return; 
			case MyDslPackage.PARAMETER_LIST:
				sequence_parameterList(context, (parameterList) semanticObject); 
				return; 
			case MyDslPackage.PARENTHESISED_EXPRESSION:
				sequence_parenthesisedExpression(context, (parenthesisedExpression) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_EXPRESSION:
				sequence_postfixExpression(context, (postfixExpression) semanticObject); 
				return; 
			case MyDslPackage.POSTFIX_NO_CALL_EXPRESSION:
				sequence_postfixNoCallExpression(context, (postfixNoCallExpression) semanticObject); 
				return; 
			case MyDslPackage.PRIMARY_EXPRESSION:
				sequence_primaryExpression(context, (primaryExpression) semanticObject); 
				return; 
			case MyDslPackage.RANGE_EXPRESSION:
				sequence_rangeExpression(context, (rangeExpression) semanticObject); 
				return; 
			case MyDslPackage.RELATIONAL_EXP:
				sequence_relationalExp(context, (relationalExp) semanticObject); 
				return; 
			case MyDslPackage.RELATIONSHIP_SPEC:
				sequence_relationshipSpec(context, (relationshipSpec) semanticObject); 
				return; 
			case MyDslPackage.SERVICE_VISIBILITY:
				sequence_serviceVisibility(context, (serviceVisibility) semanticObject); 
				return; 
			case MyDslPackage.STATE_DEFINITION:
				sequence_stateDefinition(context, (stateDefinition) semanticObject); 
				return; 
			case MyDslPackage.STATE_TYPE:
				sequence_stateType(context, (stateType) semanticObject); 
				return; 
			case MyDslPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case MyDslPackage.STATEMENT_LIST:
				sequence_statementList(context, (statementList) semanticObject); 
				return; 
			case MyDslPackage.STREAM_STATEMENT:
				sequence_streamStatement(context, (streamStatement) semanticObject); 
				return; 
			case MyDslPackage.TERMINATOR_FUNCTION_DEFINITION:
				sequence_terminatorFunctionDefinition(context, (terminatorFunctionDefinition) semanticObject); 
				return; 
			case MyDslPackage.TERMINATOR_SERVICE_DEFINITION:
				sequence_terminatorServiceDefinition(context, (terminatorServiceDefinition) semanticObject); 
				return; 
			case MyDslPackage.TYPE_NAME_EXPRESSION:
				sequence_typeNameExpression(context, (typeNameExpression) semanticObject); 
				return; 
			case MyDslPackage.TYPE_REFERENCE:
				sequence_typeReference(context, (typeReference) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_DECLARATION:
				sequence_variableDeclaration(context, (variableDeclaration) semanticObject); 
				return; 
			case MyDslPackage.WHERE_CLAUSE:
				sequence_findCondition_whereClause(context, (whereClause) semanticObject); 
				return; 
			case MyDslPackage.WHILE_STATEMENT:
				sequence_whileStatement(context, (whileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     additiveExp returns additiveExp
	 *
	 * Constraint:
	 *     (m+=multExp m+=multExp*)
	 */
	protected void sequence_additiveExp(ISerializationContext context, additiveExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     argumentList returns argumentList
	 *
	 * Constraint:
	 *     (e1+=expression e1+=expression*)?
	 */
	protected void sequence_argumentList(ISerializationContext context, argumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     generateStatement returns argumentList
	 *
	 * Constraint:
	 *     ((e1+=expression e1+=expression*)? e=expression?)
	 */
	protected void sequence_argumentList_generateStatement(ISerializationContext context, argumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeReferenceWithCA returns arrayBounds
	 *     constrainedArrayTypeRef returns arrayBounds
	 *     arrayBounds returns arrayBounds
	 *
	 * Constraint:
	 *     e=expression
	 */
	protected void sequence_arrayBounds(ISerializationContext context, arrayBounds semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARRAY_BOUNDS__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARRAY_BOUNDS__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayBoundsAccess().getEExpressionParserRuleCall_1_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     assignStatement returns assignStatement
	 *
	 * Constraint:
	 *     (lhs=expression rhs=expression)
	 */
	protected void sequence_assignStatement(ISerializationContext context, assignStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ASSIGN_STATEMENT__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ASSIGN_STATEMENT__LHS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ASSIGN_STATEMENT__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ASSIGN_STATEMENT__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignStatementAccess().getLhsExpressionParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAssignStatementAccess().getRhsExpressionParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     callStatement returns callStatement
	 *
	 * Constraint:
	 *     (p=primaryExpression ((e+=expression | c+=characteristic)* a+=argumentList)+)
	 */
	protected void sequence_callStatement(ISerializationContext context, callStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     caseAlternative returns choiceList
	 *
	 * Constraint:
	 *     (e+=expression e+=expression* s=statementList)
	 */
	protected void sequence_caseAlternative_choiceList(ISerializationContext context, choiceList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     caseStatement returns expression
	 *
	 * Constraint:
	 *     (r=rangeExpression c1+=caseAlternative* c2=caseOthers?)
	 */
	protected void sequence_caseStatement_expression(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     choiceList returns choiceList
	 *
	 * Constraint:
	 *     (e+=expression e+=expression*)
	 */
	protected void sequence_choiceList(ISerializationContext context, choiceList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     codeBlockStatement returns codeBlockStatement
	 *
	 * Constraint:
	 *     (v+=variableDeclaration* s=statementList e+=exceptionHandler* p=otherHandler?)
	 */
	protected void sequence_codeBlockStatement(ISerializationContext context, codeBlockStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     codeBlock returns codeBlock
	 *
	 * Constraint:
	 *     (v+=variableDeclaration* s=statementList e+=exceptionHandler* o=otherHandler?)
	 */
	protected void sequence_codeBlock(ISerializationContext context, codeBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     collectionTypeRef returns collectionTypeRef
	 *     primaryExpression returns collectionTypeRef
	 *     typeNameExpression returns collectionTypeRef
	 *
	 * Constraint:
	 *     (
	 *         (e=expression? t=typeReference) | 
	 *         (a=arrayBounds t=typeReference) | 
	 *         t=typeReference | 
	 *         t=typeReference | 
	 *         ((n=namedTypeRef | i=instanceTypeRef)? d=dictValueType)
	 *     )?
	 */
	protected void sequence_collectionTypeRef_dictKeyType(ISerializationContext context, collectionTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     extendedExpression returns createArgumentList
	 *     createExpression returns createArgumentList
	 *     createArgumentList returns createArgumentList
	 *
	 * Constraint:
	 *     (c+=createArgument c+=createArgument*)?
	 */
	protected void sequence_createArgumentList(ISerializationContext context, createArgumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     createArgument returns createArgument
	 *
	 * Constraint:
	 *     ((a=attributeName e=expression) | s=stateName)
	 */
	protected void sequence_createArgument(ISerializationContext context, createArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     dictKeyType returns dictKeyType
	 *
	 * Constraint:
	 *     (n=namedTypeRef | i=instanceTypeRef)
	 */
	protected void sequence_dictKeyType(ISerializationContext context, dictKeyType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     dictValueType returns dictValueType
	 *
	 * Constraint:
	 *     t=typeReference
	 */
	protected void sequence_dictValueType(ISerializationContext context, dictValueType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DICT_VALUE_TYPE__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DICT_VALUE_TYPE__T));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDictValueTypeAccess().getTTypeReferenceParserRuleCall_0(), semanticObject.getT());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     definition returns domainFunctionDefinition
	 *     domainFunctionDefinition returns domainFunctionDefinition
	 *
	 * Constraint:
	 *     (s=serviceVisibility p=parameterList r=returnType c=codeBlock)
	 */
	protected void sequence_domainFunctionDefinition(ISerializationContext context, domainFunctionDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DOMAIN_FUNCTION_DEFINITION__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DOMAIN_FUNCTION_DEFINITION__S));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__P));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DOMAIN_FUNCTION_DEFINITION__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DOMAIN_FUNCTION_DEFINITION__R));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainFunctionDefinitionAccess().getSServiceVisibilityParserRuleCall_0_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getDomainFunctionDefinitionAccess().getPParameterListParserRuleCall_5_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getDomainFunctionDefinitionAccess().getRReturnTypeParserRuleCall_7_0(), semanticObject.getR());
		feeder.accept(grammarAccess.getDomainFunctionDefinitionAccess().getCCodeBlockParserRuleCall_9_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     definition returns domainServiceDefinition
	 *     domainServiceDefinition returns domainServiceDefinition
	 *
	 * Constraint:
	 *     (s=serviceVisibility p=parameterList c=codeBlock)
	 */
	protected void sequence_domainServiceDefinition(ISerializationContext context, domainServiceDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DOMAIN_SERVICE_DEFINITION__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DOMAIN_SERVICE_DEFINITION__S));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__P));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainServiceDefinitionAccess().getSServiceVisibilityParserRuleCall_0_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getDomainServiceDefinitionAccess().getPParameterListParserRuleCall_5_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getDomainServiceDefinitionAccess().getCCodeBlockParserRuleCall_7_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     elsifBlock returns elsifBlock
	 *
	 * Constraint:
	 *     (c=condition s=statementList)
	 */
	protected void sequence_elsifBlock(ISerializationContext context, elsifBlock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ELSIF_BLOCK__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ELSIF_BLOCK__C));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ELSIF_BLOCK__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ELSIF_BLOCK__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElsifBlockAccess().getCConditionParserRuleCall_1_0(), semanticObject.getC());
		feeder.accept(grammarAccess.getElsifBlockAccess().getSStatementListParserRuleCall_3_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     equality returns equality
	 *
	 * Constraint:
	 *     (r+=relationalExp r+=relationalExp*)
	 */
	protected void sequence_equality(ISerializationContext context, equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exitStatement returns exitStatement
	 *
	 * Constraint:
	 *     c=condition?
	 */
	protected void sequence_exitStatement(ISerializationContext context, exitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     streamValue returns expression
	 *     returnStatement returns expression
	 *     delayStatement returns expression
	 *     deleteStatement returns expression
	 *     eraseStatement returns expression
	 *     cancelTimerStatement returns expression
	 *     condition returns expression
	 *     loopVariableSpec returns expression
	 *     expression returns expression
	 *
	 * Constraint:
	 *     r=rangeExpression
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getRRangeExpressionParserRuleCall_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     forStatement returns expression
	 *
	 * Constraint:
	 *     (r=rangeExpression s=statementList)
	 */
	protected void sequence_expression_forStatement(ISerializationContext context, expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION__R));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOOP_VARIABLE_SPEC__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOOP_VARIABLE_SPEC__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getRRangeExpressionParserRuleCall_0(), semanticObject.getR());
		feeder.accept(grammarAccess.getForStatementAccess().getSStatementListParserRuleCall_3_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     scheduleStatement returns expression
	 *
	 * Constraint:
	 *     (r=rangeExpression g=generateStatement e+=expression e+=expression?)
	 */
	protected void sequence_expression_scheduleStatement(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     findPrimary returns findComparison
	 *     findComparison returns findComparison
	 *
	 * Constraint:
	 *     (f=findName a=additiveExp)
	 */
	protected void sequence_findComparison(ISerializationContext context, findComparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIND_COMPARISON__F) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIND_COMPARISON__F));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIND_COMPARISON__A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIND_COMPARISON__A));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindComparisonAccess().getFFindNameParserRuleCall_0_0(), semanticObject.getF());
		feeder.accept(grammarAccess.getFindComparisonAccess().getAAdditiveExpParserRuleCall_2_0(), semanticObject.getA());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     findCondition returns findCondition
	 *     findPrimary returns findCondition
	 *     findUnary returns findCondition
	 *
	 * Constraint:
	 *     f=findLogicalOr
	 */
	protected void sequence_findCondition(ISerializationContext context, findCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIND_CONDITION__F) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIND_CONDITION__F));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindConditionAccess().getFFindLogicalOrParserRuleCall_0(), semanticObject.getF());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     whereClause returns whereClause
	 *
	 * Constraint:
	 *     f=findLogicalOr?
	 */
	protected void sequence_findCondition_whereClause(ISerializationContext context, whereClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     extendedExpression returns findExpression
	 *     findExpression returns findExpression
	 *
	 * Constraint:
	 *     (p=postfixNoCallExpression w=whereClause)
	 */
	protected void sequence_findExpression(ISerializationContext context, findExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIND_EXPRESSION__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIND_EXPRESSION__P));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIND_EXPRESSION__W) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIND_EXPRESSION__W));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindExpressionAccess().getPPostfixNoCallExpressionParserRuleCall_1_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getFindExpressionAccess().getWWhereClauseParserRuleCall_2_0(), semanticObject.getW());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     findLogicalAnd returns findLogicalAnd
	 *
	 * Constraint:
	 *     (f+=findPrimary f+=findPrimary*)
	 */
	protected void sequence_findLogicalAnd(ISerializationContext context, findLogicalAnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     findLogicalOr returns findLogicalOr
	 *
	 * Constraint:
	 *     (f+=findLogicalXor f+=findLogicalXor*)
	 */
	protected void sequence_findLogicalOr(ISerializationContext context, findLogicalOr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     findLogicalXor returns findLogicalXor
	 *
	 * Constraint:
	 *     (f+=findLogicalAnd f+=findLogicalAnd*)
	 */
	protected void sequence_findLogicalXor(ISerializationContext context, findLogicalXor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     findName returns findName
	 *
	 * Constraint:
	 *     (i1=identifier (i2+=identifier | e+=expression)*)
	 */
	protected void sequence_findName(ISerializationContext context, findName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ifStatement returns ifStatement
	 *
	 * Constraint:
	 *     (c=condition s=statementList e1+=elsifBlock* e2=elseBlock?)
	 */
	protected void sequence_ifStatement(ISerializationContext context, ifStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unaryExp returns linkExpression
	 *     linkExpression returns linkExpression
	 *
	 * Constraint:
	 *     (n1=navigateExpression | (n2=navigateExpression r=relationshipSpec n3=navigateExpression?))
	 */
	protected void sequence_linkExpression(ISerializationContext context, linkExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     linkStatement returns linkStatement
	 *
	 * Constraint:
	 *     (n1=navigateExpression r=relationshipSpec (n2=navigateExpression n3=navigateExpression?)?)
	 */
	protected void sequence_linkStatement(ISerializationContext context, linkStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logicalAnd returns logicalAnd
	 *
	 * Constraint:
	 *     (e+=equality e+=equality*)
	 */
	protected void sequence_logicalAnd(ISerializationContext context, logicalAnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logicalOr returns logicalOr
	 *
	 * Constraint:
	 *     (l+=logicalXor l+=logicalXor*)
	 */
	protected void sequence_logicalOr(ISerializationContext context, logicalOr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     logicalXor returns logicalXor
	 *
	 * Constraint:
	 *     (l+=logicalAnd l+=logicalAnd*)
	 */
	protected void sequence_logicalXor(ISerializationContext context, logicalXor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     multExp returns multExp
	 *
	 * Constraint:
	 *     (u+=unaryExp u+=unaryExp*)
	 */
	protected void sequence_multExp(ISerializationContext context, multExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     navigateExpression returns navigateExpression
	 *
	 * Constraint:
	 *     (e+=extendedExpression ((r+=relationshipSpec w+=whereClause?) | (e+=extendedExpression r+=relationshipSpec))*)
	 */
	protected void sequence_navigateExpression(ISerializationContext context, navigateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     definition returns objectFunctionDefinition
	 *     objectFunctionDefinition returns objectFunctionDefinition
	 *
	 * Constraint:
	 *     (v=serviceVisibility s=serviceType p=parameterList r=returnType c=codeBlock)
	 */
	protected void sequence_objectFunctionDefinition(ISerializationContext context, objectFunctionDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBJECT_FUNCTION_DEFINITION__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBJECT_FUNCTION_DEFINITION__V));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBJECT_FUNCTION_DEFINITION__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBJECT_FUNCTION_DEFINITION__S));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__P));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBJECT_FUNCTION_DEFINITION__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBJECT_FUNCTION_DEFINITION__R));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectFunctionDefinitionAccess().getVServiceVisibilityParserRuleCall_0_0(), semanticObject.getV());
		feeder.accept(grammarAccess.getObjectFunctionDefinitionAccess().getSServiceTypeParserRuleCall_1_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getObjectFunctionDefinitionAccess().getPParameterListParserRuleCall_8_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getObjectFunctionDefinitionAccess().getRReturnTypeParserRuleCall_10_0(), semanticObject.getR());
		feeder.accept(grammarAccess.getObjectFunctionDefinitionAccess().getCCodeBlockParserRuleCall_12_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     definition returns objectServiceDefinition
	 *     objectServiceDefinition returns objectServiceDefinition
	 *
	 * Constraint:
	 *     (s=serviceVisibility p=parameterList c=codeBlock)
	 */
	protected void sequence_objectServiceDefinition(ISerializationContext context, objectServiceDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBJECT_SERVICE_DEFINITION__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBJECT_SERVICE_DEFINITION__S));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__P));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectServiceDefinitionAccess().getSServiceVisibilityParserRuleCall_0_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getObjectServiceDefinitionAccess().getPParameterListParserRuleCall_8_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getObjectServiceDefinitionAccess().getCCodeBlockParserRuleCall_10_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameterList returns parameterList
	 *
	 * Constraint:
	 *     (p+=parameterDefinition? p+=parameterDefinition*)
	 */
	protected void sequence_parameterList(ISerializationContext context, parameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primaryExpression returns parenthesisedExpression
	 *     parenthesisedExpression returns parenthesisedExpression
	 *
	 * Constraint:
	 *     (e+=expression e+=expression*)
	 */
	protected void sequence_parenthesisedExpression(ISerializationContext context, parenthesisedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     extendedExpression returns postfixExpression
	 *     postfixExpression returns postfixExpression
	 *
	 * Constraint:
	 *     (p=primaryExpression (a+=argumentList | e+=expression | a+=argumentList)*)
	 */
	protected void sequence_postfixExpression(ISerializationContext context, postfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     postfixNoCallExpression returns postfixNoCallExpression
	 *
	 * Constraint:
	 *     (p=primaryExpression e+=expression*)
	 */
	protected void sequence_postfixNoCallExpression(ISerializationContext context, postfixNoCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primaryExpression returns primaryExpression
	 *
	 * Constraint:
	 *     {primaryExpression}
	 */
	protected void sequence_primaryExpression(ISerializationContext context, primaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rangeExpression returns rangeExpression
	 *
	 * Constraint:
	 *     (l+=logicalOr l+=logicalOr?)
	 */
	protected void sequence_rangeExpression(ISerializationContext context, rangeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relationalExp returns relationalExp
	 *
	 * Constraint:
	 *     (a+=additiveExp a+=additiveExp*)
	 */
	protected void sequence_relationalExp(ISerializationContext context, relationalExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     relationshipSpec returns relationshipSpec
	 *
	 * Constraint:
	 *     (r+=RELATIONSHIPNAME (r+=identifier r+=objectName?)?)
	 */
	protected void sequence_relationshipSpec(ISerializationContext context, relationshipSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     serviceVisibility returns serviceVisibility
	 *
	 * Constraint:
	 *     (v=PRIVATE | v=PUBLIC)?
	 */
	protected void sequence_serviceVisibility(ISerializationContext context, serviceVisibility semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     definition returns stateDefinition
	 *     stateDefinition returns stateDefinition
	 *
	 * Constraint:
	 *     (s=stateType p=parameterList c=codeBlock)
	 */
	protected void sequence_stateDefinition(ISerializationContext context, stateDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STATE_DEFINITION__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STATE_DEFINITION__S));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__P));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStateDefinitionAccess().getSStateTypeParserRuleCall_0_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getStateDefinitionAccess().getPParameterListParserRuleCall_7_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getStateDefinitionAccess().getCCodeBlockParserRuleCall_9_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     stateType returns stateType
	 *
	 * Constraint:
	 *     (s=ASSIGNER | s=assignerStart | s=CREATION | s=TERMINAL)?
	 */
	protected void sequence_stateType(ISerializationContext context, stateType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statementList returns statementList
	 *     elseBlock returns statementList
	 *     caseOthers returns statementList
	 *     exceptionHandler returns statementList
	 *     otherHandler returns statementList
	 *
	 * Constraint:
	 *     s+=statement*
	 */
	protected void sequence_statementList(ISerializationContext context, statementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (
	 *         c=codeBlockStatement | 
	 *         e=assignStatement | 
	 *         s=streamStatement | 
	 *         n=nullStatement | 
	 *         c=callStatement | 
	 *         e=exitStatement | 
	 *         r=returnStatement | 
	 *         d=delayStatement | 
	 *         d=deleteStatement | 
	 *         e=eraseStatement | 
	 *         l=linkStatement | 
	 *         s=scheduleStatement | 
	 *         c=cancelTimerStatement | 
	 *         g=generateStatement | 
	 *         i=ifStatement | 
	 *         c=caseStatement | 
	 *         f=forStatement | 
	 *         w=whileStatement
	 *     )?
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     streamStatement returns streamStatement
	 *
	 * Constraint:
	 *     (e=expression s+=streamValue+)
	 */
	protected void sequence_streamStatement(ISerializationContext context, streamStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     definition returns terminatorFunctionDefinition
	 *     terminatorFunctionDefinition returns terminatorFunctionDefinition
	 *
	 * Constraint:
	 *     (s=serviceVisibility p=parameterList r=returnType c=codeBlock)
	 */
	protected void sequence_terminatorFunctionDefinition(ISerializationContext context, terminatorFunctionDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TERMINATOR_FUNCTION_DEFINITION__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TERMINATOR_FUNCTION_DEFINITION__S));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__P));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TERMINATOR_FUNCTION_DEFINITION__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TERMINATOR_FUNCTION_DEFINITION__R));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminatorFunctionDefinitionAccess().getSServiceVisibilityParserRuleCall_0_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getTerminatorFunctionDefinitionAccess().getPParameterListParserRuleCall_7_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getTerminatorFunctionDefinitionAccess().getRReturnTypeParserRuleCall_9_0(), semanticObject.getR());
		feeder.accept(grammarAccess.getTerminatorFunctionDefinitionAccess().getCCodeBlockParserRuleCall_11_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     definition returns terminatorServiceDefinition
	 *     terminatorServiceDefinition returns terminatorServiceDefinition
	 *
	 * Constraint:
	 *     (s=serviceVisibility p=parameterList c=codeBlock)
	 */
	protected void sequence_terminatorServiceDefinition(ISerializationContext context, terminatorServiceDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TERMINATOR_SERVICE_DEFINITION__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TERMINATOR_SERVICE_DEFINITION__S));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__P));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DEFINITION__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DEFINITION__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminatorServiceDefinitionAccess().getSServiceVisibilityParserRuleCall_0_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getTerminatorServiceDefinitionAccess().getPParameterListParserRuleCall_7_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getTerminatorServiceDefinitionAccess().getCCodeBlockParserRuleCall_9_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primaryExpression returns typeNameExpression
	 *     typeNameExpression returns typeNameExpression
	 *
	 * Constraint:
	 *     {typeNameExpression}
	 */
	protected void sequence_typeNameExpression(ISerializationContext context, typeNameExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeReference returns typeReference
	 *     typeReferenceWithCA returns typeReference
	 *     parameterDefinition returns typeReference
	 *     parameterType returns typeReference
	 *     returnType returns typeReference
	 *
	 * Constraint:
	 *     c=collectionTypeRef?
	 */
	protected void sequence_typeReference(ISerializationContext context, typeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variableDeclaration returns variableDeclaration
	 *
	 * Constraint:
	 *     (t=typeReferenceWithCA e=expression?)
	 */
	protected void sequence_variableDeclaration(ISerializationContext context, variableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     whileStatement returns whileStatement
	 *
	 * Constraint:
	 *     (c=condition s=statementList)
	 */
	protected void sequence_whileStatement(ISerializationContext context, whileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.WHILE_STATEMENT__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.WHILE_STATEMENT__C));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.WHILE_STATEMENT__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.WHILE_STATEMENT__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getCConditionParserRuleCall_1_0(), semanticObject.getC());
		feeder.accept(grammarAccess.getWhileStatementAccess().getSStatementListParserRuleCall_3_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
}
