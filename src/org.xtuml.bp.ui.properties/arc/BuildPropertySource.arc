.//========================================================================
.//
.//File:      $RCSfile: BuildPropertySource.arc,v $
.//Version:   $Revision: 1.66 $
.//Modified:  $Date: 2013/01/17 03:30:35 $
.//
.//(c) Copyright 2006-2014 by Mentor Graphics Corp. All rights reserved.
.//
.//========================================================================
.// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
.// use this file except in compliance with the License.  You may obtain a copy 
.// of the License at
.//
.//       http://www.apache.org/licenses/LICENSE-2.0
.//
.// Unless required by applicable law or agreed to in writing, software 
.// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
.// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the 
.// License for the specific language governing permissions and limitations under
.// the License.
.//========================================================================
.//
.// This file is the entry point for generating the code for the
.// property view sources and descriptors
.//
.invoke arc_env = GET_ENV_VAR( "PTC_MC_ARC_DIR" )
.assign mc_archetypes = arc_env.result
.if ( mc_archetypes == "" )
  .print "\nERROR: Environment variable PTC_MC_ARC_DIR not set."
  .exit 100
.end if
.//
.include "${mc_archetypes}/arch_utils.inc"
.//
.invoke chain_util_env = GET_ENV_VAR( "CHAIN_UTIL_DIR" )
.assign chain_util = chain_util_env.result
.if ( chain_util == "" )
  .print "\nERROR: Environment variable CHAIN_UTIL_DIR not set."
  .exit 100
.end if
.include "${chain_util}/arc/parse_chain.inc"
.//
.invoke core_color_env = GET_ENV_VAR( "CORE_COLOR_DIR" )
.assign core_color = core_color_env.result
.if ( core_color == "" )
  .print "\nERROR: Environment variable CORE_COLOR_DIR not set."
  .exit 100
.end if
.include "${core_color}/ooaofooa_package_spec.clr"
.invoke compMark = markComponentsAndContainments()
.//
.function get_property_class_name
  .param inst_ref node  .// T_TNS
  .param inst_ref class  .// O_OBJ
$r{node.CategoryName}${class.Key_Lett}PropertySource\
.end function
.//
.//
.//
.function get_file_header
  .param string class_name
//======================================================================
//
// File: ${class_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      $$Revision: 1.66 $$
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp.  All rights reserved.
//
//======================================================================
.end function
.//
.//
.//
.function get_class_name_accessor
  .param inst_ref class   .// O_OBJ
  .param string inst_var
  .select one attr related by class->O_ATTR[R102] where ( selected.Name == "Name" )
  .if ( not_empty attr )
    .invoke gaa = get_attribute_accessor(attr)
${inst_var}.${gaa.body}\
  .else
    .select one op related by class->O_TFR[R115] where ( selected.Name == "get_name" )
    .if ( not_empty op )
${inst_var}.Get_name\
    .else
super.toString\
    .end if
  .end if
.end function
.//
.function get_validmult_decl
    private String[] validMult_vals()
    {
        String [] onlyOne = { "One" };
        if ( m_inst.Manymultallowed() )
        {
            return Mult_vals;
        }
        return onlyOne;
    }
.end function
.//
.//
.function generic_package_query
.param string result_set_name
    if (m_inst.isInGenericPackage()) {
    	Package_c pkg = m_inst.getFirstParentPackage();
    	Component_c component = m_inst.getFirstParentComponent();
        if ((pkg != null)) {
             pkg.Clearscope();
             pkg.Collectvisibleelementsforname(false, Gd_c.Null_unique_id(), false,
                      "", pkg.getPackage_id(), Elementtypeconstants_c.DATATYPE);           
                      
             class SearchResultSet_test24870_c implements ClassQueryInterface_c {
                public boolean evaluate(Object candidate) {
                    SearchResultSet_c selected = (SearchResultSet_c) candidate;
                    return selected.getName().equals("")
                            && selected.getType() == Elementtypeconstants_c.DATATYPE;
                }
             }
             SearchResultSet_c v_resultSet = SearchResultSet_c.getOnePE_SRSOnR8005(pkg,
                            new SearchResultSet_test24870_c());
            
             ${result_set_name} = DataType_c.getManyS_DTsOnR8001(
                    PackageableElement_c.getManyPE_PEsOnR8002(ElementVisibility_c.getManyPE_VISsOnR8006(v_resultSet)));                    
        } else {
                if (component != null) {
                  component.Clearscope();
                  component.Collectvisibleelementsforname(false, Gd_c.Null_unique_id(), "",
                                  component.getId(), Elementtypeconstants_c.DATATYPE);
                                  
                  class ComponentResultSet_test24870_c implements ClassQueryInterface_c {
                      public boolean evaluate(Object candidate) {
                          ComponentResultSet_c selected = (ComponentResultSet_c) candidate;
                          return selected.getName().equals("")
                                  && selected.getType() == Elementtypeconstants_c.DATATYPE;
                      }
                  }
                  ComponentResultSet_c v_resultSet = ComponentResultSet_c.getOnePE_CRSOnR8007(component,
                                  new ComponentResultSet_test24870_c());
                  
                  ${result_set_name} = DataType_c.getManyS_DTsOnR8001(
                          PackageableElement_c.getManyPE_PEsOnR8004(ComponentVisibility_c.getManyPE_CVSsOnR8008(v_resultSet)));
                                                      
                } else {
                    // only throw an error the the element owning
                    // this property source, are expected to not
                    // have a package or component (the cases that
                    // are not are UDTs that are built in)  Note that
                    // the tool will behave properly, as the field
                    // for these are read-only.
                    if(!m_inst.selfIsCoreDataType()) {
                    	Throwable t = new Throwable();
                    	t.fillInStackTrace();
                    	CorePlugin.logError(
                                    "Attempted to call an operation on a null instance.",
                                    t);
					}
                }

            }
    }
.end function
.//
.//
.function get_enum_descriptor
  .param inst_ref attr   .// O_ATTR
  .//
  .select one dt related by attr->S_DT[R114]
  .select one edt related by dt->S_EDT[R17]
  .assign attr_enum_decl_var = "$r{attr.Name}_vals"
  .assign attr_enum_decl = "    private String[] ${attr_enum_decl_var} = { "
  .if ( empty edt )
  .assign enum0 = "${attr.Descrip:enum0}"
  .assign attr_enum_decl = attr_enum_decl + """${enum0}"""
  .assign enum1 = "${attr.Descrip:enum1}"
  .if ( enum1 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum1}"""
  .end if
  .assign enum2 = "${attr.Descrip:enum2}"
  .if ( enum2 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum2}"""
  .end if
  .assign enum3 = "${attr.Descrip:enum3}"
  .if ( enum3 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum3}"""
  .end if
  .assign enum4 = "${attr.Descrip:enum4}"
  .if ( enum4 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum4}"""
  .end if
  .assign enum5 = "${attr.Descrip:enum5}"
  .if ( enum5 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum5}"""
  .end if
  .assign enum6 = "${attr.Descrip:enum6}"
  .if ( enum6 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum6}"""
  .end if
  .assign enum7 = "${attr.Descrip:enum7}"
  .if ( enum7 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum7}"""
  .end if
  .assign enum8 = "${attr.Descrip:enum8}"
  .if ( enum8 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum8}"""
  .end if
  .assign enum9 = "${attr.Descrip:enum9}"
  .if ( enum9 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum9}"""
  .end if
  .assign enum10 = "${attr.Descrip:enum10}"
  .if ( enum10 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum10}"""
  .end if
  .assign enum11 = "${attr.Descrip:enum11}"
  .if ( enum11 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum11}"""
  .end if
  .assign enum12 = "${attr.Descrip:enum12}"
  .if ( enum12 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum12}"""
  .end if
  .assign enum13 = "${attr.Descrip:enum13}"
  .if ( enum13 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum13}"""
  .end if
  .assign enum14 = "${attr.Descrip:enum14}"
  .if ( enum14 != "" )
    .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum14}"""
  .end if
  .else
    .select many enum_set related by edt->S_ENUM[R27];
    .assign enum_num = 0
    .while ( enum_num < (cardinality enum_set))
      .for each enum in enum_set
        .if ( "${enum.Descrip:Value}" == "${enum_num}" )
          .assign enum_name = enum.Name
          .if ( "${enum.Descrip:Full Name}" != "" )
            .assign enum_name = "${enum.Descrip:Full Name}"
          .end if
          .if ( enum_num == 0 )
            .assign attr_enum_decl = attr_enum_decl + """${enum_name}"""
          .else
            .assign attr_enum_decl = attr_enum_decl + ",\n        ""${enum_name}"""
          .end if
          .break for
        .end if
      .end for
      .assign enum_num = enum_num + 1
    .end while
  .end if
  .assign attr_enum_decl = attr_enum_decl + " };"
  .if ( attr.Name == "Mult" )
    .invoke gvmd = get_validmult_decl()
    .assign attr_enum_decl = attr_enum_decl + "\n${gvmd.body}"
    .assign attr_enum_decl_var = "valid${attr_enum_decl_var}()"
  .end if
.end function
.//
.//
.//
.function show_simple_attr
  .param inst_ref attr   .// O_ATTR
  .//
  .assign attr_result = true
  .select one dt related by attr->S_DT[R114]
  .select one rattr related by attr->O_RATTR[R106]
  .if ( dt.Name == "unique_id" )
    .assign attr_result = false
  .elif (not_empty rattr)
    .assign attr_result = false
  .elif ("$l{attr.Descrip:User_Visible}" == "false")
    .assign attr_result = false
  .elif ("$l{attr.Descrip:In Properties}" == "false")
    .assign attr_result = false
  .end if
.end function
.//
.//
.//
.function simple_attr_descriptors
  .param inst_ref_set attributes  .// O_ATTR
  .//
  .assign attr_num_attr = 0
  .assign attr_enum_decls = ""
  .for each attr in attributes
    .invoke ssa = show_simple_attr( attr )
    .if ( ssa.result )
      .assign name = "${attr.Name}"
      .assign fullname = "${attr.Descrip:Full Name}"
      .assign readonly = "$l{attr.Descrip:readonly}"
      .assign dynamicReadOnly = "$l{attr.Descrip:DynamicReadOnly}"
      .select one dt related by attr->S_DT[R114]
      .select one edt related by dt->S_EDT[R17]
      .select one dbattr related by attr->O_BATTR[R106]->O_DBATTR[R107]
      .select one obj related by attr->O_OBJ[R102]
      .assign readOnlyFlag = "readonly"
      .if (dynamicReadOnly != "")
        .assign readOnlyFlag = "readonly || m_inst.$Cr{dynamicReadOnly}()"
      .end if
      .if ( ((not_empty dbattr) or (readonly == "true")) and (attr.Name != "Action_Semantics") )
          .if ( ("${attr.Descrip:enum0}" == "") and (empty edt) )
                m_propertyDescriptors[${attr_num_attr}] = new PropertyDescriptor("${name}", "${fullname}");
          .else
            .invoke ged = get_enum_descriptor(attr)
                m_propertyDescriptors[${attr_num_attr}] = new EnumPropertyDescriptor("${name}", "${fullname}", ${ged.enum_decl_var}, true);
            .assign attr_enum_decls = attr_enum_decls + ged.enum_decl
          .end if
      .else
        .if (dt.Name == "boolean" )
                m_propertyDescriptors[${attr_num_attr}] = new BooleanPropertyDescriptor("${name}", "${fullname}", ${readOnlyFlag});
        .elif ((dt.Name == "integer") or (not_empty edt))
          .if ( ("${attr.Descrip:enum0}" == "") and (empty edt) )
            .assign min_value = "${attr.Descrip:min_value}"
            .if (min_value == "" )
              .assign min_value = "Integer.MIN_VALUE"
            .end if
            .assign max_value = "${attr.Descrip:max_value}"
            .if (max_value == "" )
              .assign max_value = "Integer.MAX_VALUE"
            .end if
                m_propertyDescriptors[${attr_num_attr}] = new IntegerPropertyDescriptor("${name}", "${fullname}", ${min_value}, ${max_value}, ${readOnlyFlag});
          .else
            .invoke ged = get_enum_descriptor(attr)
            .// assume all attrs are read-write
                m_propertyDescriptors[${attr_num_attr}] = new EnumPropertyDescriptor("${name}", "${fullname}", ${ged.enum_decl_var}, ${readOnlyFlag});
            .assign attr_enum_decls = attr_enum_decls + ged.enum_decl
          .end if
        .elif (dt.Name == "string" )
          .if (attr.Name == "Descrip" )
                m_propertyDescriptors[${attr_num_attr}] = new DescriptionPropertyDescriptor("${name}", "${fullname}", m_inst);
          .elif ( (obj.Key_Lett == "CNST_LSC") and (attr.Name == "Value") )
                m_propertyDescriptors[${attr_num_attr}] = new ConstantValuePropertyDescriptor("${name}", "${fullname}");
          .elif ( attr.Name == "Action_Semantics" )
                m_propertyDescriptors[${attr_num_attr}] = new ActivityPropertyDescriptor("${name}", "${fullname}", m_inst);
          .elif ( (attr.Name == "Dimensions") or (attr.Name == "Return_Dimensions") )
                m_propertyDescriptors[${attr_num_attr}] = new DimensionsPropertyDescriptor("${name}", "${fullname}", ${readOnlyFlag});
                m_propertyDescriptors[${attr_num_attr}].setValidator(new DimensionsValidator((NonRootModelElement)m_inst));
                m_propertyDescriptors[${attr_num_attr}].setDescription(DimensionsValidator.getDimensionsHelpText( ${readOnlyFlag} ));
          .else
            .// special case for not renaming model elements that are
            .// not meant to be renamed (the "Datatypes" package for example)
            .if ( attr.Name == "Name" )
              .select one obj related by attr->O_OBJ[R102]
              .select one op related by obj->O_TFR[R115] where (selected.Name == "canRename" )
              .if ( not_empty op )
                if (m_inst.Canrename()) {
                    m_propertyDescriptors[${attr_num_attr}] = new TextPropertyDescriptor("${name}", "${fullname}");
                }
                else {
                    m_propertyDescriptors[${attr_num_attr}] = new PropertyDescriptor("${name}", "${fullname}");
                }
              .else
                m_propertyDescriptors[${attr_num_attr}] = new TextPropertyDescriptor("${name}", "${fullname}");
              .end if
            .else
                m_propertyDescriptors[${attr_num_attr}] = new TextPropertyDescriptor("${name}", "${fullname}");
            .end if
          .end if
          .if ((attr.Name == "Name") or (attr.Name == "Root_Nam"))
                m_propertyDescriptors[${attr_num_attr}].setValidator(new ModelElementNameValidator(m_inst));
          .end if
        .end if
      .end if  .// if not_empty dbattr
                m_propertyDescriptors[${attr_num_attr}].setCategory(BridgepointPropertySheetPage.basicCategoryName);
      .assign attr_num_attr = attr_num_attr + 1
    .end if  .// asa.result
  .end for
.end function
.//
.//
.//
.function simple_attr_getpropval
  .param inst_ref_set attrs  .// O_ATTR
  .//
  .assign else_stmt = ""
  .for each attr in attrs
    .invoke ssa = show_simple_attr( attr )
    .if ( ssa.result )
      .invoke gaa = get_attribute_accessor(attr)
        ${else_stmt}if (id.equals("${attr.Name}"))
        {
      .select one dt related by attr->S_DT[R114]
      .select one edt related by dt->S_EDT[R17]
      .if (dt.Name == "boolean" )
            return new Boolean(m_inst.${gaa.body}());
        .assign else_stmt = "else "
      .elif ((dt.Name == "integer") or (not_empty edt))
        .if ( ("${attr.Descrip:enum0}" == "") and (empty edt) )
            return String.valueOf(m_inst.${gaa.body}());
        .else
            return $r{attr.Name}_vals[m_inst.${gaa.body}()];
        .end if
        .assign else_stmt = "else "
      .elif (dt.Name == "string" )
        .if ( (attr.Name == "Descrip") or (attr.Name == "Action_Semantics") )
            return m_inst.${gaa.body}().replace('\n', '/');
        .else
            return m_inst.${gaa.body}();
        .end if
        .assign else_stmt = "else "
      .end if
        }
    .end if   .// asa.result
  .end for
.end function
.//
.//
.//
.function simple_attr_setpropval
  .param inst_ref_set attrs   .// O_ATTR
  .param inst_ref class
  .param string val_change_var
  .param string trans_name_var
  .param string modelroot
  .//
  .assign else_stmt = ""
  .for each attr in attrs
    .invoke ssa = show_simple_attr( attr )
    .if ( ssa.result )
      .select one dbattr related by attr->O_BATTR[R106]->O_DBATTR[R107]
      .if ( empty dbattr )
        .assign aa = "set$cr{attr.Name}"
        ${else_stmt}if (id.equals("${attr.Name}"))
        {
        .select one dt related by attr->S_DT[R114]
        .select one edt related by dt->S_EDT[R17]
        .assign trans_name_string = "Change in property: '${attr.Name}' of ${class.Name}"
        .assign trans_start_expr = "tr = tm.startTransaction(${trans_name_var}, ${modelroot}.getDefaultInstance());"
        .if (dt.Name == "boolean" )
            boolean new_val = ((Boolean)value).booleanValue();
            if ( new_val != m_inst.get$cr{attr.Name}() )
            {
                ${trans_name_var} = "${trans_name_string}"; //$$NON-NLS-1$$
                ${trans_start_expr}
                ${val_change_var} = true;
                m_inst.${aa}(new_val);
            }
          .assign else_stmt = "else "
        .elif (((dt.Name == "integer" ) or (not_empty edt)) or (dt.Name == "real"))
            int new_val = Integer.parseInt(value.toString());
            if ( new_val != m_inst.get$cr{attr.Name}() )
            {
                ${trans_name_var} = "${trans_name_string}";//$$NON-NLS-1$$
                ${trans_start_expr}
                ${val_change_var} = true;
                m_inst.${aa}(new_val);
            }
          .assign else_stmt = "else "
        .elif (dt.Name == "string" )
            if ( ! value.toString().equals(m_inst.get$cr{attr.Name}()) )
            {
                ${trans_name_var} = "${trans_name_string}";//$$NON-NLS-1$$
                ${trans_start_expr}
                ${val_change_var} = true;
          .if ( (attr.Name == "Dimensions") or (attr.Name == "Return_Dimensions") )
                Vector dims = DimensionsUtil.getDimensionsData(value.toString(),m_inst);
                if (dims.size() > 0) {
                    for (int i = 0; i < dims.size(); i++) {
                        int numElements = ((Integer)dims.get(i)).intValue();
                        m_inst.Resize$LR{attr.Name}(i, numElements, dims.size());
                    }
                } else {
                    m_inst.Resize$LR{attr.Name}(0, 0, 0);
                }
          .end if
                .// This is a special hook (hack) to handle Model Class renames. For
                .// Model Class we don't want to only set the Name attribute, we need to
                .// update the associated inst ref datatype names as well. So we call a
                .// special rename function instead of calling setName() directly.
                .if( ("${class.Name}" == "Model Class" ) and ("$cr{attr.Name}" == "Name") )
                m_inst.Rename(value.toString());
                .else
                m_inst.${aa}(value.toString());
                .end if
            }
          .assign else_stmt = "else "
        .end if
        }
      .end if   .// empty dbattr
    .end if  .// asa.result
  .end for
.end function
.//
.//
.//
.function referential_attr_descriptors
  .param string parent_class_name
  .param inst_ref class
  .param inst_ref_set child_specs  .// T_TPS
  .param integer num_simple_attrs
  .param string modelroot
  .//
  .assign attr_needs_imports = false
  .assign attr_instance_decls = ""
  .assign attr_instance_init = ""
  .assign attr_num_modifiable = 0
  .for each spec in child_specs
    .select one child related by spec->T_TNS[R1001]
    .assign child_var_name = "v_$lr{child.CategoryName}$r{spec.NameOnly}"
    .select one parent_node related by spec->T_TNS[R1000]
    .//
    .// declare referred to instance arrays
    .if ( spec.UserModifiable )
      .assign attr_needs_imports = true
      .assign attr_instance_decls = attr_instance_decls + "    private String[] m_$r{child.categoryName}$r{spec.NameOnly};\n"
    .else
      .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
      .invoke child_class_name = get_class_name(child_class)
      .assign attr_instance_decls = attr_instance_decls + "    private ${child_class_name.body}[] m_$r{child.categoryName}$r{spec.NameOnly};\n"
    .end if
    .//
    .// initialize referred to instance arrays
    .if ( spec.UserModifiable )
      .assign attr_num_modifiable = attr_num_modifiable + 1
    .else
      .select one child related by spec->T_TNS[R1001]
      .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
      .// This is a special case to allow view of DT in case of user defined
      .// udt
      .if (parent_node.Key_Lett == "S_UDT")
        .assign check_gen_type_for_udt = "if(m_inst.getGen_type() == 0){     "
        .assign attr_instance_init = attr_instance_init + check_gen_type_for_udt
      .end if
      .if ( (parent_node.Key_Lett == "EP_PKG") and (child_class.Key_Lett == "EP_PKG") )
         .assign attr_instance_init =  attr_instance_init  + "Package_c[] v_packages = Package_c .getManyEP_PKGsOnR8001(PackageableElement_c .getManyPE_PEsOnR8000((Package_c) m_inst));\n"
         .assign attr_instance_init =  attr_instance_init  + "m_Packages = v_packages;\nnum_children += v_packages.length;\n"        
      .else
          .invoke rel_nav = generate_backward_rel_chain_nav(parent_node, spec.ParentChildRelChain, "many", "m_inst", "${child_var_name}")
          .assign attr_instance_init = attr_instance_init + rel_nav.body
          .assign attr_instance_init = attr_instance_init + "       m_$r{child.categoryName}$r{spec.NameOnly} = ${child_var_name};\n"
          .assign attr_instance_init = attr_instance_init + "       num_children += m_$r{child.categoryName}$r{spec.NameOnly}.length;\n"
          .if (parent_node.Key_Lett == "S_UDT")
            .assign attr_instance_init = attr_instance_init + "\n\t\tsorter.sort(${child_var_name});\n"
            .assign attr_instance_init = attr_instance_init + "      }"
          .end if
      .end if  
    .end if
    .if((not spec.UserModifiable) and (parent_node.Key_Lett != "S_UDT"))
      .assign attr_instance_init = attr_instance_init + "\n\t\tsorter.sort(${child_var_name});\n"
    .end if
  .end for
  .//
  .if ( not_empty child_specs )
        int d_index = ${num_simple_attrs};
    .for each spec in child_specs
      .if ( spec.UserModifiable )
        .select one child related by spec->T_TNS[R1001]
        .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
      // create combobox descriptor for ${child_class.Name}
        .invoke child_class_name = get_class_name(child_class)
        .assign set_var_name = "set${info.unique_num}"
        .if(spec.CrossModelRootBoundary)
           Object[] rootsOfDataTypePackages = m_inst.getModelRoot().getModelRoots("${spec.ModelRootType}", "${spec.ExcludedModelRootType}");     
            Object[] rootsOfPackages= m_inst.getModelRoot().getModelRoots("Package", "${spec.ExcludedModelRootType}");
            List<Object> bothRoots = new ArrayList<Object>(rootsOfDataTypePackages.length + rootsOfPackages.length); 
            Collections.addAll(bothRoots , rootsOfDataTypePackages);
            Collections.addAll(bothRoots , rootsOfPackages);
            Object[] roots = bothRoots.toArray();
           
            ArrayList<${child_class_name.body}> list = new ArrayList<${child_class_name.body}>();
            for(int i = 0; i < roots.length; i++) {
                ${child_class_name.body}[] children = ${child_class_name.body}.$Cr{child_class.Name}Instances((ModelRoot) roots[i]);
                for(int j = 0; j < children.length; j++) {
                  .// special case for suppressed data types
                  .if(child.Key_Lett == "S_DT")
                    DatatypeInSuppression_c dis = DatatypeInSuppression_c.getOneS_DISOnR47(children[j]);
                    SystemDatatypeInPackage_c sdip = SystemDatatypeInPackage_c.getOneSLD_SDINPOnR4401(children[j]);
                  PackageableElement_c pe = PackageableElement_c.getOnePE_PEOnR8001(children[j]);
                  if(dis == null && sdip != null) {
                       list.add(children[j]);
                  } else if(dis == null && pe != null) {
                        list.add(children[j]);
                  }
                  .else
                    list.add(children[j]);
                  .end if
                }
            }
              ${child_class_name.body} [] ${set_var_name} = list.toArray(new ${child_class_name.body}[list.size()]);
        .else
          .if(child.Key_Lett == "S_DT")
            ${child_class_name.body}[] ${set_var_name} = new ${child_class_name.body}[0];
            ${child_class_name.body}[] ${set_var_name}_2 = new ${child_class_name.body}[0];
          .else
        ${child_class_name.body} [] ${set_var_name} = ${child_class_name.body}.$Cr{child_class.Name}Instances((${modelroot})(m_inst.getModelRoot()));
          .end if
        .end if
        .assign list_var_name = "list${info.unique_num}"
            .// for dts process the second set, which will be
            .// system level datatypes
        .if((child.Key_Lett == "S_DT") and (not spec.CrossModelRootBoundary))
        	// Note that datatypes our handled by the dt chooser dialog
        	List ${list_var_name} = new ArrayList(${set_var_name}.length + ${set_var_name}_2.length);
        .else
    List ${list_var_name} = new ArrayList(${set_var_name}.length);
        .end if
        for (int i = 0; i < ${set_var_name}.length; ++i)
        {
        .invoke gana = get_class_name_accessor(child_class, "${set_var_name}[i]")
            if ( m_inst.Isallowed$rl{spec.NameOnly}(${gana.body}()) )
            {
              ${list_var_name}.add(${gana.body}());
            }
        }
        Collections.sort(${list_var_name}, new Comparator() {
            Collator coll = Collator.getInstance(Locale.getDefault());
            public int compare(Object a, Object b) {
                return coll.compare((String)a, (String)b);
            }
        });
        m_$r{child.categoryName}$r{spec.NameOnly} = new String[${list_var_name}.size()];
        for (int i = 0; i < ${list_var_name}.size(); ++i)
        {
            m_$r{child.categoryName}$r{spec.NameOnly}[i] = (String)${list_var_name}.get(i);
        }
        .// special case - model readonly takes precedence
        .// special case - referential attribute data type is readonly
        .// special case - predefined user data types are readonly
        .if ( parent_class_name == "Attribute_c" )
        if(!readonly) {
            readonly = (m_ReferentialAttribute.length != 0);
        }
        .// special case - model readonly takes precedence
        .elif ( parent_class_name == "UserDataType_c" )
        if(!readonly) {
            readonly = (m_inst.getGen_type() != 0);
        }
        .end if
        .if (child.Key_Lett == "S_DT")
			m_propertyDescriptors[d_index] = new ChooserPropertyDescriptor(
					"$r{child.categoryName}",
          .if ( spec.NameOnly != "" )
                    "${spec.NameOnly}",
          .else
                    "${child_class.Name}",
          .end if
					 m_inst,
          .if ((class.Key_Lett == "C_IO") or (class.Key_Lett == "O_TFR"))
					"org.xtuml.bp.core.ui.actions.SetReturnTypeOn$u{class.Key_Lett}Action", \
          .elif((class.Key_Lett == "S_BRG") or (class.Key_Lett == "S_SYNC"))
					"org.xtuml.bp.core.ui.actions.SetReturnTypeOn$u{class.Key_Lett}Action", \
          .elif((class.Key_Lett == "C_PP") or (class.Key_Lett == "CNST_LSC"))
					"org.xtuml.bp.core.ui.actions.SetTypeOn$u{class.Key_Lett}Action", \
          .elif((class.Key_Lett == "O_ATTR") or (class.Key_Lett == "O_TPARM"))
					"org.xtuml.bp.core.ui.actions.SetTypeOn$u{class.Key_Lett}Action", \
          .elif((class.Key_Lett == "S_BPARM") or (class.Key_Lett == "S_MBR"))
					"org.xtuml.bp.core.ui.actions.SetTypeOn$u{class.Key_Lett}Action", \
          .elif((class.Key_Lett == "S_SPARM") or (class.Key_Lett == "S_UDT"))
					"org.xtuml.bp.core.ui.actions.SetTypeOn$u{class.Key_Lett}Action", \
          .elif(class.Key_Lett == "SM_EVTDI")
					"org.xtuml.bp.core.ui.actions.SetTypeOn$u{class.Key_Lett}Action", \
          .elif((class.Key_Lett == "S_EEEDI") or (class.Key_Lett == "S_EEDI"))
            .// This is not fatal
            .print "Unexpected element type found generating Data type chooser invocation.  class.Key_Lett == ${class.Key_Lett}"
            "unknowntypeAction", \
          .else
            .print "ERROR: Unexpected element type found generating Data type chooser invocation.  class.Key_Lett == ${class.Key_Lett}"
                    "unknowntypeAction", \
          .end if
        .else
            m_propertyDescriptors[d_index] =
                new EnumPropertyDescriptor(
                    "$r{child.categoryName}",
        .if ( spec.NameOnly != "" )
                    "${spec.NameOnly}",
        .else
                    "${child_class.Name}",
        .end if
                    m_$r{child.categoryName}$r{spec.NameOnly}, \
        .end if
readonly);
        m_propertyDescriptors[d_index].setCategory(BridgepointPropertySheetPage.basicCategoryName);
        ++d_index;
      .else
        .select one child related by spec->T_TNS[R1001]
        .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
        .// This is a special case to allow view of S_DT in case of user defined
        .// udt
        .select one parent_node related by spec->T_TNS[R1000]
        .if (parent_node.Key_Lett == "S_UDT")
        if(m_inst.getGen_type() == 0){
        .end if
        for (int i = 0; i < m_$r{child.categoryName}$r{spec.NameOnly}.length; ++i)
        {
            m_propertyDescriptors[d_index] =
                new PropertyDescriptor(
                    "$r{child.categoryName}$r{spec.NameOnly}." + String.valueOf(i),
        .if ( spec.NameOnly != "" )
          .if ( spec.NameOnly == "Specialized Component" )
            .// TODO - SKB - this special case was put in to accomodate a change in ooaofooa_heirarchy.pei.sql
            .// that added multiple traversal paths from component to child component (SP and GP).  Once 
            .// specialized packages are removed, this special case can be removed as well and just leave the
            .// else portion of this block.  The following comment is a flag to allow us to catch this block when
            .// SPs are removed.
            .// PE_PE navigation is present (isInGenericPackage).  Do not remove this comment.
                    "Component");
          .else
                    "${spec.NameOnly}");
          .end if
        .else
                    "${child_class.Name}");
        .end if
            m_propertyDescriptors[d_index].setCategory("${child.categoryName}");
            ++d_index;
        }
        .if (parent_node.Key_Lett == "S_UDT")
        }
        .end if

      .end if
    .end for
  .end if
.end function
.//
.//
.//
.function ref_attr_getpropval
  .param inst_ref_set child_specs  .// T_TPS
  .param integer num_simple_attrs
  .//
  .if ( not_empty child_specs )
        int d_index = ${num_simple_attrs};
    .for each spec in child_specs
      .if ( spec.UserModifiable )
        .select one child related by spec->T_TNS[R1001]
        .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
      // getPropertyValue for combobox for ${child_class.Name}
        if (id.equals("$r{child.categoryName}"))
        {
        .select one parent_node related by spec->T_TNS[R1000]
        .invoke rel_nav = generate_backward_rel_chain_nav(parent_node, spec.ParentChildRelChain, "one", "m_inst", "val")
${rel_nav.body}\
        .select many alternate_children related by spec->T_AC[R1002]
        .assign count = 0;
        .for each achild in alternate_children
          .assign count = count + 1
          .invoke rel_nav = generate_backward_rel_chain_nav(parent_node, achild.ParentChildRelChain, "one", "m_inst", "val${count}")
if(val == null) {
${rel_nav.body}
val = val${count};
}
        .end for
          .invoke gana = get_class_name_accessor(child_class, "val")
        .if ( parent_node.Key_Lett == "O_ATTR" )
          .//
          .// special case for O_ATTR.DT_ID when it's a supertype of O_RATTR
          .// we want to display the referred to type instead of 'same_as<Base_Attribute>'
            ReferentialAttribute_c rattr = ReferentialAttribute_c.getOneO_RATTROnR106((Attribute_c) m_inst);
            if (rattr != null)
            {
              Attribute_c base_attr = Attribute_c.getOneO_ATTROnR106(BaseAttribute_c.getOneO_BATTROnR113(rattr));
              if ( (  (base_attr == null)) )
              {
                return "same_as<Base_Attribute>";
              }
              else {
                DataType_c base_dt = DataType_c.getOneS_DTOnR114(base_attr);
                return base_dt.getName();
              }
            }
            else
            {
                return ${gana.body}();
            }
        .else
        if(val != null)
           return ${gana.body}();
        .end if
        }
      ++d_index;
      .else
        .invoke grrag = get_readonly_ref_attr_getpropval(spec)
${grrag.body}\
      .end if
    .end for
  .end if
.end function
.//
.//
.//
.function get_readonly_ref_attr_getpropval
  .param inst_ref spec
  .//
  .select one parent_node related by spec->T_TNS[R1000]
  .select one child related by spec->T_TNS[R1001]
  .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
  .if (parent_node.Key_Lett == "S_UDT")
       if(m_inst.getGen_type() == 0){
  .end if
        for (int i = 0; i < m_$r{child.categoryName}$r{spec.NameOnly}.length; ++i)
        {
            if (m_propertyDescriptors[d_index].getId().equals(id))
            {
    .invoke gpcn = get_property_class_name( child, child_class )
                return new ${gpcn.body}(m_$r{child.categoryName}$r{spec.NameOnly}[i]);
                }
            ++d_index;
                        }
  .if (parent_node.Key_Lett == "S_UDT")
                        }
  .end if

.end function
.//
.//
.//
.function ref_attr_setpropval
  .param inst_ref_set child_specs  .// T_TPS
  .param integer num_simple_attrs
  .param string val_changed_var
  .param inst_ref class  
  .param string parent_class_name
  .param string trans_name_var
  .param string modelroot
  .//
  .// Calling code assumes that if attr_body is empty,
  .// there is nothing to do
  .//
  .assign decl_output = false
  .if ( not_empty child_specs )
    .for each spec in child_specs
      .if ( spec.UserModifiable )
        .if ( not decl_output )
        int d_index = ${num_simple_attrs};
          .assign decl_output = true
        .end if
        .select one child related by spec->T_TNS[R1001]
        if (id.equals("$r{child.categoryName}"))
        {
        .if ( child.Key_Lett != "S_DT" )
            ${val_changed_var} = m_inst.Modify$rl{spec.NameOnly}(
                m_$r{child.categoryName}$r{spec.NameOnly}[((Integer) value).intValue()] );
        .else
          .// special case for DataType (S_DT) child
          .select one parent_node related by spec->T_TNS[R1000]
          .invoke rel_nav = generate_backward_rel_chain_nav(parent_node, spec.ParentChildRelChain, "one", "m_inst", "val")
${rel_nav.body}\
          .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
          .invoke child_class_name = get_class_name(child_class)
          .assign set_var_name = "set${info.unique_num}"
           if ( ! value.equals(val.getName()) )
           {
            .if(spec.CrossModelRootBoundary)
// To be revisited                   Object[] roots = m_inst.getModelRoot().getModelRoots("${spec.ModelRootType}", "${spec.ExcludedModelRootType}");
                    Object[] rootsOfDataTypePackages = m_inst.getModelRoot().getModelRoots("${spec.ModelRootType}",  "${spec.ExcludedModelRootType}");   
                    Object[] rootsOfPackages= m_inst.getModelRoot().getModelRoots("Package",  "${spec.ExcludedModelRootType}");
                    List<Object> bothRoots = new ArrayList<Object>(rootsOfDataTypePackages.length + rootsOfPackages.length); 
                    Collections.addAll(bothRoots , rootsOfDataTypePackages);
                    Collections.addAll(bothRoots , rootsOfPackages);
                    Object[] roots = bothRoots.toArray();
                    
                     ArrayList<${child_class_name.body}> list = new ArrayList<${child_class_name.body}>();
                 for(int i = 0; i < roots.length; i++) {
                    ${child_class_name.body}[] children = ${child_class_name.body}.$Cr{child_class.Name}Instances((ModelRoot) roots[i]);
                            for(int j = 0; j < children.length; j++) {
                                list.add(children[j]);
                            }
                        }
              ${child_class_name.body} [] ${set_var_name} = list.toArray(new ${child_class_name.body}[list.size()]);
            .else
                          ${child_class_name.body} [] ${set_var_name}_1 = new ${child_class_name.body}[0];
                          ${child_class_name.body} [] ${set_var_name}_2 = new ${child_class_name.body}[0];
                          .assign queryName = set_var_name + "_2"       
                          .invoke generic_package = generic_package_query( queryName )
                          ${generic_package.body}
                          else {
                          .if(class.Key_Lett == "S_SYNC")   .//Function
        Domain_c domain = Domain_c.getOneS_DOMOnR23((${parent_class_name}) m_inst);
                          .elif(class.Key_Lett == "S_SPARM")    .//Function Parameter
        Domain_c domain = Domain_c.getOneS_DOMOnR23(Function_c
                ..getOneS_SYNCOnR24((${parent_class_name}) m_inst));
                          .elif(class.Key_Lett == "O_TFR")  .//Operation
        Domain_c domain = Domain_c.getOneS_DOMOnR1(Subsystem_c
                ..getOneS_SSOnR2(ModelClass_c.getOneO_OBJOnR115((${parent_class_name}) m_inst)));
                          .elif(class.Key_Lett == "O_TPARM")    .//Operation Parameter
        Domain_c domain = Domain_c.getOneS_DOMOnR1(Subsystem_c
                ..getOneS_SSOnR2(ModelClass_c.getOneO_OBJOnR115(Operation_c
                        ..getOneO_TFROnR117((${parent_class_name}) m_inst))));
                          .elif(class.Key_Lett == "SM_EVTDI")       .//StateMachineEventDataItem
        StateMachine_c v_sm = StateMachine_c.getOneSM_SMOnR516((${parent_class_name}) m_inst);
        
        ModelClass_c v_clazz = ModelClass_c
                ..getOneO_OBJOnR519(ClassStateMachine_c.getOneSM_ASMOnR517(v_sm));

        if (((v_clazz == null))) {
            v_clazz = ModelClass_c.getOneO_OBJOnR518(InstanceStateMachine_c
                ..getOneSM_ISMOnR517(v_sm));
        }

        Domain_c domain = Domain_c.getOneS_DOMOnR1(Subsystem_c
                ..getOneS_SSOnR2(v_clazz));
                          .elif(class.Key_Lett == "O_ATTR") .//Attribute
        Domain_c domain = Domain_c.getOneS_DOMOnR1(Subsystem_c
                ..getOneS_SSOnR2(ModelClass_c.getOneO_OBJOnR102((${parent_class_name}) m_inst)));
                          .elif(class.Key_Lett == "S_BRG")  .//Bridge
        Domain_c domain = Domain_c.getOneS_DOMOnR8(ExternalEntity_c
                ..getOneS_EEOnR19((${parent_class_name}) m_inst));
                          .elif(class.Key_Lett == "S_BPARM")    .//Bridge Parameter
        Domain_c domain = Domain_c.getOneS_DOMOnR8(ExternalEntity_c
                ..getOneS_EEOnR19(Bridge_c.getOneS_BRGOnR21((${parent_class_name}) m_inst)));
                          .elif(class.Key_Lett == "S_EEEDI")    .//ExternalEntityEventDataItem
        Domain_c domain = Domain_c.getOneS_DOMOnR8(ExternalEntity_c
                ..getOneS_EEOnR12((${parent_class_name}) m_inst));
                          .elif(class.Key_Lett == "S_EEDI") .//ExternalEntityDataItem
        Domain_c domain = Domain_c.getOneS_DOMOnR8(ExternalEntity_c
                ..getOneS_EEOnR11((${parent_class_name}) m_inst));
                          .elif(class.Key_Lett == "S_MBR")  .//StructureMember
        Domain_c domain = Domain_c.getOneS_DOMOnR14(DataType_c
                ..getOneS_DTOnR45((${parent_class_name}) m_inst));          
                          .else
        Domain_c domain = Domain_c.DomainInstance((Ooaofooa)(m_inst.getModelRoot()));           
                          .end if
        ${set_var_name}_1 = ${child_class_name.body}.getManyS_DTsOnR14(domain);
        ${set_var_name}_2 = ${child_class_name.body}.getManyS_DTsOnR4401(SystemDatatypeInPackage_c
                            ..getManySLD_SDINPsOnR4402(SystemModel_c
                                    ..getManyS_SYSsOnR4606(ComponentPackage_c
                                            ..getManyCP_CPsOnR4608(Component_c
                                                    ..getManyC_CsOnR4204(DomainAsComponent_c
                                                            ..getManyCN_DCsOnR4204(domain))))));
              .// special case for udts and mbrs
              .// if not defined at the domain
              .// level they need to access the
              .// system level dts through a different
              .// traversal
                          .if(parent_node.Key_Lett == "S_UDT")
        if(domain == null) {
                    ${set_var_name}_2 = DataType_c
                            ..getManyS_DTsOnR4401(SystemDatatypeInPackage_c
                                    ..getManySLD_SDINPsOnR4402(SystemModel_c
                                            ..getManyS_SYSsOnR4402(SystemDatatypeInPackage_c
                                                    ..getManySLD_SDINPsOnR4401(DataType_c
                                                            ..getManyS_DTsOnR17(m_inst)))));
        }
            .elif(parent_node.Key_Lett == "S_MBR")
        if(domain == null) {
                    ${set_var_name}_2 = DataType_c
                        ..getManyS_DTsOnR4401(SystemDatatypeInPackage_c
                                ..getManySLD_SDINPsOnR4402(SystemModel_c
                                        ..getManyS_SYSsOnR4402(SystemDatatypeInPackage_c
                                                ..getManySLD_SDINPsOnR4401(DataType_c
                                                        ..getManyS_DTsOnR17(StructuredDataType_c
                                                                ..getManyS_SDTsOnR44(m_inst))))));
        }
                        .end if
                          } // end isInGenericPackage
          // copy the system level data types into the
          // domain level data types array
					DataType_c[] ${set_var_name}_3 = new DataType_c[0];
					if (((SystemModel_c) m_inst.getRoot()).getUseglobals() == true) {
					  ${set_var_name}_3 = DataType_c.
							getManyS_DTsOnR8001(PackageableElement_c.
									getManyPE_PEsOnR9100(GlobalElementInSystem_c.
											getManyG_EISsOnR9100((SystemModel_c) this.m_inst.getRoot())));
					}
                    ${child_class_name.body}[] ${set_var_name} = new ${child_class_name.body}[${set_var_name}_1.length + ${set_var_name}_2.length + + ${set_var_name}_3.length];
                    System.arraycopy(${set_var_name}_1, 0, ${set_var_name}, 0, ${set_var_name}_1.length);
                    System.arraycopy(${set_var_name}_2, 0, ${set_var_name}, ${set_var_name}_1.length, ${set_var_name}_2.length);
                    System.arraycopy(${set_var_name}_3, 0, ${set_var_name}, ${set_var_name}_1.length + ${set_var_name}_2.length, ${set_var_name}_3.length);
            .end if
          .select many alternate_children related by spec->T_AC[R1002]
          .for each achild in alternate_children
            .if(achild.CrossModelRootBoundary)
//To be revisited                    Object[] roots = m_inst.getModelRoot().getModelRoots("${achild.ModelRootType}", "${achild.ExcludedModelRootType}");
                    
                    Object[] rootsOfDataTypePackages = m_inst.getModelRoot().getModelRoots("${achild.ModelRootType}", "${achild.ExcludedModelRootType}");    
                    Object[] rootsOfPackages= m_inst.getModelRoot().getModelRoots("Package", "${achild.ExcludedModelRootType}");
                    List<Object> bothRoots = new ArrayList<Object>(rootsOfDataTypePackages.length + rootsOfPackages.length); 
                    Collections.addAll(bothRoots , rootsOfDataTypePackages);
                    Collections.addAll(bothRoots , rootsOfPackages);
                    Object[] roots = bothRoots.toArray();
                    
                     ArrayList<${child_class_name.body}> list = new ArrayList<${child_class_name.body}>();
                 for(int i = 0; i < roots.length; i++) {
                    ${child_class_name.body}[] children = ${child_class_name.body}.$Cr{child_class.Name}Instances((ModelRoot) roots[i]);
                            for(int j = 0; j < children.length; j++) {
                                list.add(children[j]);
                            }
                        }
                ${set_var_name} = list.toArray(new ${child_class_name.body}[list.size()]);
                        .else
        ${set_var_name} = ${child_class_name.body}.$Cr{child_class.Name}Instances((${modelroot})(m_inst.getModelRoot()));
            .end if
          .end for
          .invoke gana = get_class_name_accessor(child_class, "${set_var_name}[i]")
            for (int i = 0; i < ${set_var_name}.length; ++i )
            {
                if ( value.equals(${gana.body}()) )
                {
                        ${trans_name_var} = "Change in property: '${spec.NameOnly}' of ${class.Name}"; //$$NON-NLS-1$$
                        tr = tm.startTransaction(${trans_name_var}, ${modelroot}.getDefaultInstance());
          .invoke nav = parse_chain( spec.ParentChildRelChain, "forward")
          .if (not_empty nav.rel)
            .if ( nav.remainder == "" )
              .// there's only one link; implement directly
              .assign rel_inst = nav.rel
                    m_inst.unrelateAcrossR${rel_inst.Numb}From(val);
                    m_inst.relateAcrossR${rel_inst.Numb}To(${set_var_name}[i]);
            .else
                    m_inst.Change$rl{spec.NameOnly}(${gana.body}());
            .end if
          .else
            .print "ERROR: Unknown relationship ending parse chain ${spec.ParentChildRelChain}"
            .exit 100
          .end if
                    ${val_changed_var} = true;
                    break;
                }
            }
          }
        .end if
        }
        ++d_index;
      .end if
    .end for
  .end if
.end function
.//
.//
.//
.function create_class_property_source
  .param inst_ref node   .// T_TNS
  .param string package
  .param string modelroot
  .//
  .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
  .invoke gpcn = get_property_class_name( node, class )
  .assign attr_class_name = "${gpcn.body}"
  .invoke arch_class_name = get_class_name(class)
  .invoke gfh = get_file_header(attr_class_name)
${gfh.body}
package ${package};
  .select many attrs related by class->O_ATTR[R102]
  .invoke sad = simple_attr_descriptors(attrs)
  .select many child_specs related by node->T_TPS[R1000] where (selected.ExcludedFromProperties == false)
  .invoke rad = referential_attr_descriptors(arch_class_name.body, class, child_specs, sad.num_attr, modelroot)
  .if ( rad.needs_imports )
import java.text.Collator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Vector;

  .end if
import org.eclipse.ui.views.properties.*;

.if(modelroot == "Ooaofgraphics")
import org.xtuml.bp.ui.canvas.*;
import org.xtuml.bp.ui.properties.*;
.end if
import org.xtuml.bp.core.*;
import org.xtuml.bp.core.common.*;
import org.xtuml.bp.core.sorter.MetadataSortingManager;
import org.xtuml.bp.core.ui.cells.editors.*;
import org.xtuml.bp.core.util.DimensionsUtil;

public class ${attr_class_name} implements IPropertySource
{
    private ${arch_class_name.body} m_inst;
${rad.instance_decls}\
    private PropertyDescriptor[] m_propertyDescriptors;
${sad.enum_decls}
	MetadataSortingManager sorter = MetadataSortingManager.createDefault();

    public ${attr_class_name}(${arch_class_name.body} inst)
    {
        m_inst = inst;
    }
    /* (non-Javadoc)
     * @see org.eclipse.ui.views.properties.IPropertySource#getEditableValue()
     */
    public Object getEditableValue()
    {
        return this;
    }

    /* (non-Javadoc)
     * @see org.eclipse.ui.views.properties.IPropertySource#isPropertySet(java.lang.Object)
     */
    public boolean isPropertySet(Object id)
    {
        return false;
    }

    /* (non-Javadoc)
     * @see org.eclipse.ui.views.properties.IPropertySource#resetPropertyValue(java.lang.Object)
     */
    public void resetPropertyValue(Object id)
    {
        // do nothing
    }

    public String toString()
    {
  .invoke gana = get_class_name_accessor(class, "m_inst")
       return ${gana.body}();
    }

    /* (non-Javadoc)
     * @see org.eclipse.ui.views.properties.IPropertySource#getPropertyDescriptors()
     */
    public IPropertyDescriptor[] getPropertyDescriptors()
    {
    .//In U.tests a deferred SelectedChnageEvent may cause this
    if(m_inst == null || m_inst.isOrphaned())
        return new IPropertyDescriptor[0];
  .assign is_special_case = false
  .if ( not_empty child_specs )
      int num_children = 0;
      .if (class.Key_Lett == "S_CDT")
        .assign is_special_case = true
      .else
${rad.instance_init}\
      .end if
  .end if
  .assign total_d = rad.num_modifiable + sad.num_attr
        if (m_propertyDescriptors == null
  .if ( not_empty child_specs )
            || ${total_d} + num_children != m_propertyDescriptors.length)
  .else
            || ${total_d} != m_propertyDescriptors.length)
  .end if
        {
            m_propertyDescriptors =
  .if ( not_empty child_specs )
                new PropertyDescriptor[${total_d} + num_children];
  .else
                new PropertyDescriptor[${total_d}];
  .end if
            boolean readonly = false;

${sad.body}
  .if (not is_special_case)
${rad.body}\
  .end if
        }
  .if ( class.AdapterName == "IProject" )
        if (m_propertyDescriptors.length > 0)
          m_propertyDescriptors[0].setValidator(new $r{class.Name}NameValidator());
  .elif ( class.AdapterName == "IFile" )
        if (m_propertyDescriptors.length > 0)
          m_propertyDescriptors[0].setValidator(new $r{class.Name}NameValidator());
  .end if
        return m_propertyDescriptors;
    }

    /* (non-Javadoc)
        * @see org.eclipse.ui.views.properties.IPropertySource#getPropertyValue(java.lang.Object)
        */
    public Object getPropertyValue(Object id)
    {
    if (m_inst.isOrphaned()) {
        return "";
    }
  .invoke sa_getval = simple_attr_getpropval( attrs )
${sa_getval.body}\
  .invoke ra_getval = ref_attr_getpropval( child_specs, sad.num_attr )
${ra_getval.body}\
        return null;
    }

    /* (non-Javadoc)
     * @see org.eclipse.ui.views.properties.IPropertySource#setPropertyValue(java.lang.Object, java.lang.Object)
     */
    public void setPropertyValue(Object id, Object value)
    {
  .assign val_changed_var = "value_changed"
  .assign trans_name_var = "trans_name"
  .invoke sa_setval = simple_attr_setpropval(attrs, class, val_changed_var, trans_name_var , modelroot)
  .invoke ra_setval = ref_attr_setpropval( child_specs, sad.num_attr, val_changed_var, class, arch_class_name.body, trans_name_var, modelroot )
  .if ((sa_setval.body != "") or (ra_setval.body != ""))
        boolean ${val_changed_var} = false;
        String ${trans_name_var} = "";
        Transaction tr = null;
        ${modelroot} modelRoot = (${modelroot})m_inst.getModelRoot();
        TransactionManager tm = TransactionManager.getSingleton();
        try {
${sa_setval.body}

${ra_setval.body}
    // catch all exceptions and cancel the transaction
        } catch (Exception e) {
            // this can be null if there was
            // an exception starting the
            // transaction
            if(tr != null) {
                tm.cancelTransaction(tr, e);
                tr = null;
            }
            CorePlugin.logError("Transaction: " + trans_name + " could not complete", e);
        }
        if (tr != null){
            if ( ${val_changed_var} )
                tm.endTransaction(tr);
            else
                tm.cancelTransaction(tr);
        }
  .end if
    }
}
.end function
.//
.//
.function create_name_validator
  .param inst_ref node
  .param string package
  .//
  .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
  .assign attr_class_name = ""
  .if ( (class.AdapterName == "IProject") or (class.AdapterName == "IFile") )
    .invoke arch_class_name = get_class_name(class)
    .assign attr_class_name = "$r{class.Name}NameValidator"
    .invoke gfh = get_file_header(attr_class_name)
${gfh.body}
package ${package};

import org.eclipse.core.runtime.IStatus;
import org.eclipse.jface.viewers.ICellEditorValidator;
import org.eclipse.jface.viewers.IStructuredSelection;

import org.xtuml.bp.core.${arch_class_name.body};
import org.xtuml.bp.core.ui.RenameAction;
import org.xtuml.bp.core.ui.Selection;

public class ${attr_class_name} implements ICellEditorValidator {

    /*
     * (non-Javadoc)
     *
     * @see org.eclipse.jface.viewers.ICellEditorValidator#isValid(java.lang.Object)
     */
    public String isValid(Object value) {
        String New_name = (String) value;
        final IStructuredSelection structuredSelection = Selection.getInstance().getStructuredSelection();
        if (structuredSelection.size() > 1) {
            return "Can't happen: selection size > 1";
        }
        Object context = structuredSelection.getFirstElement();
        if (!(context instanceof ${arch_class_name.body}) ) {
            return "Can't happen: ${node.CategoryName} not selected";
        }
        ${arch_class_name.body} element = null;
        if (context instanceof ${arch_class_name.body}) {
            element = (${arch_class_name.body}) context;
        }
    .if ( class.AdapterName == "IProject" )
        IStatus name_ok = RenameAction.validateSystemModelName(element, New_name);
    .else
        IStatus name_ok = RenameAction.validateComponentName(element, New_name);
  .end if
        if ( !name_ok.isOK() ){
            return name_ok.getMessage();
        }
        return null;
    }

}
  .end if
.end function
.//
.//
.function generate_model_property_source_provider
  .param inst_ref_set node_set
  .param string package
  .param string modelroot
  .//
  .assign attr_class_name = "ModelPropertySourceProvider"
  .invoke gfh = get_file_header(attr_class_name)
${gfh.body}
package ${package};

import org.eclipse.ui.views.properties.IPropertySource;
import org.eclipse.ui.views.properties.IPropertySourceProvider;

import org.xtuml.bp.core.*;
.if(modelroot == "Ooaofgraphics")
import org.xtuml.bp.ui.canvas.*;
.end if

public class ${attr_class_name} implements IPropertySourceProvider
{

    /* (non-Javadoc)
     * @see org.eclipse.ui.views.properties.IPropertySourceProvider#getPropertySource(java.lang.Object)
     */
    public IPropertySource getPropertySource(Object object)
    {
        if (object instanceof IPropertySource) {
            return (IPropertySource)object;
        }
  .for each node in node_set
    .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke arch_class_name = get_class_name(class)
        else if ( object instanceof ${arch_class_name.body} )
    .invoke gpcn = get_property_class_name( node, class )
            return new ${gpcn.body}((${arch_class_name.body})object);
  .end for
        else
            return null;
    }
}
.end function
.//
.//  Main code
.//
.assign path = "org/xtuml/bp/ui/properties"
.invoke source_path = GET_ENV_VAR( "SOURCE_PATH" )
.if(source_path.result != "")
  .assign path = source_path.result
.end if
.assign rel_path = "src/${path}"
.assign package_initial = "org.xtuml.bp.ui.properties"
.invoke source_package = GET_ENV_VAR( "SOURCE_PACKAGE" )
.if(source_package.result != "")
  .assign package_initial = source_package.result
.end if
.assign root = "Ooaofooa"
.invoke modelroot = GET_ENV_VAR( "MODEL_ROOT" )
.if(modelroot.result != "")
  .assign root = modelroot.result 
.end if
.select many nodes from instances of T_TNS
.for each tree_node in nodes
  .invoke ccps= create_class_property_source( tree_node, package_initial, root )
${ccps.body}\
  .emit to file "${rel_path}/${ccps.class_name}.java"
.end for
.//
.for each tree_node in nodes
  .invoke cnv= create_name_validator( tree_node, package_initial )
  .if ( cnv.class_name != "" )
${cnv.body}\
    .emit to file "${rel_path}/${cnv.class_name}.java"
  .end if
.end for
.//
.invoke gmpsp = generate_model_property_source_provider(nodes, package_initial, root)
${gmpsp.body}\
.emit to file "${rel_path}/${gmpsp.class_name}.java"
.//
