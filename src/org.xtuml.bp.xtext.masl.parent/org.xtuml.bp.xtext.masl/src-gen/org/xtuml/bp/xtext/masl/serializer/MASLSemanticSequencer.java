/*
 * generated by Xtext 2.39.0
 */
package org.xtuml.bp.xtext.masl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtuml.bp.xtext.masl.masl.behavior.ActionCall;
import org.xtuml.bp.xtext.masl.masl.behavior.AdditiveExp;
import org.xtuml.bp.xtext.masl.masl.behavior.AssignStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.AttributeReferential;
import org.xtuml.bp.xtext.masl.masl.behavior.BehaviorPackage;
import org.xtuml.bp.xtext.masl.masl.behavior.BooleanLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.CancelTimerStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.CaseAlternative;
import org.xtuml.bp.xtext.masl.masl.behavior.CaseOthers;
import org.xtuml.bp.xtext.masl.masl.behavior.CaseStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.CharacterLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.CharacteristicCall;
import org.xtuml.bp.xtext.masl.masl.behavior.CodeBlock;
import org.xtuml.bp.xtext.masl.masl.behavior.ConsoleLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.CreateArgument;
import org.xtuml.bp.xtext.masl.masl.behavior.CreateExpression;
import org.xtuml.bp.xtext.masl.masl.behavior.DefaultExceptionHandler;
import org.xtuml.bp.xtext.masl.masl.behavior.DelayStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.DeleteStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.DurationLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.ElseBlock;
import org.xtuml.bp.xtext.masl.masl.behavior.ElsifBlock;
import org.xtuml.bp.xtext.masl.masl.behavior.EndlLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.Equality;
import org.xtuml.bp.xtext.masl.masl.behavior.EraseStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.ExceptionHandler;
import org.xtuml.bp.xtext.masl.masl.behavior.ExitStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.FileNameLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.FindExpression;
import org.xtuml.bp.xtext.masl.masl.behavior.FlushLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.ForStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.GenerateStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.IfStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.IndexedExpression;
import org.xtuml.bp.xtext.masl.masl.behavior.IntegerLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.LineNoLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.LinkExpression;
import org.xtuml.bp.xtext.masl.masl.behavior.LogicalAnd;
import org.xtuml.bp.xtext.masl.masl.behavior.LogicalOr;
import org.xtuml.bp.xtext.masl.masl.behavior.LogicalXor;
import org.xtuml.bp.xtext.masl.masl.behavior.LoopVariable;
import org.xtuml.bp.xtext.masl.masl.behavior.MultExp;
import org.xtuml.bp.xtext.masl.masl.behavior.NavigateExpression;
import org.xtuml.bp.xtext.masl.masl.behavior.NullLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.RaiseStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.RangeExpression;
import org.xtuml.bp.xtext.masl.masl.behavior.RealLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.RelationalExp;
import org.xtuml.bp.xtext.masl.masl.behavior.ReturnStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.ScheduleStatement;
import org.xtuml.bp.xtext.masl.masl.behavior.SimpleFeatureCall;
import org.xtuml.bp.xtext.masl.masl.behavior.SortOrder;
import org.xtuml.bp.xtext.masl.masl.behavior.SortOrderComponent;
import org.xtuml.bp.xtext.masl.masl.behavior.SortOrderFeature;
import org.xtuml.bp.xtext.masl.masl.behavior.Statement;
import org.xtuml.bp.xtext.masl.masl.behavior.StreamExpression;
import org.xtuml.bp.xtext.masl.masl.behavior.StringLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.StructureAggregateExpression;
import org.xtuml.bp.xtext.masl.masl.behavior.TerminatorActionCall;
import org.xtuml.bp.xtext.masl.masl.behavior.ThisLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.TimestampLiteral;
import org.xtuml.bp.xtext.masl.masl.behavior.UnaryExp;
import org.xtuml.bp.xtext.masl.masl.behavior.VariableDeclaration;
import org.xtuml.bp.xtext.masl.masl.behavior.WhileStatement;
import org.xtuml.bp.xtext.masl.masl.structure.AssocRelationshipDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.AttributeDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.BuiltinLibraryDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.Characteristic;
import org.xtuml.bp.xtext.masl.masl.structure.DomainDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.DomainServiceDeclaration;
import org.xtuml.bp.xtext.masl.masl.structure.DomainServiceDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.EventDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.ExceptionDeclaration;
import org.xtuml.bp.xtext.masl.masl.structure.IdentifierDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.MaslModel;
import org.xtuml.bp.xtext.masl.masl.structure.ObjectDeclaration;
import org.xtuml.bp.xtext.masl.masl.structure.ObjectDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.ObjectServiceDeclaration;
import org.xtuml.bp.xtext.masl.masl.structure.ObjectServiceDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.Pragma;
import org.xtuml.bp.xtext.masl.masl.structure.PragmaValue;
import org.xtuml.bp.xtext.masl.masl.structure.ProjectDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.RangeTypeReference;
import org.xtuml.bp.xtext.masl.masl.structure.RegularRelationshipDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.RelationshipEnd;
import org.xtuml.bp.xtext.masl.masl.structure.RelationshipNavigation;
import org.xtuml.bp.xtext.masl.masl.structure.StateDeclaration;
import org.xtuml.bp.xtext.masl.masl.structure.StateDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.StructurePackage;
import org.xtuml.bp.xtext.masl.masl.structure.SubtypeRelationshipDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.TerminatorDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.TerminatorServiceDeclaration;
import org.xtuml.bp.xtext.masl.masl.structure.TerminatorServiceDefinition;
import org.xtuml.bp.xtext.masl.masl.structure.TransitionOption;
import org.xtuml.bp.xtext.masl.masl.structure.TransitionRow;
import org.xtuml.bp.xtext.masl.masl.structure.TransitionTable;
import org.xtuml.bp.xtext.masl.masl.structure.TypeParameter;
import org.xtuml.bp.xtext.masl.masl.types.ArrayTypeReference;
import org.xtuml.bp.xtext.masl.masl.types.BagTypeReference;
import org.xtuml.bp.xtext.masl.masl.types.BuiltinTypeDeclaration;
import org.xtuml.bp.xtext.masl.masl.types.ConstrainedArrayTypeReference;
import org.xtuml.bp.xtext.masl.masl.types.ConstrainedTypeDefinition;
import org.xtuml.bp.xtext.masl.masl.types.DeltaConstraint;
import org.xtuml.bp.xtext.masl.masl.types.DictionaryTypeReference;
import org.xtuml.bp.xtext.masl.masl.types.DigitsConstraint;
import org.xtuml.bp.xtext.masl.masl.types.EnumerationTypeDefinition;
import org.xtuml.bp.xtext.masl.masl.types.Enumerator;
import org.xtuml.bp.xtext.masl.masl.types.InstanceTypeReference;
import org.xtuml.bp.xtext.masl.masl.types.NamedTypeReference;
import org.xtuml.bp.xtext.masl.masl.types.RangeConstraint;
import org.xtuml.bp.xtext.masl.masl.types.SequenceTypeReference;
import org.xtuml.bp.xtext.masl.masl.types.SetTypeReference;
import org.xtuml.bp.xtext.masl.masl.types.StructureComponentDefinition;
import org.xtuml.bp.xtext.masl.masl.types.StructureTypeDefinition;
import org.xtuml.bp.xtext.masl.masl.types.TypeDeclaration;
import org.xtuml.bp.xtext.masl.masl.types.TypeForwardDeclaration;
import org.xtuml.bp.xtext.masl.masl.types.TypesPackage;
import org.xtuml.bp.xtext.masl.masl.types.UnconstrainedArrayDefinition;
import org.xtuml.bp.xtext.masl.services.MASLGrammarAccess;

@SuppressWarnings("all")
public class MASLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MASLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BehaviorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BehaviorPackage.ACTION_CALL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_PostfixExpression(context, (ActionCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_PostfixExpression_PragmaList(context, (ActionCall) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.ADDITIVE_EXP:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_AdditiveExp(context, (AdditiveExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_AdditiveExp_PragmaList(context, (AdditiveExp) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.ASSIGN_STATEMENT:
				if (rule == grammarAccess.getAssignStatementRule()) {
					sequence_AssignStatement(context, (AssignStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_AssignStatement_PragmaList(context, (AssignStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.ATTRIBUTE_REFERENTIAL:
				sequence_AttributeReferential(context, (AttributeReferential) semanticObject); 
				return; 
			case BehaviorPackage.BOOLEAN_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getBooleanLiteralRule()) {
					sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_BooleanLiteral_PragmaList(context, (BooleanLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.CANCEL_TIMER_STATEMENT:
				if (rule == grammarAccess.getCancelTimerStatementRule()) {
					sequence_CancelTimerStatement(context, (CancelTimerStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_CancelTimerStatement_PragmaList(context, (CancelTimerStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.CASE_ALTERNATIVE:
				sequence_CaseAlternative(context, (CaseAlternative) semanticObject); 
				return; 
			case BehaviorPackage.CASE_OTHERS:
				sequence_CaseOthers(context, (CaseOthers) semanticObject); 
				return; 
			case BehaviorPackage.CASE_STATEMENT:
				if (rule == grammarAccess.getCaseStatementRule()) {
					sequence_CaseStatement(context, (CaseStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_CaseStatement_PragmaList(context, (CaseStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.CHARACTER_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCharacterLiteralRule()) {
					sequence_CharacterLiteral(context, (CharacterLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_CharacterLiteral_PragmaList(context, (CharacterLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.CHARACTERISTIC_CALL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_PostfixExpression(context, (CharacteristicCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()) {
					sequence_PostfixExpression_PostfixNoActionCallExpression(context, (CharacteristicCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_PostfixExpression_PragmaList(context, (CharacteristicCall) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.CODE_BLOCK:
				if (rule == grammarAccess.getCodeBlockStatementRule()
						|| rule == grammarAccess.getCodeBlockRule()) {
					sequence_CodeBlock(context, (CodeBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_CodeBlock_PragmaList(context, (CodeBlock) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.CONSOLE_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getConsoleLiteralRule()) {
					sequence_ConsoleLiteral(context, (ConsoleLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_ConsoleLiteral_PragmaList(context, (ConsoleLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.CREATE_ARGUMENT:
				sequence_CreateArgument(context, (CreateArgument) semanticObject); 
				return; 
			case BehaviorPackage.CREATE_EXPRESSION:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getCreateExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_CreateExpression(context, (CreateExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_CreateExpression_PragmaList(context, (CreateExpression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.DEFAULT_EXCEPTION_HANDLER:
				sequence_DefaultExceptionHandler(context, (DefaultExceptionHandler) semanticObject); 
				return; 
			case BehaviorPackage.DELAY_STATEMENT:
				if (rule == grammarAccess.getDelayStatementRule()) {
					sequence_DelayStatement(context, (DelayStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_DelayStatement_PragmaList(context, (DelayStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.DELETE_STATEMENT:
				if (rule == grammarAccess.getDeleteStatementRule()) {
					sequence_DeleteStatement(context, (DeleteStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_DeleteStatement_PragmaList(context, (DeleteStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.DURATION_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getDurationLiteralRule()) {
					sequence_DurationLiteral(context, (DurationLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_DurationLiteral_PragmaList(context, (DurationLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.ELSE_BLOCK:
				sequence_ElseBlock(context, (ElseBlock) semanticObject); 
				return; 
			case BehaviorPackage.ELSIF_BLOCK:
				sequence_ElsifBlock(context, (ElsifBlock) semanticObject); 
				return; 
			case BehaviorPackage.ENDL_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getEndlLiteralRule()) {
					sequence_EndlLiteral(context, (EndlLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_EndlLiteral_PragmaList(context, (EndlLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.EQUALITY:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_Equality(context, (Equality) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Equality_PragmaList(context, (Equality) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFindConditionRule()
						|| rule == grammarAccess.getFindLogicalOrRule()
						|| action == grammarAccess.getFindLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalXorRule()
						|| action == grammarAccess.getFindLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalAndRule()
						|| action == grammarAccess.getFindLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getFindPrimaryRule()
						|| rule == grammarAccess.getFindUnaryRule()
						|| rule == grammarAccess.getFindEqualityRule()) {
					sequence_FindEquality(context, (Equality) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.ERASE_STATEMENT:
				if (rule == grammarAccess.getEraseStatementRule()) {
					sequence_EraseStatement(context, (EraseStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_EraseStatement_PragmaList(context, (EraseStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.EXCEPTION_HANDLER:
				sequence_ExceptionHandler(context, (ExceptionHandler) semanticObject); 
				return; 
			case BehaviorPackage.EXIT_STATEMENT:
				if (rule == grammarAccess.getExitStatementRule()) {
					sequence_ExitStatement(context, (ExitStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_ExitStatement_PragmaList(context, (ExitStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.FILE_NAME_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFileNameLiteralRule()) {
					sequence_FileNameLiteral(context, (FileNameLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_FileNameLiteral_PragmaList(context, (FileNameLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.FIND_EXPRESSION:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getFindExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_FindExpression(context, (FindExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_FindExpression_PragmaList(context, (FindExpression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.FLUSH_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFlushLiteralRule()) {
					sequence_FlushLiteral(context, (FlushLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_FlushLiteral_PragmaList(context, (FlushLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.FOR_STATEMENT:
				if (rule == grammarAccess.getForStatementRule()) {
					sequence_ForStatement(context, (ForStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_ForStatement_PragmaList(context, (ForStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.GENERATE_STATEMENT:
				if (rule == grammarAccess.getGenerateStatementRule()) {
					sequence_GenerateStatement(context, (GenerateStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_GenerateStatement_PragmaList(context, (GenerateStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.IF_STATEMENT:
				if (rule == grammarAccess.getIfStatementRule()) {
					sequence_IfStatement(context, (IfStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_IfStatement_PragmaList(context, (IfStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.INDEXED_EXPRESSION:
				if (rule == grammarAccess.getFindConditionRule()
						|| rule == grammarAccess.getFindLogicalOrRule()
						|| action == grammarAccess.getFindLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalXorRule()
						|| action == grammarAccess.getFindLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalAndRule()
						|| action == grammarAccess.getFindLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getFindPrimaryRule()
						|| rule == grammarAccess.getFindUnaryRule()
						|| rule == grammarAccess.getFindEqualityRule()
						|| action == grammarAccess.getFindEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getFindRelationExpRule()
						|| action == grammarAccess.getFindRelationExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getFindNameRule()
						|| action == grammarAccess.getFindNameAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getFindNameAccess().getIndexedExpressionReceiverAction_1_1_0()) {
					sequence_FindName(context, (IndexedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_PostfixExpression(context, (IndexedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()) {
					sequence_PostfixExpression_PostfixNoActionCallExpression(context, (IndexedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_PostfixExpression_PragmaList(context, (IndexedExpression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.INTEGER_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getIntegerLiteralRule()) {
					sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_IntegerLiteral_PragmaList(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.LINE_NO_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getLineNoLiteralRule()) {
					sequence_LineNoLiteral(context, (LineNoLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_LineNoLiteral_PragmaList(context, (LineNoLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.LINK_EXPRESSION:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_LinkExpression(context, (LinkExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_LinkExpression_PragmaList(context, (LinkExpression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.LOGICAL_AND:
				if (rule == grammarAccess.getFindConditionRule()
						|| rule == grammarAccess.getFindLogicalOrRule()
						|| action == grammarAccess.getFindLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalXorRule()
						|| action == grammarAccess.getFindLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalAndRule()
						|| action == grammarAccess.getFindLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getFindPrimaryRule()
						|| rule == grammarAccess.getFindUnaryRule()) {
					sequence_FindLogicalAnd(context, (LogicalAnd) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_LogicalAnd(context, (LogicalAnd) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_LogicalAnd_PragmaList(context, (LogicalAnd) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.LOGICAL_OR:
				if (rule == grammarAccess.getFindConditionRule()
						|| rule == grammarAccess.getFindLogicalOrRule()
						|| action == grammarAccess.getFindLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalXorRule()
						|| action == grammarAccess.getFindLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalAndRule()
						|| action == grammarAccess.getFindLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getFindPrimaryRule()
						|| rule == grammarAccess.getFindUnaryRule()) {
					sequence_FindLogicalOr(context, (LogicalOr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_LogicalOr(context, (LogicalOr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_LogicalOr_PragmaList(context, (LogicalOr) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.LOGICAL_XOR:
				if (rule == grammarAccess.getFindConditionRule()
						|| rule == grammarAccess.getFindLogicalOrRule()
						|| action == grammarAccess.getFindLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalXorRule()
						|| action == grammarAccess.getFindLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalAndRule()
						|| action == grammarAccess.getFindLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getFindPrimaryRule()
						|| rule == grammarAccess.getFindUnaryRule()) {
					sequence_FindLogicalXor(context, (LogicalXor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_LogicalXor(context, (LogicalXor) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_LogicalXor_PragmaList(context, (LogicalXor) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.LOOP_VARIABLE:
				sequence_LoopVariable(context, (LoopVariable) semanticObject); 
				return; 
			case BehaviorPackage.MULT_EXP:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_MultExp(context, (MultExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_MultExp_PragmaList(context, (MultExp) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.NAVIGATE_EXPRESSION:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_NavigateExpression(context, (NavigateExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_NavigateExpression_PragmaList(context, (NavigateExpression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.NULL_LITERAL:
				if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getNullLiteralRule()) {
					sequence_NullLiteral(context, (NullLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_NullLiteral_PragmaList(context, (NullLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.RAISE_STATEMENT:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_RaiseStatement(context, (RaiseStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRaiseStatementRule()) {
					sequence_RaiseStatement(context, (RaiseStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.RANGE_EXPRESSION:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_RangeExpression(context, (RangeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_RangeExpression(context, (RangeExpression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.REAL_LITERAL:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_RealLiteral(context, (RealLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getRealLiteralRule()) {
					sequence_RealLiteral(context, (RealLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.RELATIONAL_EXP:
				if (rule == grammarAccess.getFindConditionRule()
						|| rule == grammarAccess.getFindLogicalOrRule()
						|| action == grammarAccess.getFindLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalXorRule()
						|| action == grammarAccess.getFindLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalAndRule()
						|| action == grammarAccess.getFindLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getFindPrimaryRule()
						|| rule == grammarAccess.getFindUnaryRule()
						|| rule == grammarAccess.getFindEqualityRule()
						|| action == grammarAccess.getFindEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getFindRelationExpRule()) {
					sequence_FindRelationExp(context, (RelationalExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_RelationalExp(context, (RelationalExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_RelationalExp(context, (RelationalExp) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.RETURN_STATEMENT:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_ReturnStatement(context, (ReturnStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReturnStatementRule()) {
					sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.SCHEDULE_STATEMENT:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_ScheduleStatement(context, (ScheduleStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getScheduleStatementRule()) {
					sequence_ScheduleStatement(context, (ScheduleStatement) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.SIMPLE_FEATURE_CALL:
				if (rule == grammarAccess.getFindConditionRule()
						|| rule == grammarAccess.getFindLogicalOrRule()
						|| action == grammarAccess.getFindLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalXorRule()
						|| action == grammarAccess.getFindLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getFindLogicalAndRule()
						|| action == grammarAccess.getFindLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getFindPrimaryRule()
						|| rule == grammarAccess.getFindUnaryRule()
						|| rule == grammarAccess.getFindEqualityRule()
						|| action == grammarAccess.getFindEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getFindRelationExpRule()
						|| action == grammarAccess.getFindRelationExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getFindNameRule()
						|| action == grammarAccess.getFindNameAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getFindNameAccess().getIndexedExpressionReceiverAction_1_1_0()) {
					sequence_FindName_FindReceiverAttribute(context, (SimpleFeatureCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFindReceiverAttributeRule()) {
					sequence_FindReceiverAttribute(context, (SimpleFeatureCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()) {
					sequence_PostfixExpression_PostfixNoActionCallExpression_SimpleFeatureCall(context, (SimpleFeatureCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_PostfixExpression_PragmaList_SimpleFeatureCall(context, (SimpleFeatureCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_PostfixExpression_SimpleFeatureCall(context, (SimpleFeatureCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleFeatureCallRule()) {
					sequence_SimpleFeatureCall(context, (SimpleFeatureCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSortOrderFeatureRule()
						|| action == grammarAccess.getSortOrderFeatureAccess().getSimpleFeatureCallReceiverAction_2_0()) {
					sequence_SortOrderFeature(context, (SimpleFeatureCall) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.SORT_ORDER:
				sequence_SortOrder(context, (SortOrder) semanticObject); 
				return; 
			case BehaviorPackage.SORT_ORDER_COMPONENT:
				sequence_SortOrderComponent(context, (SortOrderComponent) semanticObject); 
				return; 
			case BehaviorPackage.SORT_ORDER_FEATURE:
				sequence_SortOrderFeature(context, (SortOrderFeature) semanticObject); 
				return; 
			case BehaviorPackage.STATEMENT:
				sequence_PragmaList(context, (Statement) semanticObject); 
				return; 
			case BehaviorPackage.STREAM_EXPRESSION:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_StreamExpression(context, (StreamExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_StreamExpression(context, (StreamExpression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.STRING_LITERAL:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_StringLiteral(context, (StringLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getStringLiteralRule()) {
					sequence_StringLiteral(context, (StringLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.STRUCTURE_AGGREGATE_EXPRESSION:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_ParenthesisedExpression_PragmaList(context, (StructureAggregateExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_ParenthesisedExpression(context, (StructureAggregateExpression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.TERMINATOR_ACTION_CALL:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PostfixExpression_PragmaList(context, (TerminatorActionCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_PostfixExpression(context, (TerminatorActionCall) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.THIS_LITERAL:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_ThisLiteral(context, (ThisLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getThisLiteralRule()) {
					sequence_ThisLiteral(context, (ThisLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.TIMESTAMP_LITERAL:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_TimestampLiteral(context, (TimestampLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getTimestampLiteralRule()) {
					sequence_TimestampLiteral(context, (TimestampLiteral) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.UNARY_EXP:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_UnaryExp(context, (UnaryExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_UnaryExp(context, (UnaryExp) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.VARIABLE_DECLARATION:
				sequence_PragmaList_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case BehaviorPackage.WHILE_STATEMENT:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_WhileStatement(context, (WhileStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWhileStatementRule()) {
					sequence_WhileStatement(context, (WhileStatement) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == StructurePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StructurePackage.ASSOC_RELATIONSHIP_DEFINITION:
				if (rule == grammarAccess.getAssocRelationshipDefinitionRule()) {
					sequence_AssocRelationshipDefinition(context, (AssocRelationshipDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRelationshipDefinitionRule()) {
					sequence_AssocRelationshipDefinition_PragmaList(context, (AssocRelationshipDefinition) semanticObject); 
					return; 
				}
				else break;
			case StructurePackage.ATTRIBUTE_DEFINITION:
				sequence_AttributeDefinition_PragmaList(context, (AttributeDefinition) semanticObject); 
				return; 
			case StructurePackage.BUILTIN_LIBRARY_DEFINITION:
				sequence_BuiltinLibraryDefinition(context, (BuiltinLibraryDefinition) semanticObject); 
				return; 
			case StructurePackage.CHARACTERISTIC:
				sequence_Characteristic_ParameterList(context, (Characteristic) semanticObject); 
				return; 
			case StructurePackage.DOMAIN_DEFINITION:
				sequence_DomainDefinition_PragmaList(context, (DomainDefinition) semanticObject); 
				return; 
			case StructurePackage.DOMAIN_SERVICE_DECLARATION:
				sequence_DomainServiceDeclaration_ParameterList_PragmaList(context, (DomainServiceDeclaration) semanticObject); 
				return; 
			case StructurePackage.DOMAIN_SERVICE_DEFINITION:
				sequence_DomainServiceDefinition_ParameterList_PragmaList(context, (DomainServiceDefinition) semanticObject); 
				return; 
			case StructurePackage.EVENT_DEFINITION:
				sequence_EventDefinition_ParameterList_PragmaList(context, (EventDefinition) semanticObject); 
				return; 
			case StructurePackage.EXCEPTION_DECLARATION:
				sequence_ExceptionDeclaration_PragmaList(context, (ExceptionDeclaration) semanticObject); 
				return; 
			case StructurePackage.IDENTIFIER_DEFINITION:
				sequence_IdentifierDefinition_PragmaList(context, (IdentifierDefinition) semanticObject); 
				return; 
			case StructurePackage.MASL_MODEL:
				sequence_MaslModel(context, (MaslModel) semanticObject); 
				return; 
			case StructurePackage.OBJECT_DECLARATION:
				sequence_ObjectDeclaration_PragmaList(context, (ObjectDeclaration) semanticObject); 
				return; 
			case StructurePackage.OBJECT_DEFINITION:
				sequence_ObjectDefinition_PragmaList(context, (ObjectDefinition) semanticObject); 
				return; 
			case StructurePackage.OBJECT_SERVICE_DECLARATION:
				sequence_ObjectServiceDeclaration_ParameterList_PragmaList(context, (ObjectServiceDeclaration) semanticObject); 
				return; 
			case StructurePackage.OBJECT_SERVICE_DEFINITION:
				sequence_ObjectServiceDefinition_ParameterList_PragmaList(context, (ObjectServiceDefinition) semanticObject); 
				return; 
			case StructurePackage.PARAMETER:
				sequence_Parameter(context, (org.xtuml.bp.xtext.masl.masl.structure.Parameter) semanticObject); 
				return; 
			case StructurePackage.PRAGMA:
				sequence_Pragma(context, (Pragma) semanticObject); 
				return; 
			case StructurePackage.PRAGMA_VALUE:
				sequence_PragmaValue(context, (PragmaValue) semanticObject); 
				return; 
			case StructurePackage.PROJECT_DEFINITION:
				sequence_PragmaList_ProjectDefinition(context, (ProjectDefinition) semanticObject); 
				return; 
			case StructurePackage.RANGE_TYPE_REFERENCE:
				sequence_RangeTypeReference(context, (RangeTypeReference) semanticObject); 
				return; 
			case StructurePackage.REGULAR_RELATIONSHIP_DEFINITION:
				if (rule == grammarAccess.getRelationshipDefinitionRule()) {
					sequence_PragmaList_RegularRelationshipDefinition(context, (RegularRelationshipDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRegularRelationshipDefinitionRule()) {
					sequence_RegularRelationshipDefinition(context, (RegularRelationshipDefinition) semanticObject); 
					return; 
				}
				else break;
			case StructurePackage.RELATIONSHIP_END:
				sequence_RelationshipEnd(context, (RelationshipEnd) semanticObject); 
				return; 
			case StructurePackage.RELATIONSHIP_NAVIGATION:
				sequence_RelationshipNavigation(context, (RelationshipNavigation) semanticObject); 
				return; 
			case StructurePackage.STATE_DECLARATION:
				sequence_ParameterList_PragmaList_StateDeclaration(context, (StateDeclaration) semanticObject); 
				return; 
			case StructurePackage.STATE_DEFINITION:
				sequence_ParameterList_PragmaList_StateDefinition(context, (StateDefinition) semanticObject); 
				return; 
			case StructurePackage.SUBTYPE_RELATIONSHIP_DEFINITION:
				if (rule == grammarAccess.getRelationshipDefinitionRule()) {
					sequence_PragmaList_SubtypeRelationshipDefinition(context, (SubtypeRelationshipDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSubtypeRelationshipDefinitionRule()) {
					sequence_SubtypeRelationshipDefinition(context, (SubtypeRelationshipDefinition) semanticObject); 
					return; 
				}
				else break;
			case StructurePackage.TERMINATOR_DEFINITION:
				sequence_PragmaList_TerminatorDefinition(context, (TerminatorDefinition) semanticObject); 
				return; 
			case StructurePackage.TERMINATOR_SERVICE_DECLARATION:
				sequence_ParameterList_PragmaList_TerminatorServiceDeclaration(context, (TerminatorServiceDeclaration) semanticObject); 
				return; 
			case StructurePackage.TERMINATOR_SERVICE_DEFINITION:
				sequence_ParameterList_PragmaList_TerminatorServiceDefinition(context, (TerminatorServiceDefinition) semanticObject); 
				return; 
			case StructurePackage.TRANSITION_OPTION:
				sequence_TransitionOption(context, (TransitionOption) semanticObject); 
				return; 
			case StructurePackage.TRANSITION_ROW:
				sequence_PragmaList_TransitionRow(context, (TransitionRow) semanticObject); 
				return; 
			case StructurePackage.TRANSITION_TABLE:
				sequence_PragmaList_TransitionTable(context, (TransitionTable) semanticObject); 
				return; 
			case StructurePackage.TYPE_PARAMETER:
				sequence_TypeParameter(context, (TypeParameter) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.ARRAY_TYPE_REFERENCE:
				if (rule == grammarAccess.getAbstractTypeReferenceWithRangeRule()
						|| rule == grammarAccess.getAbstractTypeDefinitionRule()
						|| rule == grammarAccess.getAbstractTypeReferenceRule()
						|| rule == grammarAccess.getAbstractTypeReferenceWithCARule()
						|| rule == grammarAccess.getAbstractCollectionTypeReferenceRule()
						|| rule == grammarAccess.getArrayTypeReferenceRule()
						|| rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getTypeNameExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_ArrayTypeReference(context, (ArrayTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_ArrayTypeReference_PragmaList(context, (ArrayTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.BAG_TYPE_REFERENCE:
				if (rule == grammarAccess.getAbstractTypeReferenceWithRangeRule()
						|| rule == grammarAccess.getAbstractTypeDefinitionRule()
						|| rule == grammarAccess.getAbstractTypeReferenceRule()
						|| rule == grammarAccess.getAbstractTypeReferenceWithCARule()
						|| rule == grammarAccess.getAbstractCollectionTypeReferenceRule()
						|| rule == grammarAccess.getBagTypeReferenceRule()
						|| rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getTypeNameExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_BagTypeReference(context, (BagTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_BagTypeReference_PragmaList(context, (BagTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.BUILTIN_TYPE_DECLARATION:
				sequence_BuiltinTypeDeclaration(context, (BuiltinTypeDeclaration) semanticObject); 
				return; 
			case TypesPackage.CONSTRAINED_ARRAY_TYPE_REFERENCE:
				sequence_ConstrainedArrayTypeReference(context, (ConstrainedArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.CONSTRAINED_TYPE_DEFINITION:
				sequence_ConstrainedTypeDefinition(context, (ConstrainedTypeDefinition) semanticObject); 
				return; 
			case TypesPackage.DELTA_CONSTRAINT:
				sequence_DeltaConstraint(context, (DeltaConstraint) semanticObject); 
				return; 
			case TypesPackage.DICTIONARY_TYPE_REFERENCE:
				if (rule == grammarAccess.getAbstractTypeReferenceWithRangeRule()
						|| rule == grammarAccess.getAbstractTypeDefinitionRule()
						|| rule == grammarAccess.getAbstractTypeReferenceRule()
						|| rule == grammarAccess.getAbstractTypeReferenceWithCARule()
						|| rule == grammarAccess.getAbstractCollectionTypeReferenceRule()
						|| rule == grammarAccess.getDictionaryTypeReferenceRule()
						|| rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getTypeNameExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_DictionaryTypeReference(context, (DictionaryTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_DictionaryTypeReference_PragmaList(context, (DictionaryTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.DIGITS_CONSTRAINT:
				sequence_DigitsConstraint(context, (DigitsConstraint) semanticObject); 
				return; 
			case TypesPackage.ENUMERATION_TYPE_DEFINITION:
				sequence_EnumerationTypeDefinition(context, (EnumerationTypeDefinition) semanticObject); 
				return; 
			case TypesPackage.ENUMERATOR:
				sequence_Enumerator(context, (Enumerator) semanticObject); 
				return; 
			case TypesPackage.INSTANCE_TYPE_REFERENCE:
				if (rule == grammarAccess.getAbstractTypeReferenceWithRangeRule()
						|| rule == grammarAccess.getAbstractTypeDefinitionRule()
						|| rule == grammarAccess.getAbstractTypeReferenceRule()
						|| rule == grammarAccess.getAbstractTypeReferenceWithCARule()
						|| rule == grammarAccess.getInstanceTypeReferenceRule()
						|| rule == grammarAccess.getAbstractDictKeyTypeRefRule()
						|| rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getTypeNameExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_InstanceTypeReference(context, (InstanceTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_InstanceTypeReference_PragmaList(context, (InstanceTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.NAMED_TYPE_REFERENCE:
				sequence_NamedTypeReference(context, (NamedTypeReference) semanticObject); 
				return; 
			case TypesPackage.RANGE_CONSTRAINT:
				sequence_RangeConstraint(context, (RangeConstraint) semanticObject); 
				return; 
			case TypesPackage.SEQUENCE_TYPE_REFERENCE:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_SequenceTypeReference(context, (SequenceTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractTypeReferenceWithRangeRule()
						|| rule == grammarAccess.getAbstractTypeDefinitionRule()
						|| rule == grammarAccess.getAbstractTypeReferenceRule()
						|| rule == grammarAccess.getAbstractTypeReferenceWithCARule()
						|| rule == grammarAccess.getAbstractCollectionTypeReferenceRule()
						|| rule == grammarAccess.getSequenceTypeReferenceRule()
						|| rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getTypeNameExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_SequenceTypeReference(context, (SequenceTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.SET_TYPE_REFERENCE:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_PragmaList_SetTypeReference(context, (SetTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractTypeReferenceWithRangeRule()
						|| rule == grammarAccess.getAbstractTypeDefinitionRule()
						|| rule == grammarAccess.getAbstractTypeReferenceRule()
						|| rule == grammarAccess.getAbstractTypeReferenceWithCARule()
						|| rule == grammarAccess.getAbstractCollectionTypeReferenceRule()
						|| rule == grammarAccess.getSetTypeReferenceRule()
						|| rule == grammarAccess.getAssignStatementRule()
						|| action == grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0()
						|| rule == grammarAccess.getConstExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStreamExpressionRule()
						|| action == grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0()
						|| rule == grammarAccess.getLogicalOrRule()
						|| action == grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0()
						|| rule == grammarAccess.getLogicalXorRule()
						|| action == grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0()
						|| rule == grammarAccess.getLogicalAndRule()
						|| action == grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLhsAction_1_0()
						|| rule == grammarAccess.getRelationalExpRule()
						|| action == grammarAccess.getRelationalExpAccess().getRelationalExpLhsAction_1_0()
						|| rule == grammarAccess.getAdditiveExpRule()
						|| action == grammarAccess.getAdditiveExpAccess().getAdditiveExpLhsAction_1_0()
						|| rule == grammarAccess.getMultExpRule()
						|| action == grammarAccess.getMultExpAccess().getMultExpLhsAction_1_0()
						|| rule == grammarAccess.getUnaryExpRule()
						|| rule == grammarAccess.getLinkExpressionRule()
						|| rule == grammarAccess.getNavigateExpressionRule()
						|| action == grammarAccess.getNavigateExpressionAccess().getNavigateExpressionLhsAction_1_0()
						|| rule == grammarAccess.getExtendedExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getActionCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getSimpleFeatureCallReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getTerminatorActionCallReceiverAction_1_2_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getCharacteristicCallReceiverAction_1_4_0()
						|| rule == grammarAccess.getPostfixNoActionCallExpressionRule()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getSimpleFeatureCallReceiverAction_1_0_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getIndexedExpressionReceiverAction_1_1_0()
						|| action == grammarAccess.getPostfixNoActionCallExpressionAccess().getCharacteristicCallReceiverAction_1_2_0()
						|| rule == grammarAccess.getPrimaryNoActionCallExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getTypeNameExpressionRule()
						|| rule == grammarAccess.getParenthesisedExpressionRule()
						|| action == grammarAccess.getParenthesisedExpressionAccess().getStructureAggregateExpressionElementsAction_2_0()) {
					sequence_SetTypeReference(context, (SetTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.STRUCTURE_COMPONENT_DEFINITION:
				sequence_PragmaList_StructureComponentDefinition(context, (StructureComponentDefinition) semanticObject); 
				return; 
			case TypesPackage.STRUCTURE_TYPE_DEFINITION:
				sequence_StructureTypeDefinition(context, (StructureTypeDefinition) semanticObject); 
				return; 
			case TypesPackage.TYPE_DECLARATION:
				sequence_PragmaList_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case TypesPackage.TYPE_FORWARD_DECLARATION:
				sequence_PragmaList_TypeForwardDeclaration(context, (TypeForwardDeclaration) semanticObject); 
				return; 
			case TypesPackage.UNCONSTRAINED_ARRAY_DEFINITION:
				sequence_UnconstrainedArrayDefinition(context, (UnconstrainedArrayDefinition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns AdditiveExp
	 *     AssignStatement.AssignStatement_1_0 returns AdditiveExp
	 *     ConstExpression returns AdditiveExp
	 *     Expression returns AdditiveExp
	 *     StreamExpression returns AdditiveExp
	 *     StreamExpression.StreamExpression_1_0 returns AdditiveExp
	 *     RangeExpression returns AdditiveExp
	 *     RangeExpression.RangeExpression_1_0 returns AdditiveExp
	 *     LogicalOr returns AdditiveExp
	 *     LogicalOr.LogicalOr_1_0 returns AdditiveExp
	 *     LogicalXor returns AdditiveExp
	 *     LogicalXor.LogicalXor_1_0 returns AdditiveExp
	 *     LogicalAnd returns AdditiveExp
	 *     LogicalAnd.LogicalAnd_1_0 returns AdditiveExp
	 *     Equality returns AdditiveExp
	 *     Equality.Equality_1_0 returns AdditiveExp
	 *     RelationalExp returns AdditiveExp
	 *     RelationalExp.RelationalExp_1_0 returns AdditiveExp
	 *     AdditiveExp returns AdditiveExp
	 *     AdditiveExp.AdditiveExp_1_0 returns AdditiveExp
	 *     MultExp returns AdditiveExp
	 *     MultExp.MultExp_1_0 returns AdditiveExp
	 *     UnaryExp returns AdditiveExp
	 *     LinkExpression returns AdditiveExp
	 *     NavigateExpression returns AdditiveExp
	 *     NavigateExpression.NavigateExpression_1_0 returns AdditiveExp
	 *     ExtendedExpression returns AdditiveExp
	 *     PostfixExpression returns AdditiveExp
	 *     PostfixExpression.ActionCall_1_0_0 returns AdditiveExp
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns AdditiveExp
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns AdditiveExp
	 *     PostfixExpression.IndexedExpression_1_3_0 returns AdditiveExp
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns AdditiveExp
	 *     PostfixNoActionCallExpression returns AdditiveExp
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns AdditiveExp
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns AdditiveExp
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns AdditiveExp
	 *     PrimaryNoActionCallExpression returns AdditiveExp
	 *     PrimaryExpression returns AdditiveExp
	 *     ParenthesisedExpression returns AdditiveExp
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns AdditiveExp
	 *
	 * Constraint:
	 *     (lhs=AdditiveExp_AdditiveExp_1_0 (operator='+' | operator='-' | operator='&' | operator='union' | operator='not_in') rhs=MultExp)
	 * </pre>
	 */
	protected void sequence_AdditiveExp(ISerializationContext context, AdditiveExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns AdditiveExp
	 *
	 * Constraint:
	 *     (
	 *         lhs=AdditiveExp_AdditiveExp_1_0 
	 *         (operator='+' | operator='-' | operator='&' | operator='union' | operator='not_in') 
	 *         rhs=MultExp 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_AdditiveExp_PragmaList(ISerializationContext context, AdditiveExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeReferenceWithRange returns ArrayTypeReference
	 *     AbstractTypeDefinition returns ArrayTypeReference
	 *     AbstractTypeReference returns ArrayTypeReference
	 *     AbstractTypeReferenceWithCA returns ArrayTypeReference
	 *     AbstractCollectionTypeReference returns ArrayTypeReference
	 *     ArrayTypeReference returns ArrayTypeReference
	 *     AssignStatement returns ArrayTypeReference
	 *     AssignStatement.AssignStatement_1_0 returns ArrayTypeReference
	 *     ConstExpression returns ArrayTypeReference
	 *     Expression returns ArrayTypeReference
	 *     StreamExpression returns ArrayTypeReference
	 *     StreamExpression.StreamExpression_1_0 returns ArrayTypeReference
	 *     RangeExpression returns ArrayTypeReference
	 *     RangeExpression.RangeExpression_1_0 returns ArrayTypeReference
	 *     LogicalOr returns ArrayTypeReference
	 *     LogicalOr.LogicalOr_1_0 returns ArrayTypeReference
	 *     LogicalXor returns ArrayTypeReference
	 *     LogicalXor.LogicalXor_1_0 returns ArrayTypeReference
	 *     LogicalAnd returns ArrayTypeReference
	 *     LogicalAnd.LogicalAnd_1_0 returns ArrayTypeReference
	 *     Equality returns ArrayTypeReference
	 *     Equality.Equality_1_0 returns ArrayTypeReference
	 *     RelationalExp returns ArrayTypeReference
	 *     RelationalExp.RelationalExp_1_0 returns ArrayTypeReference
	 *     AdditiveExp returns ArrayTypeReference
	 *     AdditiveExp.AdditiveExp_1_0 returns ArrayTypeReference
	 *     MultExp returns ArrayTypeReference
	 *     MultExp.MultExp_1_0 returns ArrayTypeReference
	 *     UnaryExp returns ArrayTypeReference
	 *     LinkExpression returns ArrayTypeReference
	 *     NavigateExpression returns ArrayTypeReference
	 *     NavigateExpression.NavigateExpression_1_0 returns ArrayTypeReference
	 *     ExtendedExpression returns ArrayTypeReference
	 *     PostfixExpression returns ArrayTypeReference
	 *     PostfixExpression.ActionCall_1_0_0 returns ArrayTypeReference
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns ArrayTypeReference
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns ArrayTypeReference
	 *     PostfixExpression.IndexedExpression_1_3_0 returns ArrayTypeReference
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns ArrayTypeReference
	 *     PostfixNoActionCallExpression returns ArrayTypeReference
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns ArrayTypeReference
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns ArrayTypeReference
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns ArrayTypeReference
	 *     PrimaryNoActionCallExpression returns ArrayTypeReference
	 *     PrimaryExpression returns ArrayTypeReference
	 *     TypeNameExpression returns ArrayTypeReference
	 *     ParenthesisedExpression returns ArrayTypeReference
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns ArrayTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? (indexType=RangeTypeReference | expression=Expression) elementType=AbstractTypeReference)
	 * </pre>
	 */
	protected void sequence_ArrayTypeReference(ISerializationContext context, ArrayTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ArrayTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? (indexType=RangeTypeReference | expression=Expression) elementType=AbstractTypeReference pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_ArrayTypeReference_PragmaList(ISerializationContext context, ArrayTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns AssignStatement
	 *
	 * Constraint:
	 *     (lhs=AssignStatement_AssignStatement_1_0 rhs=Expression)
	 * </pre>
	 */
	protected void sequence_AssignStatement(ISerializationContext context, AssignStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.ASSIGN_STATEMENT__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.ASSIGN_STATEMENT__LHS));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.ASSIGN_STATEMENT__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.ASSIGN_STATEMENT__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignStatementAccess().getAssignStatementLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAssignStatementAccess().getRhsExpressionParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns AssignStatement
	 *
	 * Constraint:
	 *     (lhs=AssignStatement_AssignStatement_1_0 rhs=Expression pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_AssignStatement_PragmaList(ISerializationContext context, AssignStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssocRelationshipDefinition returns AssocRelationshipDefinition
	 *
	 * Constraint:
	 *     (name=ID forwards=RelationshipEnd backwards=RelationshipEnd one?='one'? object=[ObjectDeclaration|ID])
	 * </pre>
	 */
	protected void sequence_AssocRelationshipDefinition(ISerializationContext context, AssocRelationshipDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationshipDefinition returns AssocRelationshipDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         forwards=RelationshipEnd 
	 *         backwards=RelationshipEnd 
	 *         one?='one'? 
	 *         object=[ObjectDeclaration|ID] 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_AssocRelationshipDefinition_PragmaList(ISerializationContext context, AssocRelationshipDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeDefinition returns AttributeDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         preferred?='preferred'? 
	 *         unique?='unique'? 
	 *         (referentials+=AttributeReferential referentials+=AttributeReferential*)? 
	 *         type=AbstractTypeReference 
	 *         defaultValue=ConstExpression? 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_AttributeDefinition_PragmaList(ISerializationContext context, AttributeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeReferential returns AttributeReferential
	 *
	 * Constraint:
	 *     (
	 *         relationship=[RelationshipDefinition|ScopedName] 
	 *         (
	 *             (objectOrRole=[ObjectOrRole|ObjectOrRoleName] attribute=[AttributeDefinition|ID]) | 
	 *             (objectOrRole=[ObjectOrRole|ID] attribute=[AttributeDefinition|ID]) | 
	 *             attribute=[AttributeDefinition|ID]
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_AttributeReferential(ISerializationContext context, AttributeReferential semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeReferenceWithRange returns BagTypeReference
	 *     AbstractTypeDefinition returns BagTypeReference
	 *     AbstractTypeReference returns BagTypeReference
	 *     AbstractTypeReferenceWithCA returns BagTypeReference
	 *     AbstractCollectionTypeReference returns BagTypeReference
	 *     BagTypeReference returns BagTypeReference
	 *     AssignStatement returns BagTypeReference
	 *     AssignStatement.AssignStatement_1_0 returns BagTypeReference
	 *     ConstExpression returns BagTypeReference
	 *     Expression returns BagTypeReference
	 *     StreamExpression returns BagTypeReference
	 *     StreamExpression.StreamExpression_1_0 returns BagTypeReference
	 *     RangeExpression returns BagTypeReference
	 *     RangeExpression.RangeExpression_1_0 returns BagTypeReference
	 *     LogicalOr returns BagTypeReference
	 *     LogicalOr.LogicalOr_1_0 returns BagTypeReference
	 *     LogicalXor returns BagTypeReference
	 *     LogicalXor.LogicalXor_1_0 returns BagTypeReference
	 *     LogicalAnd returns BagTypeReference
	 *     LogicalAnd.LogicalAnd_1_0 returns BagTypeReference
	 *     Equality returns BagTypeReference
	 *     Equality.Equality_1_0 returns BagTypeReference
	 *     RelationalExp returns BagTypeReference
	 *     RelationalExp.RelationalExp_1_0 returns BagTypeReference
	 *     AdditiveExp returns BagTypeReference
	 *     AdditiveExp.AdditiveExp_1_0 returns BagTypeReference
	 *     MultExp returns BagTypeReference
	 *     MultExp.MultExp_1_0 returns BagTypeReference
	 *     UnaryExp returns BagTypeReference
	 *     LinkExpression returns BagTypeReference
	 *     NavigateExpression returns BagTypeReference
	 *     NavigateExpression.NavigateExpression_1_0 returns BagTypeReference
	 *     ExtendedExpression returns BagTypeReference
	 *     PostfixExpression returns BagTypeReference
	 *     PostfixExpression.ActionCall_1_0_0 returns BagTypeReference
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns BagTypeReference
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns BagTypeReference
	 *     PostfixExpression.IndexedExpression_1_3_0 returns BagTypeReference
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns BagTypeReference
	 *     PostfixNoActionCallExpression returns BagTypeReference
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns BagTypeReference
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns BagTypeReference
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns BagTypeReference
	 *     PrimaryNoActionCallExpression returns BagTypeReference
	 *     PrimaryExpression returns BagTypeReference
	 *     TypeNameExpression returns BagTypeReference
	 *     ParenthesisedExpression returns BagTypeReference
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns BagTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? elementType=AbstractTypeReference)
	 * </pre>
	 */
	protected void sequence_BagTypeReference(ISerializationContext context, BagTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns BagTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? elementType=AbstractTypeReference pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_BagTypeReference_PragmaList(ISerializationContext context, BagTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns BooleanLiteral
	 *     AssignStatement.AssignStatement_1_0 returns BooleanLiteral
	 *     ConstExpression returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     StreamExpression returns BooleanLiteral
	 *     StreamExpression.StreamExpression_1_0 returns BooleanLiteral
	 *     RangeExpression returns BooleanLiteral
	 *     RangeExpression.RangeExpression_1_0 returns BooleanLiteral
	 *     LogicalOr returns BooleanLiteral
	 *     LogicalOr.LogicalOr_1_0 returns BooleanLiteral
	 *     LogicalXor returns BooleanLiteral
	 *     LogicalXor.LogicalXor_1_0 returns BooleanLiteral
	 *     LogicalAnd returns BooleanLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns BooleanLiteral
	 *     Equality returns BooleanLiteral
	 *     Equality.Equality_1_0 returns BooleanLiteral
	 *     RelationalExp returns BooleanLiteral
	 *     RelationalExp.RelationalExp_1_0 returns BooleanLiteral
	 *     AdditiveExp returns BooleanLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns BooleanLiteral
	 *     MultExp returns BooleanLiteral
	 *     MultExp.MultExp_1_0 returns BooleanLiteral
	 *     UnaryExp returns BooleanLiteral
	 *     LinkExpression returns BooleanLiteral
	 *     NavigateExpression returns BooleanLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns BooleanLiteral
	 *     ExtendedExpression returns BooleanLiteral
	 *     PostfixExpression returns BooleanLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns BooleanLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns BooleanLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns BooleanLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns BooleanLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns BooleanLiteral
	 *     PostfixNoActionCallExpression returns BooleanLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns BooleanLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns BooleanLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns BooleanLiteral
	 *     PrimaryNoActionCallExpression returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     ParenthesisedExpression returns BooleanLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     value?='true'?
	 * </pre>
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value?='true'? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_BooleanLiteral_PragmaList(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MaslModel returns BuiltinLibraryDefinition
	 *     BuiltinLibraryDefinition returns BuiltinLibraryDefinition
	 *
	 * Constraint:
	 *     (types+=BuiltinTypeDeclaration | exceptions+=ExceptionDeclaration | characteristics+=Characteristic)*
	 * </pre>
	 */
	protected void sequence_BuiltinLibraryDefinition(ISerializationContext context, BuiltinLibraryDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BuiltinTypeDeclaration returns BuiltinTypeDeclaration
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? name=ID)
	 * </pre>
	 */
	protected void sequence_BuiltinTypeDeclaration(ISerializationContext context, BuiltinTypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CancelTimerStatement returns CancelTimerStatement
	 *
	 * Constraint:
	 *     timerId=Expression
	 * </pre>
	 */
	protected void sequence_CancelTimerStatement(ISerializationContext context, CancelTimerStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.CANCEL_TIMER_STATEMENT__TIMER_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.CANCEL_TIMER_STATEMENT__TIMER_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCancelTimerStatementAccess().getTimerIdExpressionParserRuleCall_1_0(), semanticObject.getTimerId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CancelTimerStatement
	 *
	 * Constraint:
	 *     (timerId=Expression pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_CancelTimerStatement_PragmaList(ISerializationContext context, CancelTimerStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CaseAlternative returns CaseAlternative
	 *
	 * Constraint:
	 *     (choices+=Expression choices+=Expression* statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_CaseAlternative(ISerializationContext context, CaseAlternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CaseOthers returns CaseOthers
	 *
	 * Constraint:
	 *     statements+=Statement*
	 * </pre>
	 */
	protected void sequence_CaseOthers(ISerializationContext context, CaseOthers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CaseStatement returns CaseStatement
	 *
	 * Constraint:
	 *     (value=Expression alternatives+=CaseAlternative* default=CaseOthers?)
	 * </pre>
	 */
	protected void sequence_CaseStatement(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CaseStatement
	 *
	 * Constraint:
	 *     (value=Expression alternatives+=CaseAlternative* default=CaseOthers? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_CaseStatement_PragmaList(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns CharacterLiteral
	 *     AssignStatement.AssignStatement_1_0 returns CharacterLiteral
	 *     ConstExpression returns CharacterLiteral
	 *     Expression returns CharacterLiteral
	 *     StreamExpression returns CharacterLiteral
	 *     StreamExpression.StreamExpression_1_0 returns CharacterLiteral
	 *     RangeExpression returns CharacterLiteral
	 *     RangeExpression.RangeExpression_1_0 returns CharacterLiteral
	 *     LogicalOr returns CharacterLiteral
	 *     LogicalOr.LogicalOr_1_0 returns CharacterLiteral
	 *     LogicalXor returns CharacterLiteral
	 *     LogicalXor.LogicalXor_1_0 returns CharacterLiteral
	 *     LogicalAnd returns CharacterLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns CharacterLiteral
	 *     Equality returns CharacterLiteral
	 *     Equality.Equality_1_0 returns CharacterLiteral
	 *     RelationalExp returns CharacterLiteral
	 *     RelationalExp.RelationalExp_1_0 returns CharacterLiteral
	 *     AdditiveExp returns CharacterLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns CharacterLiteral
	 *     MultExp returns CharacterLiteral
	 *     MultExp.MultExp_1_0 returns CharacterLiteral
	 *     UnaryExp returns CharacterLiteral
	 *     LinkExpression returns CharacterLiteral
	 *     NavigateExpression returns CharacterLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns CharacterLiteral
	 *     ExtendedExpression returns CharacterLiteral
	 *     PostfixExpression returns CharacterLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns CharacterLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns CharacterLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns CharacterLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns CharacterLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns CharacterLiteral
	 *     PostfixNoActionCallExpression returns CharacterLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns CharacterLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns CharacterLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns CharacterLiteral
	 *     PrimaryNoActionCallExpression returns CharacterLiteral
	 *     PrimaryExpression returns CharacterLiteral
	 *     ParenthesisedExpression returns CharacterLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns CharacterLiteral
	 *     Literal returns CharacterLiteral
	 *     CharacterLiteral returns CharacterLiteral
	 *
	 * Constraint:
	 *     value=CHAR
	 * </pre>
	 */
	protected void sequence_CharacterLiteral(ISerializationContext context, CharacterLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.CHARACTER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.CHARACTER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharacterLiteralAccess().getValueCHARTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CharacterLiteral
	 *
	 * Constraint:
	 *     (value=CHAR pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_CharacterLiteral_PragmaList(ISerializationContext context, CharacterLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Characteristic returns Characteristic
	 *
	 * Constraint:
	 *     (
	 *         (typeParams+=TypeParameter typeParams+=TypeParameter*)? 
	 *         ((forValue?='(' receiverType=AbstractTypeReference) | receiverType=AbstractTypeReference) 
	 *         name=CharacteristicID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         returnType=AbstractTypeReferenceWithRange?
	 *     )
	 * </pre>
	 */
	protected void sequence_Characteristic_ParameterList(ISerializationContext context, Characteristic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CodeBlockStatement returns CodeBlock
	 *     CodeBlock returns CodeBlock
	 *
	 * Constraint:
	 *     (variables+=VariableDeclaration* statements+=Statement* exceptionHandler+=ExceptionHandler* defaultHandler=DefaultExceptionHandler?)
	 * </pre>
	 */
	protected void sequence_CodeBlock(ISerializationContext context, CodeBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CodeBlock
	 *
	 * Constraint:
	 *     (
	 *         variables+=VariableDeclaration* 
	 *         statements+=Statement* 
	 *         exceptionHandler+=ExceptionHandler* 
	 *         defaultHandler=DefaultExceptionHandler? 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_CodeBlock_PragmaList(ISerializationContext context, CodeBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns ConsoleLiteral
	 *     AssignStatement.AssignStatement_1_0 returns ConsoleLiteral
	 *     ConstExpression returns ConsoleLiteral
	 *     Expression returns ConsoleLiteral
	 *     StreamExpression returns ConsoleLiteral
	 *     StreamExpression.StreamExpression_1_0 returns ConsoleLiteral
	 *     RangeExpression returns ConsoleLiteral
	 *     RangeExpression.RangeExpression_1_0 returns ConsoleLiteral
	 *     LogicalOr returns ConsoleLiteral
	 *     LogicalOr.LogicalOr_1_0 returns ConsoleLiteral
	 *     LogicalXor returns ConsoleLiteral
	 *     LogicalXor.LogicalXor_1_0 returns ConsoleLiteral
	 *     LogicalAnd returns ConsoleLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns ConsoleLiteral
	 *     Equality returns ConsoleLiteral
	 *     Equality.Equality_1_0 returns ConsoleLiteral
	 *     RelationalExp returns ConsoleLiteral
	 *     RelationalExp.RelationalExp_1_0 returns ConsoleLiteral
	 *     AdditiveExp returns ConsoleLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns ConsoleLiteral
	 *     MultExp returns ConsoleLiteral
	 *     MultExp.MultExp_1_0 returns ConsoleLiteral
	 *     UnaryExp returns ConsoleLiteral
	 *     LinkExpression returns ConsoleLiteral
	 *     NavigateExpression returns ConsoleLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns ConsoleLiteral
	 *     ExtendedExpression returns ConsoleLiteral
	 *     PostfixExpression returns ConsoleLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns ConsoleLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns ConsoleLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns ConsoleLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns ConsoleLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns ConsoleLiteral
	 *     PostfixNoActionCallExpression returns ConsoleLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns ConsoleLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns ConsoleLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns ConsoleLiteral
	 *     PrimaryNoActionCallExpression returns ConsoleLiteral
	 *     PrimaryExpression returns ConsoleLiteral
	 *     ParenthesisedExpression returns ConsoleLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns ConsoleLiteral
	 *     Literal returns ConsoleLiteral
	 *     ConsoleLiteral returns ConsoleLiteral
	 *
	 * Constraint:
	 *     {ConsoleLiteral}
	 * </pre>
	 */
	protected void sequence_ConsoleLiteral(ISerializationContext context, ConsoleLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ConsoleLiteral
	 *
	 * Constraint:
	 *     pragmas+=Pragma*
	 * </pre>
	 */
	protected void sequence_ConsoleLiteral_PragmaList(ISerializationContext context, ConsoleLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeDefinition returns ConstrainedArrayTypeReference
	 *     AbstractTypeReferenceWithCA returns ConstrainedArrayTypeReference
	 *     ConstrainedArrayTypeReference returns ConstrainedArrayTypeReference
	 *
	 * Constraint:
	 *     (unconstrained=[TypeDeclaration|ScopedName] constraint=Expression)
	 * </pre>
	 */
	protected void sequence_ConstrainedArrayTypeReference(ISerializationContext context, ConstrainedArrayTypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.CONSTRAINED_ARRAY_TYPE_REFERENCE__UNCONSTRAINED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.CONSTRAINED_ARRAY_TYPE_REFERENCE__UNCONSTRAINED));
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.CONSTRAINED_ARRAY_TYPE_REFERENCE__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.CONSTRAINED_ARRAY_TYPE_REFERENCE__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstrainedArrayTypeReferenceAccess().getUnconstrainedTypeDeclarationScopedNameParserRuleCall_0_0_1(), semanticObject.eGet(TypesPackage.Literals.CONSTRAINED_ARRAY_TYPE_REFERENCE__UNCONSTRAINED, false));
		feeder.accept(grammarAccess.getConstrainedArrayTypeReferenceAccess().getConstraintExpressionParserRuleCall_2_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeDefinition returns ConstrainedTypeDefinition
	 *     ConstrainedTypeDefinition returns ConstrainedTypeDefinition
	 *
	 * Constraint:
	 *     (type=NamedTypeReference constraint=AbstractTypeConstraint)
	 * </pre>
	 */
	protected void sequence_ConstrainedTypeDefinition(ISerializationContext context, ConstrainedTypeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.CONSTRAINED_TYPE_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.CONSTRAINED_TYPE_DEFINITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.CONSTRAINED_TYPE_DEFINITION__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.CONSTRAINED_TYPE_DEFINITION__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstrainedTypeDefinitionAccess().getTypeNamedTypeReferenceParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConstrainedTypeDefinitionAccess().getConstraintAbstractTypeConstraintParserRuleCall_1_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CreateArgument returns CreateArgument
	 *
	 * Constraint:
	 *     ((attribute=[AttributeDefinition|ID] value=Expression) | currentState=[StateDeclaration|ID])
	 * </pre>
	 */
	protected void sequence_CreateArgument(ISerializationContext context, CreateArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns CreateExpression
	 *     AssignStatement.AssignStatement_1_0 returns CreateExpression
	 *     ConstExpression returns CreateExpression
	 *     Expression returns CreateExpression
	 *     StreamExpression returns CreateExpression
	 *     StreamExpression.StreamExpression_1_0 returns CreateExpression
	 *     RangeExpression returns CreateExpression
	 *     RangeExpression.RangeExpression_1_0 returns CreateExpression
	 *     LogicalOr returns CreateExpression
	 *     LogicalOr.LogicalOr_1_0 returns CreateExpression
	 *     LogicalXor returns CreateExpression
	 *     LogicalXor.LogicalXor_1_0 returns CreateExpression
	 *     LogicalAnd returns CreateExpression
	 *     LogicalAnd.LogicalAnd_1_0 returns CreateExpression
	 *     Equality returns CreateExpression
	 *     Equality.Equality_1_0 returns CreateExpression
	 *     RelationalExp returns CreateExpression
	 *     RelationalExp.RelationalExp_1_0 returns CreateExpression
	 *     AdditiveExp returns CreateExpression
	 *     AdditiveExp.AdditiveExp_1_0 returns CreateExpression
	 *     MultExp returns CreateExpression
	 *     MultExp.MultExp_1_0 returns CreateExpression
	 *     UnaryExp returns CreateExpression
	 *     LinkExpression returns CreateExpression
	 *     NavigateExpression returns CreateExpression
	 *     NavigateExpression.NavigateExpression_1_0 returns CreateExpression
	 *     ExtendedExpression returns CreateExpression
	 *     CreateExpression returns CreateExpression
	 *     PostfixExpression returns CreateExpression
	 *     PostfixExpression.ActionCall_1_0_0 returns CreateExpression
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns CreateExpression
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns CreateExpression
	 *     PostfixExpression.IndexedExpression_1_3_0 returns CreateExpression
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns CreateExpression
	 *     PostfixNoActionCallExpression returns CreateExpression
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns CreateExpression
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns CreateExpression
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns CreateExpression
	 *     PrimaryNoActionCallExpression returns CreateExpression
	 *     PrimaryExpression returns CreateExpression
	 *     ParenthesisedExpression returns CreateExpression
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns CreateExpression
	 *
	 * Constraint:
	 *     (unique?='unique'? object=[ObjectDeclaration|ID] (arguments+=CreateArgument arguments+=CreateArgument*)?)
	 * </pre>
	 */
	protected void sequence_CreateExpression(ISerializationContext context, CreateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CreateExpression
	 *
	 * Constraint:
	 *     (unique?='unique'? object=[ObjectDeclaration|ID] (arguments+=CreateArgument arguments+=CreateArgument*)? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_CreateExpression_PragmaList(ISerializationContext context, CreateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefaultExceptionHandler returns DefaultExceptionHandler
	 *
	 * Constraint:
	 *     statements+=Statement*
	 * </pre>
	 */
	protected void sequence_DefaultExceptionHandler(ISerializationContext context, DefaultExceptionHandler semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DelayStatement returns DelayStatement
	 *
	 * Constraint:
	 *     value=Expression
	 * </pre>
	 */
	protected void sequence_DelayStatement(ISerializationContext context, DelayStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.DELAY_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.DELAY_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDelayStatementAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns DelayStatement
	 *
	 * Constraint:
	 *     (value=Expression pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_DelayStatement_PragmaList(ISerializationContext context, DelayStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeleteStatement returns DeleteStatement
	 *
	 * Constraint:
	 *     value=Expression
	 * </pre>
	 */
	protected void sequence_DeleteStatement(ISerializationContext context, DeleteStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.DELETE_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.DELETE_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteStatementAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns DeleteStatement
	 *
	 * Constraint:
	 *     (value=Expression pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_DeleteStatement_PragmaList(ISerializationContext context, DeleteStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeConstraint returns DeltaConstraint
	 *     DeltaConstraint returns DeltaConstraint
	 *
	 * Constraint:
	 *     (delta=ConstExpression constraint=RangeConstraint)
	 * </pre>
	 */
	protected void sequence_DeltaConstraint(ISerializationContext context, DeltaConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.DELTA_CONSTRAINT__DELTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.DELTA_CONSTRAINT__DELTA));
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.DELTA_CONSTRAINT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.DELTA_CONSTRAINT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeltaConstraintAccess().getDeltaConstExpressionParserRuleCall_1_0(), semanticObject.getDelta());
		feeder.accept(grammarAccess.getDeltaConstraintAccess().getConstraintRangeConstraintParserRuleCall_2_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeReferenceWithRange returns DictionaryTypeReference
	 *     AbstractTypeDefinition returns DictionaryTypeReference
	 *     AbstractTypeReference returns DictionaryTypeReference
	 *     AbstractTypeReferenceWithCA returns DictionaryTypeReference
	 *     AbstractCollectionTypeReference returns DictionaryTypeReference
	 *     DictionaryTypeReference returns DictionaryTypeReference
	 *     AssignStatement returns DictionaryTypeReference
	 *     AssignStatement.AssignStatement_1_0 returns DictionaryTypeReference
	 *     ConstExpression returns DictionaryTypeReference
	 *     Expression returns DictionaryTypeReference
	 *     StreamExpression returns DictionaryTypeReference
	 *     StreamExpression.StreamExpression_1_0 returns DictionaryTypeReference
	 *     RangeExpression returns DictionaryTypeReference
	 *     RangeExpression.RangeExpression_1_0 returns DictionaryTypeReference
	 *     LogicalOr returns DictionaryTypeReference
	 *     LogicalOr.LogicalOr_1_0 returns DictionaryTypeReference
	 *     LogicalXor returns DictionaryTypeReference
	 *     LogicalXor.LogicalXor_1_0 returns DictionaryTypeReference
	 *     LogicalAnd returns DictionaryTypeReference
	 *     LogicalAnd.LogicalAnd_1_0 returns DictionaryTypeReference
	 *     Equality returns DictionaryTypeReference
	 *     Equality.Equality_1_0 returns DictionaryTypeReference
	 *     RelationalExp returns DictionaryTypeReference
	 *     RelationalExp.RelationalExp_1_0 returns DictionaryTypeReference
	 *     AdditiveExp returns DictionaryTypeReference
	 *     AdditiveExp.AdditiveExp_1_0 returns DictionaryTypeReference
	 *     MultExp returns DictionaryTypeReference
	 *     MultExp.MultExp_1_0 returns DictionaryTypeReference
	 *     UnaryExp returns DictionaryTypeReference
	 *     LinkExpression returns DictionaryTypeReference
	 *     NavigateExpression returns DictionaryTypeReference
	 *     NavigateExpression.NavigateExpression_1_0 returns DictionaryTypeReference
	 *     ExtendedExpression returns DictionaryTypeReference
	 *     PostfixExpression returns DictionaryTypeReference
	 *     PostfixExpression.ActionCall_1_0_0 returns DictionaryTypeReference
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns DictionaryTypeReference
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns DictionaryTypeReference
	 *     PostfixExpression.IndexedExpression_1_3_0 returns DictionaryTypeReference
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns DictionaryTypeReference
	 *     PostfixNoActionCallExpression returns DictionaryTypeReference
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns DictionaryTypeReference
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns DictionaryTypeReference
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns DictionaryTypeReference
	 *     PrimaryNoActionCallExpression returns DictionaryTypeReference
	 *     PrimaryExpression returns DictionaryTypeReference
	 *     TypeNameExpression returns DictionaryTypeReference
	 *     ParenthesisedExpression returns DictionaryTypeReference
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns DictionaryTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? (keyType=AbstractDictKeyTypeRef? elementType=AbstractTypeReference)?)
	 * </pre>
	 */
	protected void sequence_DictionaryTypeReference(ISerializationContext context, DictionaryTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns DictionaryTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? (keyType=AbstractDictKeyTypeRef? elementType=AbstractTypeReference)? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_DictionaryTypeReference_PragmaList(ISerializationContext context, DictionaryTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeConstraint returns DigitsConstraint
	 *     DigitsConstraint returns DigitsConstraint
	 *
	 * Constraint:
	 *     (digits=ConstExpression constraint=RangeConstraint)
	 * </pre>
	 */
	protected void sequence_DigitsConstraint(ISerializationContext context, DigitsConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.DIGITS_CONSTRAINT__DIGITS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.DIGITS_CONSTRAINT__DIGITS));
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.DIGITS_CONSTRAINT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.DIGITS_CONSTRAINT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDigitsConstraintAccess().getDigitsConstExpressionParserRuleCall_1_0(), semanticObject.getDigits());
		feeder.accept(grammarAccess.getDigitsConstraintAccess().getConstraintRangeConstraintParserRuleCall_2_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTopLevelElement returns DomainDefinition
	 *     DomainDefinition returns DomainDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             objects+=ObjectDeclaration | 
	 *             services+=DomainServiceDeclaration | 
	 *             terminators+=TerminatorDefinition | 
	 *             relationships+=RelationshipDefinition | 
	 *             objectDefs+=ObjectDefinition | 
	 *             typeForwards+=TypeForwardDeclaration | 
	 *             types+=TypeDeclaration | 
	 *             exceptions+=ExceptionDeclaration
	 *         )* 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_DomainDefinition_PragmaList(ISerializationContext context, DomainDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DomainServiceDeclaration returns DomainServiceDeclaration
	 *
	 * Constraint:
	 *     (visibility=Visibility? name=ID (parameters+=Parameter parameters+=Parameter*)? returnType=AbstractTypeReference? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_DomainServiceDeclaration_ParameterList_PragmaList(ISerializationContext context, DomainServiceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTopLevelElement returns DomainServiceDefinition
	 *     DomainServiceDefinition returns DomainServiceDefinition
	 *
	 * Constraint:
	 *     (
	 *         visibility=Visibility? 
	 *         domain=[DomainDefinition|ID] 
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         returnType=AbstractTypeReference? 
	 *         body=CodeBlock 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_DomainServiceDefinition_ParameterList_PragmaList(ISerializationContext context, DomainServiceDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns DurationLiteral
	 *     AssignStatement.AssignStatement_1_0 returns DurationLiteral
	 *     ConstExpression returns DurationLiteral
	 *     Expression returns DurationLiteral
	 *     StreamExpression returns DurationLiteral
	 *     StreamExpression.StreamExpression_1_0 returns DurationLiteral
	 *     RangeExpression returns DurationLiteral
	 *     RangeExpression.RangeExpression_1_0 returns DurationLiteral
	 *     LogicalOr returns DurationLiteral
	 *     LogicalOr.LogicalOr_1_0 returns DurationLiteral
	 *     LogicalXor returns DurationLiteral
	 *     LogicalXor.LogicalXor_1_0 returns DurationLiteral
	 *     LogicalAnd returns DurationLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns DurationLiteral
	 *     Equality returns DurationLiteral
	 *     Equality.Equality_1_0 returns DurationLiteral
	 *     RelationalExp returns DurationLiteral
	 *     RelationalExp.RelationalExp_1_0 returns DurationLiteral
	 *     AdditiveExp returns DurationLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns DurationLiteral
	 *     MultExp returns DurationLiteral
	 *     MultExp.MultExp_1_0 returns DurationLiteral
	 *     UnaryExp returns DurationLiteral
	 *     LinkExpression returns DurationLiteral
	 *     NavigateExpression returns DurationLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns DurationLiteral
	 *     ExtendedExpression returns DurationLiteral
	 *     PostfixExpression returns DurationLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns DurationLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns DurationLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns DurationLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns DurationLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns DurationLiteral
	 *     PostfixNoActionCallExpression returns DurationLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns DurationLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns DurationLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns DurationLiteral
	 *     PrimaryNoActionCallExpression returns DurationLiteral
	 *     PrimaryExpression returns DurationLiteral
	 *     ParenthesisedExpression returns DurationLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns DurationLiteral
	 *     Literal returns DurationLiteral
	 *     DurationLiteral returns DurationLiteral
	 *
	 * Constraint:
	 *     value=DURATION
	 * </pre>
	 */
	protected void sequence_DurationLiteral(ISerializationContext context, DurationLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.DURATION_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.DURATION_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDurationLiteralAccess().getValueDURATIONTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns DurationLiteral
	 *
	 * Constraint:
	 *     (value=DURATION pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_DurationLiteral_PragmaList(ISerializationContext context, DurationLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElseBlock returns ElseBlock
	 *
	 * Constraint:
	 *     statements+=Statement*
	 * </pre>
	 */
	protected void sequence_ElseBlock(ISerializationContext context, ElseBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElsifBlock returns ElsifBlock
	 *
	 * Constraint:
	 *     (condition=Expression statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_ElsifBlock(ISerializationContext context, ElsifBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns EndlLiteral
	 *     AssignStatement.AssignStatement_1_0 returns EndlLiteral
	 *     ConstExpression returns EndlLiteral
	 *     Expression returns EndlLiteral
	 *     StreamExpression returns EndlLiteral
	 *     StreamExpression.StreamExpression_1_0 returns EndlLiteral
	 *     RangeExpression returns EndlLiteral
	 *     RangeExpression.RangeExpression_1_0 returns EndlLiteral
	 *     LogicalOr returns EndlLiteral
	 *     LogicalOr.LogicalOr_1_0 returns EndlLiteral
	 *     LogicalXor returns EndlLiteral
	 *     LogicalXor.LogicalXor_1_0 returns EndlLiteral
	 *     LogicalAnd returns EndlLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns EndlLiteral
	 *     Equality returns EndlLiteral
	 *     Equality.Equality_1_0 returns EndlLiteral
	 *     RelationalExp returns EndlLiteral
	 *     RelationalExp.RelationalExp_1_0 returns EndlLiteral
	 *     AdditiveExp returns EndlLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns EndlLiteral
	 *     MultExp returns EndlLiteral
	 *     MultExp.MultExp_1_0 returns EndlLiteral
	 *     UnaryExp returns EndlLiteral
	 *     LinkExpression returns EndlLiteral
	 *     NavigateExpression returns EndlLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns EndlLiteral
	 *     ExtendedExpression returns EndlLiteral
	 *     PostfixExpression returns EndlLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns EndlLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns EndlLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns EndlLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns EndlLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns EndlLiteral
	 *     PostfixNoActionCallExpression returns EndlLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns EndlLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns EndlLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns EndlLiteral
	 *     PrimaryNoActionCallExpression returns EndlLiteral
	 *     PrimaryExpression returns EndlLiteral
	 *     ParenthesisedExpression returns EndlLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns EndlLiteral
	 *     Literal returns EndlLiteral
	 *     EndlLiteral returns EndlLiteral
	 *
	 * Constraint:
	 *     {EndlLiteral}
	 * </pre>
	 */
	protected void sequence_EndlLiteral(ISerializationContext context, EndlLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns EndlLiteral
	 *
	 * Constraint:
	 *     pragmas+=Pragma*
	 * </pre>
	 */
	protected void sequence_EndlLiteral_PragmaList(ISerializationContext context, EndlLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeDefinition returns EnumerationTypeDefinition
	 *     EnumerationTypeDefinition returns EnumerationTypeDefinition
	 *
	 * Constraint:
	 *     (enumerators+=Enumerator enumerators+=Enumerator*)?
	 * </pre>
	 */
	protected void sequence_EnumerationTypeDefinition(ISerializationContext context, EnumerationTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Enumerator returns Enumerator
	 *
	 * Constraint:
	 *     (name=ID expression=ConstExpression?)
	 * </pre>
	 */
	protected void sequence_Enumerator(ISerializationContext context, Enumerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns Equality
	 *     AssignStatement.AssignStatement_1_0 returns Equality
	 *     ConstExpression returns Equality
	 *     Expression returns Equality
	 *     StreamExpression returns Equality
	 *     StreamExpression.StreamExpression_1_0 returns Equality
	 *     RangeExpression returns Equality
	 *     RangeExpression.RangeExpression_1_0 returns Equality
	 *     LogicalOr returns Equality
	 *     LogicalOr.LogicalOr_1_0 returns Equality
	 *     LogicalXor returns Equality
	 *     LogicalXor.LogicalXor_1_0 returns Equality
	 *     LogicalAnd returns Equality
	 *     LogicalAnd.LogicalAnd_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     RelationalExp returns Equality
	 *     RelationalExp.RelationalExp_1_0 returns Equality
	 *     AdditiveExp returns Equality
	 *     AdditiveExp.AdditiveExp_1_0 returns Equality
	 *     MultExp returns Equality
	 *     MultExp.MultExp_1_0 returns Equality
	 *     UnaryExp returns Equality
	 *     LinkExpression returns Equality
	 *     NavigateExpression returns Equality
	 *     NavigateExpression.NavigateExpression_1_0 returns Equality
	 *     ExtendedExpression returns Equality
	 *     PostfixExpression returns Equality
	 *     PostfixExpression.ActionCall_1_0_0 returns Equality
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns Equality
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns Equality
	 *     PostfixExpression.IndexedExpression_1_3_0 returns Equality
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns Equality
	 *     PostfixNoActionCallExpression returns Equality
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns Equality
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns Equality
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns Equality
	 *     PrimaryNoActionCallExpression returns Equality
	 *     PrimaryExpression returns Equality
	 *     ParenthesisedExpression returns Equality
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns Equality
	 *
	 * Constraint:
	 *     (lhs=Equality_Equality_1_0 (operator='=' | operator='/=') rhs=RelationalExp)
	 * </pre>
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Equality
	 *
	 * Constraint:
	 *     (lhs=Equality_Equality_1_0 (operator='=' | operator='/=') rhs=RelationalExp pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_Equality_PragmaList(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EraseStatement returns EraseStatement
	 *
	 * Constraint:
	 *     value=Expression
	 * </pre>
	 */
	protected void sequence_EraseStatement(ISerializationContext context, EraseStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.ERASE_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.ERASE_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEraseStatementAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns EraseStatement
	 *
	 * Constraint:
	 *     (value=Expression pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_EraseStatement_PragmaList(ISerializationContext context, EraseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventDefinition returns EventDefinition
	 *
	 * Constraint:
	 *     (type=EventType? name=ID (parameters+=Parameter parameters+=Parameter*)? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_EventDefinition_ParameterList_PragmaList(ISerializationContext context, EventDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExceptionDeclaration returns ExceptionDeclaration
	 *
	 * Constraint:
	 *     (visibility=Visibility? name=ID pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_ExceptionDeclaration_PragmaList(ISerializationContext context, ExceptionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExceptionHandler returns ExceptionHandler
	 *
	 * Constraint:
	 *     (exception=[ExceptionDeclaration|ScopedName] statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_ExceptionHandler(ISerializationContext context, ExceptionHandler semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExitStatement returns ExitStatement
	 *
	 * Constraint:
	 *     condition=Expression?
	 * </pre>
	 */
	protected void sequence_ExitStatement(ISerializationContext context, ExitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ExitStatement
	 *
	 * Constraint:
	 *     (condition=Expression? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_ExitStatement_PragmaList(ISerializationContext context, ExitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns FileNameLiteral
	 *     AssignStatement.AssignStatement_1_0 returns FileNameLiteral
	 *     ConstExpression returns FileNameLiteral
	 *     Expression returns FileNameLiteral
	 *     StreamExpression returns FileNameLiteral
	 *     StreamExpression.StreamExpression_1_0 returns FileNameLiteral
	 *     RangeExpression returns FileNameLiteral
	 *     RangeExpression.RangeExpression_1_0 returns FileNameLiteral
	 *     LogicalOr returns FileNameLiteral
	 *     LogicalOr.LogicalOr_1_0 returns FileNameLiteral
	 *     LogicalXor returns FileNameLiteral
	 *     LogicalXor.LogicalXor_1_0 returns FileNameLiteral
	 *     LogicalAnd returns FileNameLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns FileNameLiteral
	 *     Equality returns FileNameLiteral
	 *     Equality.Equality_1_0 returns FileNameLiteral
	 *     RelationalExp returns FileNameLiteral
	 *     RelationalExp.RelationalExp_1_0 returns FileNameLiteral
	 *     AdditiveExp returns FileNameLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns FileNameLiteral
	 *     MultExp returns FileNameLiteral
	 *     MultExp.MultExp_1_0 returns FileNameLiteral
	 *     UnaryExp returns FileNameLiteral
	 *     LinkExpression returns FileNameLiteral
	 *     NavigateExpression returns FileNameLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns FileNameLiteral
	 *     ExtendedExpression returns FileNameLiteral
	 *     PostfixExpression returns FileNameLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns FileNameLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns FileNameLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns FileNameLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns FileNameLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns FileNameLiteral
	 *     PostfixNoActionCallExpression returns FileNameLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns FileNameLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns FileNameLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns FileNameLiteral
	 *     PrimaryNoActionCallExpression returns FileNameLiteral
	 *     PrimaryExpression returns FileNameLiteral
	 *     ParenthesisedExpression returns FileNameLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns FileNameLiteral
	 *     Literal returns FileNameLiteral
	 *     FileNameLiteral returns FileNameLiteral
	 *
	 * Constraint:
	 *     {FileNameLiteral}
	 * </pre>
	 */
	protected void sequence_FileNameLiteral(ISerializationContext context, FileNameLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FileNameLiteral
	 *
	 * Constraint:
	 *     pragmas+=Pragma*
	 * </pre>
	 */
	protected void sequence_FileNameLiteral_PragmaList(ISerializationContext context, FileNameLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FindCondition returns Equality
	 *     FindLogicalOr returns Equality
	 *     FindLogicalOr.LogicalOr_1_0 returns Equality
	 *     FindLogicalXor returns Equality
	 *     FindLogicalXor.LogicalXor_1_0 returns Equality
	 *     FindLogicalAnd returns Equality
	 *     FindLogicalAnd.LogicalAnd_1_0 returns Equality
	 *     FindPrimary returns Equality
	 *     FindUnary returns Equality
	 *     FindEquality returns Equality
	 *
	 * Constraint:
	 *     (lhs=FindEquality_Equality_1_0 (operator='=' | operator='/=') rhs=AdditiveExp)
	 * </pre>
	 */
	protected void sequence_FindEquality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns FindExpression
	 *     AssignStatement.AssignStatement_1_0 returns FindExpression
	 *     ConstExpression returns FindExpression
	 *     Expression returns FindExpression
	 *     StreamExpression returns FindExpression
	 *     StreamExpression.StreamExpression_1_0 returns FindExpression
	 *     RangeExpression returns FindExpression
	 *     RangeExpression.RangeExpression_1_0 returns FindExpression
	 *     LogicalOr returns FindExpression
	 *     LogicalOr.LogicalOr_1_0 returns FindExpression
	 *     LogicalXor returns FindExpression
	 *     LogicalXor.LogicalXor_1_0 returns FindExpression
	 *     LogicalAnd returns FindExpression
	 *     LogicalAnd.LogicalAnd_1_0 returns FindExpression
	 *     Equality returns FindExpression
	 *     Equality.Equality_1_0 returns FindExpression
	 *     RelationalExp returns FindExpression
	 *     RelationalExp.RelationalExp_1_0 returns FindExpression
	 *     AdditiveExp returns FindExpression
	 *     AdditiveExp.AdditiveExp_1_0 returns FindExpression
	 *     MultExp returns FindExpression
	 *     MultExp.MultExp_1_0 returns FindExpression
	 *     UnaryExp returns FindExpression
	 *     LinkExpression returns FindExpression
	 *     NavigateExpression returns FindExpression
	 *     NavigateExpression.NavigateExpression_1_0 returns FindExpression
	 *     ExtendedExpression returns FindExpression
	 *     FindExpression returns FindExpression
	 *     PostfixExpression returns FindExpression
	 *     PostfixExpression.ActionCall_1_0_0 returns FindExpression
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns FindExpression
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns FindExpression
	 *     PostfixExpression.IndexedExpression_1_3_0 returns FindExpression
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns FindExpression
	 *     PostfixNoActionCallExpression returns FindExpression
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns FindExpression
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns FindExpression
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns FindExpression
	 *     PrimaryNoActionCallExpression returns FindExpression
	 *     PrimaryExpression returns FindExpression
	 *     ParenthesisedExpression returns FindExpression
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns FindExpression
	 *
	 * Constraint:
	 *     (type=FindType expression=PostfixNoActionCallExpression where=FindCondition?)
	 * </pre>
	 */
	protected void sequence_FindExpression(ISerializationContext context, FindExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FindExpression
	 *
	 * Constraint:
	 *     (type=FindType expression=PostfixNoActionCallExpression where=FindCondition? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_FindExpression_PragmaList(ISerializationContext context, FindExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FindCondition returns LogicalAnd
	 *     FindLogicalOr returns LogicalAnd
	 *     FindLogicalOr.LogicalOr_1_0 returns LogicalAnd
	 *     FindLogicalXor returns LogicalAnd
	 *     FindLogicalXor.LogicalXor_1_0 returns LogicalAnd
	 *     FindLogicalAnd returns LogicalAnd
	 *     FindLogicalAnd.LogicalAnd_1_0 returns LogicalAnd
	 *     FindPrimary returns LogicalAnd
	 *     FindUnary returns LogicalAnd
	 *
	 * Constraint:
	 *     (lhs=FindLogicalAnd_LogicalAnd_1_0 rhs=FindPrimary)
	 * </pre>
	 */
	protected void sequence_FindLogicalAnd(ISerializationContext context, LogicalAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__LHS));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindLogicalAndAccess().getLogicalAndLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getFindLogicalAndAccess().getRhsFindPrimaryParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FindCondition returns LogicalOr
	 *     FindLogicalOr returns LogicalOr
	 *     FindLogicalOr.LogicalOr_1_0 returns LogicalOr
	 *     FindLogicalXor returns LogicalOr
	 *     FindLogicalXor.LogicalXor_1_0 returns LogicalOr
	 *     FindLogicalAnd returns LogicalOr
	 *     FindLogicalAnd.LogicalAnd_1_0 returns LogicalOr
	 *     FindPrimary returns LogicalOr
	 *     FindUnary returns LogicalOr
	 *
	 * Constraint:
	 *     (lhs=FindLogicalOr_LogicalOr_1_0 rhs=FindLogicalXor)
	 * </pre>
	 */
	protected void sequence_FindLogicalOr(ISerializationContext context, LogicalOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__LHS));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindLogicalOrAccess().getLogicalOrLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getFindLogicalOrAccess().getRhsFindLogicalXorParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FindCondition returns LogicalXor
	 *     FindLogicalOr returns LogicalXor
	 *     FindLogicalOr.LogicalOr_1_0 returns LogicalXor
	 *     FindLogicalXor returns LogicalXor
	 *     FindLogicalXor.LogicalXor_1_0 returns LogicalXor
	 *     FindLogicalAnd returns LogicalXor
	 *     FindLogicalAnd.LogicalAnd_1_0 returns LogicalXor
	 *     FindPrimary returns LogicalXor
	 *     FindUnary returns LogicalXor
	 *
	 * Constraint:
	 *     (lhs=FindLogicalXor_LogicalXor_1_0 rhs=FindLogicalAnd)
	 * </pre>
	 */
	protected void sequence_FindLogicalXor(ISerializationContext context, LogicalXor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__LHS));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindLogicalXorAccess().getLogicalXorLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getFindLogicalXorAccess().getRhsFindLogicalAndParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FindCondition returns SimpleFeatureCall
	 *     FindLogicalOr returns SimpleFeatureCall
	 *     FindLogicalOr.LogicalOr_1_0 returns SimpleFeatureCall
	 *     FindLogicalXor returns SimpleFeatureCall
	 *     FindLogicalXor.LogicalXor_1_0 returns SimpleFeatureCall
	 *     FindLogicalAnd returns SimpleFeatureCall
	 *     FindLogicalAnd.LogicalAnd_1_0 returns SimpleFeatureCall
	 *     FindPrimary returns SimpleFeatureCall
	 *     FindUnary returns SimpleFeatureCall
	 *     FindEquality returns SimpleFeatureCall
	 *     FindEquality.Equality_1_0 returns SimpleFeatureCall
	 *     FindRelationExp returns SimpleFeatureCall
	 *     FindRelationExp.RelationalExp_1_0 returns SimpleFeatureCall
	 *     FindName returns SimpleFeatureCall
	 *     FindName.SimpleFeatureCall_1_0_0 returns SimpleFeatureCall
	 *     FindName.IndexedExpression_1_1_0 returns SimpleFeatureCall
	 *
	 * Constraint:
	 *     ((receiver=FindName_SimpleFeatureCall_1_0_0 feature=[AbstractFeature|ID]) | feature=[AttributeDefinition|ID])
	 * </pre>
	 */
	protected void sequence_FindName_FindReceiverAttribute(ISerializationContext context, SimpleFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FindCondition returns IndexedExpression
	 *     FindLogicalOr returns IndexedExpression
	 *     FindLogicalOr.LogicalOr_1_0 returns IndexedExpression
	 *     FindLogicalXor returns IndexedExpression
	 *     FindLogicalXor.LogicalXor_1_0 returns IndexedExpression
	 *     FindLogicalAnd returns IndexedExpression
	 *     FindLogicalAnd.LogicalAnd_1_0 returns IndexedExpression
	 *     FindPrimary returns IndexedExpression
	 *     FindUnary returns IndexedExpression
	 *     FindEquality returns IndexedExpression
	 *     FindEquality.Equality_1_0 returns IndexedExpression
	 *     FindRelationExp returns IndexedExpression
	 *     FindRelationExp.RelationalExp_1_0 returns IndexedExpression
	 *     FindName returns IndexedExpression
	 *     FindName.SimpleFeatureCall_1_0_0 returns IndexedExpression
	 *     FindName.IndexedExpression_1_1_0 returns IndexedExpression
	 *
	 * Constraint:
	 *     (receiver=FindName_IndexedExpression_1_1_0 brackets=Expression)
	 * </pre>
	 */
	protected void sequence_FindName(ISerializationContext context, IndexedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.INDEXED_EXPRESSION__RECEIVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.INDEXED_EXPRESSION__RECEIVER));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.INDEXED_EXPRESSION__BRACKETS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.INDEXED_EXPRESSION__BRACKETS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindNameAccess().getIndexedExpressionReceiverAction_1_1_0(), semanticObject.getReceiver());
		feeder.accept(grammarAccess.getFindNameAccess().getBracketsExpressionParserRuleCall_1_1_2_0(), semanticObject.getBrackets());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FindReceiverAttribute returns SimpleFeatureCall
	 *
	 * Constraint:
	 *     feature=[AttributeDefinition|ID]
	 * </pre>
	 */
	protected void sequence_FindReceiverAttribute(ISerializationContext context, SimpleFeatureCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindReceiverAttributeAccess().getFeatureAttributeDefinitionIDTerminalRuleCall_0_1(), semanticObject.eGet(BehaviorPackage.Literals.FEATURE_CALL__FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FindCondition returns RelationalExp
	 *     FindLogicalOr returns RelationalExp
	 *     FindLogicalOr.LogicalOr_1_0 returns RelationalExp
	 *     FindLogicalXor returns RelationalExp
	 *     FindLogicalXor.LogicalXor_1_0 returns RelationalExp
	 *     FindLogicalAnd returns RelationalExp
	 *     FindLogicalAnd.LogicalAnd_1_0 returns RelationalExp
	 *     FindPrimary returns RelationalExp
	 *     FindUnary returns RelationalExp
	 *     FindEquality returns RelationalExp
	 *     FindEquality.Equality_1_0 returns RelationalExp
	 *     FindRelationExp returns RelationalExp
	 *
	 * Constraint:
	 *     (lhs=FindRelationExp_RelationalExp_1_0 (operator='&lt;' | operator='&gt;' | operator='&lt;=' | operator='&gt;=') rhs=AdditiveExp)
	 * </pre>
	 */
	protected void sequence_FindRelationExp(ISerializationContext context, RelationalExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns FlushLiteral
	 *     AssignStatement.AssignStatement_1_0 returns FlushLiteral
	 *     ConstExpression returns FlushLiteral
	 *     Expression returns FlushLiteral
	 *     StreamExpression returns FlushLiteral
	 *     StreamExpression.StreamExpression_1_0 returns FlushLiteral
	 *     RangeExpression returns FlushLiteral
	 *     RangeExpression.RangeExpression_1_0 returns FlushLiteral
	 *     LogicalOr returns FlushLiteral
	 *     LogicalOr.LogicalOr_1_0 returns FlushLiteral
	 *     LogicalXor returns FlushLiteral
	 *     LogicalXor.LogicalXor_1_0 returns FlushLiteral
	 *     LogicalAnd returns FlushLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns FlushLiteral
	 *     Equality returns FlushLiteral
	 *     Equality.Equality_1_0 returns FlushLiteral
	 *     RelationalExp returns FlushLiteral
	 *     RelationalExp.RelationalExp_1_0 returns FlushLiteral
	 *     AdditiveExp returns FlushLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns FlushLiteral
	 *     MultExp returns FlushLiteral
	 *     MultExp.MultExp_1_0 returns FlushLiteral
	 *     UnaryExp returns FlushLiteral
	 *     LinkExpression returns FlushLiteral
	 *     NavigateExpression returns FlushLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns FlushLiteral
	 *     ExtendedExpression returns FlushLiteral
	 *     PostfixExpression returns FlushLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns FlushLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns FlushLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns FlushLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns FlushLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns FlushLiteral
	 *     PostfixNoActionCallExpression returns FlushLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns FlushLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns FlushLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns FlushLiteral
	 *     PrimaryNoActionCallExpression returns FlushLiteral
	 *     PrimaryExpression returns FlushLiteral
	 *     ParenthesisedExpression returns FlushLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns FlushLiteral
	 *     Literal returns FlushLiteral
	 *     FlushLiteral returns FlushLiteral
	 *
	 * Constraint:
	 *     {FlushLiteral}
	 * </pre>
	 */
	protected void sequence_FlushLiteral(ISerializationContext context, FlushLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FlushLiteral
	 *
	 * Constraint:
	 *     pragmas+=Pragma*
	 * </pre>
	 */
	protected void sequence_FlushLiteral_PragmaList(ISerializationContext context, FlushLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (variable=LoopVariable reverse?='reverse'? expression=Expression statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ForStatement
	 *
	 * Constraint:
	 *     (variable=LoopVariable reverse?='reverse'? expression=Expression statements+=Statement* pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_ForStatement_PragmaList(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GenerateStatement returns GenerateStatement
	 *
	 * Constraint:
	 *     (object=[ObjectDeclaration|ScopedName]? event=[EventDefinition|ID] (arguments+=Expression arguments+=Expression*)? to=Expression?)
	 * </pre>
	 */
	protected void sequence_GenerateStatement(ISerializationContext context, GenerateStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns GenerateStatement
	 *
	 * Constraint:
	 *     (
	 *         object=[ObjectDeclaration|ScopedName]? 
	 *         event=[EventDefinition|ID] 
	 *         (arguments+=Expression arguments+=Expression*)? 
	 *         to=Expression? 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_GenerateStatement_PragmaList(ISerializationContext context, GenerateStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IdentifierDefinition returns IdentifierDefinition
	 *
	 * Constraint:
	 *     ((attributes+=[AttributeDefinition|ID] attributes+=[AttributeDefinition|ID]*)? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_IdentifierDefinition_PragmaList(ISerializationContext context, IdentifierDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression statements+=Statement* elseIfs+=ElsifBlock* else=ElseBlock?)
	 * </pre>
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression statements+=Statement* elseIfs+=ElsifBlock* else=ElseBlock? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_IfStatement_PragmaList(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeReferenceWithRange returns InstanceTypeReference
	 *     AbstractTypeDefinition returns InstanceTypeReference
	 *     AbstractTypeReference returns InstanceTypeReference
	 *     AbstractTypeReferenceWithCA returns InstanceTypeReference
	 *     InstanceTypeReference returns InstanceTypeReference
	 *     AbstractDictKeyTypeRef returns InstanceTypeReference
	 *     AssignStatement returns InstanceTypeReference
	 *     AssignStatement.AssignStatement_1_0 returns InstanceTypeReference
	 *     ConstExpression returns InstanceTypeReference
	 *     Expression returns InstanceTypeReference
	 *     StreamExpression returns InstanceTypeReference
	 *     StreamExpression.StreamExpression_1_0 returns InstanceTypeReference
	 *     RangeExpression returns InstanceTypeReference
	 *     RangeExpression.RangeExpression_1_0 returns InstanceTypeReference
	 *     LogicalOr returns InstanceTypeReference
	 *     LogicalOr.LogicalOr_1_0 returns InstanceTypeReference
	 *     LogicalXor returns InstanceTypeReference
	 *     LogicalXor.LogicalXor_1_0 returns InstanceTypeReference
	 *     LogicalAnd returns InstanceTypeReference
	 *     LogicalAnd.LogicalAnd_1_0 returns InstanceTypeReference
	 *     Equality returns InstanceTypeReference
	 *     Equality.Equality_1_0 returns InstanceTypeReference
	 *     RelationalExp returns InstanceTypeReference
	 *     RelationalExp.RelationalExp_1_0 returns InstanceTypeReference
	 *     AdditiveExp returns InstanceTypeReference
	 *     AdditiveExp.AdditiveExp_1_0 returns InstanceTypeReference
	 *     MultExp returns InstanceTypeReference
	 *     MultExp.MultExp_1_0 returns InstanceTypeReference
	 *     UnaryExp returns InstanceTypeReference
	 *     LinkExpression returns InstanceTypeReference
	 *     NavigateExpression returns InstanceTypeReference
	 *     NavigateExpression.NavigateExpression_1_0 returns InstanceTypeReference
	 *     ExtendedExpression returns InstanceTypeReference
	 *     PostfixExpression returns InstanceTypeReference
	 *     PostfixExpression.ActionCall_1_0_0 returns InstanceTypeReference
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns InstanceTypeReference
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns InstanceTypeReference
	 *     PostfixExpression.IndexedExpression_1_3_0 returns InstanceTypeReference
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns InstanceTypeReference
	 *     PostfixNoActionCallExpression returns InstanceTypeReference
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns InstanceTypeReference
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns InstanceTypeReference
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns InstanceTypeReference
	 *     PrimaryNoActionCallExpression returns InstanceTypeReference
	 *     PrimaryExpression returns InstanceTypeReference
	 *     TypeNameExpression returns InstanceTypeReference
	 *     ParenthesisedExpression returns InstanceTypeReference
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns InstanceTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? instance=[ObjectDeclaration|ScopedName])
	 * </pre>
	 */
	protected void sequence_InstanceTypeReference(ISerializationContext context, InstanceTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns InstanceTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? instance=[ObjectDeclaration|ScopedName] pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_InstanceTypeReference_PragmaList(ISerializationContext context, InstanceTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns IntegerLiteral
	 *     AssignStatement.AssignStatement_1_0 returns IntegerLiteral
	 *     ConstExpression returns IntegerLiteral
	 *     Expression returns IntegerLiteral
	 *     StreamExpression returns IntegerLiteral
	 *     StreamExpression.StreamExpression_1_0 returns IntegerLiteral
	 *     RangeExpression returns IntegerLiteral
	 *     RangeExpression.RangeExpression_1_0 returns IntegerLiteral
	 *     LogicalOr returns IntegerLiteral
	 *     LogicalOr.LogicalOr_1_0 returns IntegerLiteral
	 *     LogicalXor returns IntegerLiteral
	 *     LogicalXor.LogicalXor_1_0 returns IntegerLiteral
	 *     LogicalAnd returns IntegerLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns IntegerLiteral
	 *     Equality returns IntegerLiteral
	 *     Equality.Equality_1_0 returns IntegerLiteral
	 *     RelationalExp returns IntegerLiteral
	 *     RelationalExp.RelationalExp_1_0 returns IntegerLiteral
	 *     AdditiveExp returns IntegerLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns IntegerLiteral
	 *     MultExp returns IntegerLiteral
	 *     MultExp.MultExp_1_0 returns IntegerLiteral
	 *     UnaryExp returns IntegerLiteral
	 *     LinkExpression returns IntegerLiteral
	 *     NavigateExpression returns IntegerLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns IntegerLiteral
	 *     ExtendedExpression returns IntegerLiteral
	 *     PostfixExpression returns IntegerLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns IntegerLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns IntegerLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns IntegerLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns IntegerLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns IntegerLiteral
	 *     PostfixNoActionCallExpression returns IntegerLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns IntegerLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns IntegerLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns IntegerLiteral
	 *     PrimaryNoActionCallExpression returns IntegerLiteral
	 *     PrimaryExpression returns IntegerLiteral
	 *     ParenthesisedExpression returns IntegerLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns IntegerLiteral
	 *     Literal returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INTEGER
	 * </pre>
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueINTEGERTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns IntegerLiteral
	 *
	 * Constraint:
	 *     (value=INTEGER pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_IntegerLiteral_PragmaList(ISerializationContext context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns LineNoLiteral
	 *     AssignStatement.AssignStatement_1_0 returns LineNoLiteral
	 *     ConstExpression returns LineNoLiteral
	 *     Expression returns LineNoLiteral
	 *     StreamExpression returns LineNoLiteral
	 *     StreamExpression.StreamExpression_1_0 returns LineNoLiteral
	 *     RangeExpression returns LineNoLiteral
	 *     RangeExpression.RangeExpression_1_0 returns LineNoLiteral
	 *     LogicalOr returns LineNoLiteral
	 *     LogicalOr.LogicalOr_1_0 returns LineNoLiteral
	 *     LogicalXor returns LineNoLiteral
	 *     LogicalXor.LogicalXor_1_0 returns LineNoLiteral
	 *     LogicalAnd returns LineNoLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns LineNoLiteral
	 *     Equality returns LineNoLiteral
	 *     Equality.Equality_1_0 returns LineNoLiteral
	 *     RelationalExp returns LineNoLiteral
	 *     RelationalExp.RelationalExp_1_0 returns LineNoLiteral
	 *     AdditiveExp returns LineNoLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns LineNoLiteral
	 *     MultExp returns LineNoLiteral
	 *     MultExp.MultExp_1_0 returns LineNoLiteral
	 *     UnaryExp returns LineNoLiteral
	 *     LinkExpression returns LineNoLiteral
	 *     NavigateExpression returns LineNoLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns LineNoLiteral
	 *     ExtendedExpression returns LineNoLiteral
	 *     PostfixExpression returns LineNoLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns LineNoLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns LineNoLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns LineNoLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns LineNoLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns LineNoLiteral
	 *     PostfixNoActionCallExpression returns LineNoLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns LineNoLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns LineNoLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns LineNoLiteral
	 *     PrimaryNoActionCallExpression returns LineNoLiteral
	 *     PrimaryExpression returns LineNoLiteral
	 *     ParenthesisedExpression returns LineNoLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns LineNoLiteral
	 *     Literal returns LineNoLiteral
	 *     LineNoLiteral returns LineNoLiteral
	 *
	 * Constraint:
	 *     {LineNoLiteral}
	 * </pre>
	 */
	protected void sequence_LineNoLiteral(ISerializationContext context, LineNoLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LineNoLiteral
	 *
	 * Constraint:
	 *     pragmas+=Pragma*
	 * </pre>
	 */
	protected void sequence_LineNoLiteral_PragmaList(ISerializationContext context, LineNoLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns LinkExpression
	 *     AssignStatement.AssignStatement_1_0 returns LinkExpression
	 *     ConstExpression returns LinkExpression
	 *     Expression returns LinkExpression
	 *     StreamExpression returns LinkExpression
	 *     StreamExpression.StreamExpression_1_0 returns LinkExpression
	 *     RangeExpression returns LinkExpression
	 *     RangeExpression.RangeExpression_1_0 returns LinkExpression
	 *     LogicalOr returns LinkExpression
	 *     LogicalOr.LogicalOr_1_0 returns LinkExpression
	 *     LogicalXor returns LinkExpression
	 *     LogicalXor.LogicalXor_1_0 returns LinkExpression
	 *     LogicalAnd returns LinkExpression
	 *     LogicalAnd.LogicalAnd_1_0 returns LinkExpression
	 *     Equality returns LinkExpression
	 *     Equality.Equality_1_0 returns LinkExpression
	 *     RelationalExp returns LinkExpression
	 *     RelationalExp.RelationalExp_1_0 returns LinkExpression
	 *     AdditiveExp returns LinkExpression
	 *     AdditiveExp.AdditiveExp_1_0 returns LinkExpression
	 *     MultExp returns LinkExpression
	 *     MultExp.MultExp_1_0 returns LinkExpression
	 *     UnaryExp returns LinkExpression
	 *     LinkExpression returns LinkExpression
	 *     NavigateExpression returns LinkExpression
	 *     NavigateExpression.NavigateExpression_1_0 returns LinkExpression
	 *     ExtendedExpression returns LinkExpression
	 *     PostfixExpression returns LinkExpression
	 *     PostfixExpression.ActionCall_1_0_0 returns LinkExpression
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns LinkExpression
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns LinkExpression
	 *     PostfixExpression.IndexedExpression_1_3_0 returns LinkExpression
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns LinkExpression
	 *     PostfixNoActionCallExpression returns LinkExpression
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns LinkExpression
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns LinkExpression
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns LinkExpression
	 *     PrimaryNoActionCallExpression returns LinkExpression
	 *     PrimaryExpression returns LinkExpression
	 *     ParenthesisedExpression returns LinkExpression
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns LinkExpression
	 *
	 * Constraint:
	 *     (type=LinkType lhs=NavigateExpression navigation=RelationshipNavigation (rhs=NavigateExpression assoc=NavigateExpression?)?)
	 * </pre>
	 */
	protected void sequence_LinkExpression(ISerializationContext context, LinkExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LinkExpression
	 *
	 * Constraint:
	 *     (type=LinkType lhs=NavigateExpression navigation=RelationshipNavigation (rhs=NavigateExpression assoc=NavigateExpression?)? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_LinkExpression_PragmaList(ISerializationContext context, LinkExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns LogicalAnd
	 *     AssignStatement.AssignStatement_1_0 returns LogicalAnd
	 *     ConstExpression returns LogicalAnd
	 *     Expression returns LogicalAnd
	 *     StreamExpression returns LogicalAnd
	 *     StreamExpression.StreamExpression_1_0 returns LogicalAnd
	 *     RangeExpression returns LogicalAnd
	 *     RangeExpression.RangeExpression_1_0 returns LogicalAnd
	 *     LogicalOr returns LogicalAnd
	 *     LogicalOr.LogicalOr_1_0 returns LogicalAnd
	 *     LogicalXor returns LogicalAnd
	 *     LogicalXor.LogicalXor_1_0 returns LogicalAnd
	 *     LogicalAnd returns LogicalAnd
	 *     LogicalAnd.LogicalAnd_1_0 returns LogicalAnd
	 *     Equality returns LogicalAnd
	 *     Equality.Equality_1_0 returns LogicalAnd
	 *     RelationalExp returns LogicalAnd
	 *     RelationalExp.RelationalExp_1_0 returns LogicalAnd
	 *     AdditiveExp returns LogicalAnd
	 *     AdditiveExp.AdditiveExp_1_0 returns LogicalAnd
	 *     MultExp returns LogicalAnd
	 *     MultExp.MultExp_1_0 returns LogicalAnd
	 *     UnaryExp returns LogicalAnd
	 *     LinkExpression returns LogicalAnd
	 *     NavigateExpression returns LogicalAnd
	 *     NavigateExpression.NavigateExpression_1_0 returns LogicalAnd
	 *     ExtendedExpression returns LogicalAnd
	 *     PostfixExpression returns LogicalAnd
	 *     PostfixExpression.ActionCall_1_0_0 returns LogicalAnd
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns LogicalAnd
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns LogicalAnd
	 *     PostfixExpression.IndexedExpression_1_3_0 returns LogicalAnd
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns LogicalAnd
	 *     PostfixNoActionCallExpression returns LogicalAnd
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns LogicalAnd
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns LogicalAnd
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns LogicalAnd
	 *     PrimaryNoActionCallExpression returns LogicalAnd
	 *     PrimaryExpression returns LogicalAnd
	 *     ParenthesisedExpression returns LogicalAnd
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns LogicalAnd
	 *
	 * Constraint:
	 *     (lhs=LogicalAnd_LogicalAnd_1_0 operator='and' rhs=Equality)
	 * </pre>
	 */
	protected void sequence_LogicalAnd(ISerializationContext context, LogicalAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__LHS));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_AND__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalAndAccess().getLogicalAndLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getLogicalAndAccess().getOperatorAndKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getLogicalAndAccess().getRhsEqualityParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LogicalAnd
	 *
	 * Constraint:
	 *     (lhs=LogicalAnd_LogicalAnd_1_0 operator='and' rhs=Equality pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_LogicalAnd_PragmaList(ISerializationContext context, LogicalAnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns LogicalOr
	 *     AssignStatement.AssignStatement_1_0 returns LogicalOr
	 *     ConstExpression returns LogicalOr
	 *     Expression returns LogicalOr
	 *     StreamExpression returns LogicalOr
	 *     StreamExpression.StreamExpression_1_0 returns LogicalOr
	 *     RangeExpression returns LogicalOr
	 *     RangeExpression.RangeExpression_1_0 returns LogicalOr
	 *     LogicalOr returns LogicalOr
	 *     LogicalOr.LogicalOr_1_0 returns LogicalOr
	 *     LogicalXor returns LogicalOr
	 *     LogicalXor.LogicalXor_1_0 returns LogicalOr
	 *     LogicalAnd returns LogicalOr
	 *     LogicalAnd.LogicalAnd_1_0 returns LogicalOr
	 *     Equality returns LogicalOr
	 *     Equality.Equality_1_0 returns LogicalOr
	 *     RelationalExp returns LogicalOr
	 *     RelationalExp.RelationalExp_1_0 returns LogicalOr
	 *     AdditiveExp returns LogicalOr
	 *     AdditiveExp.AdditiveExp_1_0 returns LogicalOr
	 *     MultExp returns LogicalOr
	 *     MultExp.MultExp_1_0 returns LogicalOr
	 *     UnaryExp returns LogicalOr
	 *     LinkExpression returns LogicalOr
	 *     NavigateExpression returns LogicalOr
	 *     NavigateExpression.NavigateExpression_1_0 returns LogicalOr
	 *     ExtendedExpression returns LogicalOr
	 *     PostfixExpression returns LogicalOr
	 *     PostfixExpression.ActionCall_1_0_0 returns LogicalOr
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns LogicalOr
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns LogicalOr
	 *     PostfixExpression.IndexedExpression_1_3_0 returns LogicalOr
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns LogicalOr
	 *     PostfixNoActionCallExpression returns LogicalOr
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns LogicalOr
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns LogicalOr
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns LogicalOr
	 *     PrimaryNoActionCallExpression returns LogicalOr
	 *     PrimaryExpression returns LogicalOr
	 *     ParenthesisedExpression returns LogicalOr
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns LogicalOr
	 *
	 * Constraint:
	 *     (lhs=LogicalOr_LogicalOr_1_0 operator='or' rhs=LogicalXor)
	 * </pre>
	 */
	protected void sequence_LogicalOr(ISerializationContext context, LogicalOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__LHS));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_OR__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalOrAccess().getLogicalOrLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getLogicalOrAccess().getOperatorOrKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getLogicalOrAccess().getRhsLogicalXorParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LogicalOr
	 *
	 * Constraint:
	 *     (lhs=LogicalOr_LogicalOr_1_0 operator='or' rhs=LogicalXor pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_LogicalOr_PragmaList(ISerializationContext context, LogicalOr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns LogicalXor
	 *     AssignStatement.AssignStatement_1_0 returns LogicalXor
	 *     ConstExpression returns LogicalXor
	 *     Expression returns LogicalXor
	 *     StreamExpression returns LogicalXor
	 *     StreamExpression.StreamExpression_1_0 returns LogicalXor
	 *     RangeExpression returns LogicalXor
	 *     RangeExpression.RangeExpression_1_0 returns LogicalXor
	 *     LogicalOr returns LogicalXor
	 *     LogicalOr.LogicalOr_1_0 returns LogicalXor
	 *     LogicalXor returns LogicalXor
	 *     LogicalXor.LogicalXor_1_0 returns LogicalXor
	 *     LogicalAnd returns LogicalXor
	 *     LogicalAnd.LogicalAnd_1_0 returns LogicalXor
	 *     Equality returns LogicalXor
	 *     Equality.Equality_1_0 returns LogicalXor
	 *     RelationalExp returns LogicalXor
	 *     RelationalExp.RelationalExp_1_0 returns LogicalXor
	 *     AdditiveExp returns LogicalXor
	 *     AdditiveExp.AdditiveExp_1_0 returns LogicalXor
	 *     MultExp returns LogicalXor
	 *     MultExp.MultExp_1_0 returns LogicalXor
	 *     UnaryExp returns LogicalXor
	 *     LinkExpression returns LogicalXor
	 *     NavigateExpression returns LogicalXor
	 *     NavigateExpression.NavigateExpression_1_0 returns LogicalXor
	 *     ExtendedExpression returns LogicalXor
	 *     PostfixExpression returns LogicalXor
	 *     PostfixExpression.ActionCall_1_0_0 returns LogicalXor
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns LogicalXor
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns LogicalXor
	 *     PostfixExpression.IndexedExpression_1_3_0 returns LogicalXor
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns LogicalXor
	 *     PostfixNoActionCallExpression returns LogicalXor
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns LogicalXor
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns LogicalXor
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns LogicalXor
	 *     PrimaryNoActionCallExpression returns LogicalXor
	 *     PrimaryExpression returns LogicalXor
	 *     ParenthesisedExpression returns LogicalXor
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns LogicalXor
	 *
	 * Constraint:
	 *     (lhs=LogicalXor_LogicalXor_1_0 operator='xor' rhs=LogicalAnd)
	 * </pre>
	 */
	protected void sequence_LogicalXor(ISerializationContext context, LogicalXor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__LHS));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOGICAL_XOR__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalXorAccess().getLogicalXorLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getLogicalXorAccess().getOperatorXorKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getLogicalXorAccess().getRhsLogicalAndParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LogicalXor
	 *
	 * Constraint:
	 *     (lhs=LogicalXor_LogicalXor_1_0 operator='xor' rhs=LogicalAnd pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_LogicalXor_PragmaList(ISerializationContext context, LogicalXor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LoopVariable returns LoopVariable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_LoopVariable(ISerializationContext context, LoopVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.ABSTRACT_NAMED__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.ABSTRACT_NAMED__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MaslModel returns MaslModel
	 *
	 * Constraint:
	 *     elements+=AbstractTopLevelElement*
	 * </pre>
	 */
	protected void sequence_MaslModel(ISerializationContext context, MaslModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns MultExp
	 *     AssignStatement.AssignStatement_1_0 returns MultExp
	 *     ConstExpression returns MultExp
	 *     Expression returns MultExp
	 *     StreamExpression returns MultExp
	 *     StreamExpression.StreamExpression_1_0 returns MultExp
	 *     RangeExpression returns MultExp
	 *     RangeExpression.RangeExpression_1_0 returns MultExp
	 *     LogicalOr returns MultExp
	 *     LogicalOr.LogicalOr_1_0 returns MultExp
	 *     LogicalXor returns MultExp
	 *     LogicalXor.LogicalXor_1_0 returns MultExp
	 *     LogicalAnd returns MultExp
	 *     LogicalAnd.LogicalAnd_1_0 returns MultExp
	 *     Equality returns MultExp
	 *     Equality.Equality_1_0 returns MultExp
	 *     RelationalExp returns MultExp
	 *     RelationalExp.RelationalExp_1_0 returns MultExp
	 *     AdditiveExp returns MultExp
	 *     AdditiveExp.AdditiveExp_1_0 returns MultExp
	 *     MultExp returns MultExp
	 *     MultExp.MultExp_1_0 returns MultExp
	 *     UnaryExp returns MultExp
	 *     LinkExpression returns MultExp
	 *     NavigateExpression returns MultExp
	 *     NavigateExpression.NavigateExpression_1_0 returns MultExp
	 *     ExtendedExpression returns MultExp
	 *     PostfixExpression returns MultExp
	 *     PostfixExpression.ActionCall_1_0_0 returns MultExp
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns MultExp
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns MultExp
	 *     PostfixExpression.IndexedExpression_1_3_0 returns MultExp
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns MultExp
	 *     PostfixNoActionCallExpression returns MultExp
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns MultExp
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns MultExp
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns MultExp
	 *     PrimaryNoActionCallExpression returns MultExp
	 *     PrimaryExpression returns MultExp
	 *     ParenthesisedExpression returns MultExp
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns MultExp
	 *
	 * Constraint:
	 *     (
	 *         lhs=MultExp_MultExp_1_0 
	 *         (
	 *             operator='*' | 
	 *             operator='/' | 
	 *             operator='mod' | 
	 *             operator='**' | 
	 *             operator='rem' | 
	 *             operator='intersection' | 
	 *             operator='disunion'
	 *         ) 
	 *         rhs=UnaryExp
	 *     )
	 * </pre>
	 */
	protected void sequence_MultExp(ISerializationContext context, MultExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns MultExp
	 *
	 * Constraint:
	 *     (
	 *         lhs=MultExp_MultExp_1_0 
	 *         (
	 *             operator='*' | 
	 *             operator='/' | 
	 *             operator='mod' | 
	 *             operator='**' | 
	 *             operator='rem' | 
	 *             operator='intersection' | 
	 *             operator='disunion'
	 *         ) 
	 *         rhs=UnaryExp 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_MultExp_PragmaList(ISerializationContext context, MultExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeReferenceWithRange returns NamedTypeReference
	 *     AbstractTypeDefinition returns NamedTypeReference
	 *     AbstractTypeReference returns NamedTypeReference
	 *     AbstractTypeReferenceWithCA returns NamedTypeReference
	 *     NamedTypeReference returns NamedTypeReference
	 *     AbstractDictKeyTypeRef returns NamedTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? type=[TypeDeclaration|ScopedName])
	 * </pre>
	 */
	protected void sequence_NamedTypeReference(ISerializationContext context, NamedTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns NavigateExpression
	 *     AssignStatement.AssignStatement_1_0 returns NavigateExpression
	 *     ConstExpression returns NavigateExpression
	 *     Expression returns NavigateExpression
	 *     StreamExpression returns NavigateExpression
	 *     StreamExpression.StreamExpression_1_0 returns NavigateExpression
	 *     RangeExpression returns NavigateExpression
	 *     RangeExpression.RangeExpression_1_0 returns NavigateExpression
	 *     LogicalOr returns NavigateExpression
	 *     LogicalOr.LogicalOr_1_0 returns NavigateExpression
	 *     LogicalXor returns NavigateExpression
	 *     LogicalXor.LogicalXor_1_0 returns NavigateExpression
	 *     LogicalAnd returns NavigateExpression
	 *     LogicalAnd.LogicalAnd_1_0 returns NavigateExpression
	 *     Equality returns NavigateExpression
	 *     Equality.Equality_1_0 returns NavigateExpression
	 *     RelationalExp returns NavigateExpression
	 *     RelationalExp.RelationalExp_1_0 returns NavigateExpression
	 *     AdditiveExp returns NavigateExpression
	 *     AdditiveExp.AdditiveExp_1_0 returns NavigateExpression
	 *     MultExp returns NavigateExpression
	 *     MultExp.MultExp_1_0 returns NavigateExpression
	 *     UnaryExp returns NavigateExpression
	 *     LinkExpression returns NavigateExpression
	 *     NavigateExpression returns NavigateExpression
	 *     NavigateExpression.NavigateExpression_1_0 returns NavigateExpression
	 *     ExtendedExpression returns NavigateExpression
	 *     PostfixExpression returns NavigateExpression
	 *     PostfixExpression.ActionCall_1_0_0 returns NavigateExpression
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns NavigateExpression
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns NavigateExpression
	 *     PostfixExpression.IndexedExpression_1_3_0 returns NavigateExpression
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns NavigateExpression
	 *     PostfixNoActionCallExpression returns NavigateExpression
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns NavigateExpression
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns NavigateExpression
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns NavigateExpression
	 *     PrimaryNoActionCallExpression returns NavigateExpression
	 *     PrimaryExpression returns NavigateExpression
	 *     ParenthesisedExpression returns NavigateExpression
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns NavigateExpression
	 *
	 * Constraint:
	 *     (
	 *         lhs=NavigateExpression_NavigateExpression_1_0 
	 *         (
	 *             (navigation=RelationshipNavigation where=FindCondition?) | 
	 *             (with=ExtendedExpression navigation=RelationshipNavigation) | 
	 *             order=SortOrder | 
	 *             reverseOrder=SortOrder
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_NavigateExpression(ISerializationContext context, NavigateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns NavigateExpression
	 *
	 * Constraint:
	 *     (
	 *         lhs=NavigateExpression_NavigateExpression_1_0 
	 *         (
	 *             (navigation=RelationshipNavigation where=FindCondition?) | 
	 *             (with=ExtendedExpression navigation=RelationshipNavigation) | 
	 *             order=SortOrder | 
	 *             reverseOrder=SortOrder
	 *         ) 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_NavigateExpression_PragmaList(ISerializationContext context, NavigateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns NullLiteral
	 *     AssignStatement.AssignStatement_1_0 returns NullLiteral
	 *     ConstExpression returns NullLiteral
	 *     Expression returns NullLiteral
	 *     StreamExpression returns NullLiteral
	 *     StreamExpression.StreamExpression_1_0 returns NullLiteral
	 *     RangeExpression returns NullLiteral
	 *     RangeExpression.RangeExpression_1_0 returns NullLiteral
	 *     LogicalOr returns NullLiteral
	 *     LogicalOr.LogicalOr_1_0 returns NullLiteral
	 *     LogicalXor returns NullLiteral
	 *     LogicalXor.LogicalXor_1_0 returns NullLiteral
	 *     LogicalAnd returns NullLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns NullLiteral
	 *     Equality returns NullLiteral
	 *     Equality.Equality_1_0 returns NullLiteral
	 *     RelationalExp returns NullLiteral
	 *     RelationalExp.RelationalExp_1_0 returns NullLiteral
	 *     AdditiveExp returns NullLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns NullLiteral
	 *     MultExp returns NullLiteral
	 *     MultExp.MultExp_1_0 returns NullLiteral
	 *     UnaryExp returns NullLiteral
	 *     LinkExpression returns NullLiteral
	 *     NavigateExpression returns NullLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns NullLiteral
	 *     ExtendedExpression returns NullLiteral
	 *     PostfixExpression returns NullLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns NullLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns NullLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns NullLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns NullLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns NullLiteral
	 *     PostfixNoActionCallExpression returns NullLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns NullLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns NullLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns NullLiteral
	 *     PrimaryNoActionCallExpression returns NullLiteral
	 *     PrimaryExpression returns NullLiteral
	 *     ParenthesisedExpression returns NullLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns NullLiteral
	 *     Literal returns NullLiteral
	 *     NullLiteral returns NullLiteral
	 *
	 * Constraint:
	 *     {NullLiteral}
	 * </pre>
	 */
	protected void sequence_NullLiteral(ISerializationContext context, NullLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns NullLiteral
	 *
	 * Constraint:
	 *     pragmas+=Pragma*
	 * </pre>
	 */
	protected void sequence_NullLiteral_PragmaList(ISerializationContext context, NullLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectDeclaration returns ObjectDeclaration
	 *
	 * Constraint:
	 *     (name=ID pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_ObjectDeclaration_PragmaList(ISerializationContext context, ObjectDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectDefinition returns ObjectDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             attributes+=AttributeDefinition | 
	 *             identifiers+=IdentifierDefinition | 
	 *             services+=ObjectServiceDeclaration | 
	 *             events+=EventDefinition | 
	 *             states+=StateDeclaration | 
	 *             transitions+=TransitionTable
	 *         )* 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_ObjectDefinition_PragmaList(ISerializationContext context, ObjectDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectServiceDeclaration returns ObjectServiceDeclaration
	 *
	 * Constraint:
	 *     (
	 *         visibility=Visibility? 
	 *         instance?='instance'? 
	 *         relationship=[RelationshipDefinition|ID]? 
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         returnType=AbstractTypeReference? 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_ObjectServiceDeclaration_ParameterList_PragmaList(ISerializationContext context, ObjectServiceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTopLevelElement returns ObjectServiceDefinition
	 *     ObjectServiceDefinition returns ObjectServiceDefinition
	 *
	 * Constraint:
	 *     (
	 *         visibility=Visibility? 
	 *         instance?='instance'? 
	 *         relationship=[RelationshipDefinition|ID]? 
	 *         domain=[DomainDefinition|ID] 
	 *         object=[ObjectDeclaration|ID] 
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         returnType=AbstractTypeReference? 
	 *         body=CodeBlock 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_ObjectServiceDefinition_ParameterList_PragmaList(ISerializationContext context, ObjectServiceDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateDeclaration returns StateDeclaration
	 *
	 * Constraint:
	 *     (type=StateTypeSyntax? name=ID (parameters+=Parameter parameters+=Parameter*)? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_ParameterList_PragmaList_StateDeclaration(ISerializationContext context, StateDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTopLevelElement returns StateDefinition
	 *     StateDefinition returns StateDefinition
	 *
	 * Constraint:
	 *     (
	 *         type=StateTypeSyntax? 
	 *         domain=[DomainDefinition|ID] 
	 *         object=[ObjectDeclaration|ID] 
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         body=CodeBlock 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_ParameterList_PragmaList_StateDefinition(ISerializationContext context, StateDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TerminatorServiceDeclaration returns TerminatorServiceDeclaration
	 *
	 * Constraint:
	 *     (visibility=Visibility? name=ID (parameters+=Parameter parameters+=Parameter*)? returnType=AbstractTypeReference? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_ParameterList_PragmaList_TerminatorServiceDeclaration(ISerializationContext context, TerminatorServiceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTopLevelElement returns TerminatorServiceDefinition
	 *     TerminatorServiceDefinition returns TerminatorServiceDefinition
	 *
	 * Constraint:
	 *     (
	 *         visibility=Visibility? 
	 *         domain=[DomainDefinition|ID] 
	 *         terminator=[TerminatorDefinition|ID] 
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         returnType=AbstractTypeReference? 
	 *         body=CodeBlock 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_ParameterList_PragmaList_TerminatorServiceDefinition(ISerializationContext context, TerminatorServiceDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID mode=ParameterMode type=AbstractTypeReference)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtuml.bp.xtext.masl.masl.structure.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.ABSTRACT_NAMED__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.ABSTRACT_NAMED__NAME));
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.PARAMETER__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.PARAMETER__MODE));
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getModeParameterModeEnumRuleCall_2_0(), semanticObject.getMode());
		feeder.accept(grammarAccess.getParameterAccess().getTypeAbstractTypeReferenceParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns StructureAggregateExpression
	 *
	 * Constraint:
	 *     (elements+=ParenthesisedExpression_StructureAggregateExpression_2_0 elements+=Expression+ pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_ParenthesisedExpression_PragmaList(ISerializationContext context, StructureAggregateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns StructureAggregateExpression
	 *     AssignStatement.AssignStatement_1_0 returns StructureAggregateExpression
	 *     ConstExpression returns StructureAggregateExpression
	 *     Expression returns StructureAggregateExpression
	 *     StreamExpression returns StructureAggregateExpression
	 *     StreamExpression.StreamExpression_1_0 returns StructureAggregateExpression
	 *     RangeExpression returns StructureAggregateExpression
	 *     RangeExpression.RangeExpression_1_0 returns StructureAggregateExpression
	 *     LogicalOr returns StructureAggregateExpression
	 *     LogicalOr.LogicalOr_1_0 returns StructureAggregateExpression
	 *     LogicalXor returns StructureAggregateExpression
	 *     LogicalXor.LogicalXor_1_0 returns StructureAggregateExpression
	 *     LogicalAnd returns StructureAggregateExpression
	 *     LogicalAnd.LogicalAnd_1_0 returns StructureAggregateExpression
	 *     Equality returns StructureAggregateExpression
	 *     Equality.Equality_1_0 returns StructureAggregateExpression
	 *     RelationalExp returns StructureAggregateExpression
	 *     RelationalExp.RelationalExp_1_0 returns StructureAggregateExpression
	 *     AdditiveExp returns StructureAggregateExpression
	 *     AdditiveExp.AdditiveExp_1_0 returns StructureAggregateExpression
	 *     MultExp returns StructureAggregateExpression
	 *     MultExp.MultExp_1_0 returns StructureAggregateExpression
	 *     UnaryExp returns StructureAggregateExpression
	 *     LinkExpression returns StructureAggregateExpression
	 *     NavigateExpression returns StructureAggregateExpression
	 *     NavigateExpression.NavigateExpression_1_0 returns StructureAggregateExpression
	 *     ExtendedExpression returns StructureAggregateExpression
	 *     PostfixExpression returns StructureAggregateExpression
	 *     PostfixExpression.ActionCall_1_0_0 returns StructureAggregateExpression
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns StructureAggregateExpression
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns StructureAggregateExpression
	 *     PostfixExpression.IndexedExpression_1_3_0 returns StructureAggregateExpression
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns StructureAggregateExpression
	 *     PostfixNoActionCallExpression returns StructureAggregateExpression
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns StructureAggregateExpression
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns StructureAggregateExpression
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns StructureAggregateExpression
	 *     PrimaryNoActionCallExpression returns StructureAggregateExpression
	 *     PrimaryExpression returns StructureAggregateExpression
	 *     ParenthesisedExpression returns StructureAggregateExpression
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns StructureAggregateExpression
	 *
	 * Constraint:
	 *     (elements+=ParenthesisedExpression_StructureAggregateExpression_2_0 elements+=Expression+)
	 * </pre>
	 */
	protected void sequence_ParenthesisedExpression(ISerializationContext context, StructureAggregateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns ActionCall
	 *     AssignStatement.AssignStatement_1_0 returns ActionCall
	 *     ConstExpression returns ActionCall
	 *     Expression returns ActionCall
	 *     StreamExpression returns ActionCall
	 *     StreamExpression.StreamExpression_1_0 returns ActionCall
	 *     RangeExpression returns ActionCall
	 *     RangeExpression.RangeExpression_1_0 returns ActionCall
	 *     LogicalOr returns ActionCall
	 *     LogicalOr.LogicalOr_1_0 returns ActionCall
	 *     LogicalXor returns ActionCall
	 *     LogicalXor.LogicalXor_1_0 returns ActionCall
	 *     LogicalAnd returns ActionCall
	 *     LogicalAnd.LogicalAnd_1_0 returns ActionCall
	 *     Equality returns ActionCall
	 *     Equality.Equality_1_0 returns ActionCall
	 *     RelationalExp returns ActionCall
	 *     RelationalExp.RelationalExp_1_0 returns ActionCall
	 *     AdditiveExp returns ActionCall
	 *     AdditiveExp.AdditiveExp_1_0 returns ActionCall
	 *     MultExp returns ActionCall
	 *     MultExp.MultExp_1_0 returns ActionCall
	 *     UnaryExp returns ActionCall
	 *     LinkExpression returns ActionCall
	 *     NavigateExpression returns ActionCall
	 *     NavigateExpression.NavigateExpression_1_0 returns ActionCall
	 *     ExtendedExpression returns ActionCall
	 *     PostfixExpression returns ActionCall
	 *     PostfixExpression.ActionCall_1_0_0 returns ActionCall
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns ActionCall
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns ActionCall
	 *     PostfixExpression.IndexedExpression_1_3_0 returns ActionCall
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns ActionCall
	 *     PostfixNoActionCallExpression returns ActionCall
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns ActionCall
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns ActionCall
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns ActionCall
	 *     PrimaryNoActionCallExpression returns ActionCall
	 *     PrimaryExpression returns ActionCall
	 *     ParenthesisedExpression returns ActionCall
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns ActionCall
	 *
	 * Constraint:
	 *     (receiver=PostfixExpression_ActionCall_1_0_0 (arguments+=Expression arguments+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, ActionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns CharacteristicCall
	 *     AssignStatement.AssignStatement_1_0 returns CharacteristicCall
	 *     ConstExpression returns CharacteristicCall
	 *     Expression returns CharacteristicCall
	 *     StreamExpression returns CharacteristicCall
	 *     StreamExpression.StreamExpression_1_0 returns CharacteristicCall
	 *     RangeExpression returns CharacteristicCall
	 *     RangeExpression.RangeExpression_1_0 returns CharacteristicCall
	 *     LogicalOr returns CharacteristicCall
	 *     LogicalOr.LogicalOr_1_0 returns CharacteristicCall
	 *     LogicalXor returns CharacteristicCall
	 *     LogicalXor.LogicalXor_1_0 returns CharacteristicCall
	 *     LogicalAnd returns CharacteristicCall
	 *     LogicalAnd.LogicalAnd_1_0 returns CharacteristicCall
	 *     Equality returns CharacteristicCall
	 *     Equality.Equality_1_0 returns CharacteristicCall
	 *     RelationalExp returns CharacteristicCall
	 *     RelationalExp.RelationalExp_1_0 returns CharacteristicCall
	 *     AdditiveExp returns CharacteristicCall
	 *     AdditiveExp.AdditiveExp_1_0 returns CharacteristicCall
	 *     MultExp returns CharacteristicCall
	 *     MultExp.MultExp_1_0 returns CharacteristicCall
	 *     UnaryExp returns CharacteristicCall
	 *     LinkExpression returns CharacteristicCall
	 *     NavigateExpression returns CharacteristicCall
	 *     NavigateExpression.NavigateExpression_1_0 returns CharacteristicCall
	 *     ExtendedExpression returns CharacteristicCall
	 *     PostfixExpression returns CharacteristicCall
	 *     PostfixExpression.ActionCall_1_0_0 returns CharacteristicCall
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns CharacteristicCall
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns CharacteristicCall
	 *     PostfixExpression.IndexedExpression_1_3_0 returns CharacteristicCall
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns CharacteristicCall
	 *     PrimaryNoActionCallExpression returns CharacteristicCall
	 *     PrimaryExpression returns CharacteristicCall
	 *     ParenthesisedExpression returns CharacteristicCall
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns CharacteristicCall
	 *
	 * Constraint:
	 *     (
	 *         receiver=PostfixExpression_CharacteristicCall_1_4_0 
	 *         characteristic=[Characteristic|CharacteristicID] 
	 *         (arguments+=Expression arguments+=Expression*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, CharacteristicCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns IndexedExpression
	 *     AssignStatement.AssignStatement_1_0 returns IndexedExpression
	 *     ConstExpression returns IndexedExpression
	 *     Expression returns IndexedExpression
	 *     StreamExpression returns IndexedExpression
	 *     StreamExpression.StreamExpression_1_0 returns IndexedExpression
	 *     RangeExpression returns IndexedExpression
	 *     RangeExpression.RangeExpression_1_0 returns IndexedExpression
	 *     LogicalOr returns IndexedExpression
	 *     LogicalOr.LogicalOr_1_0 returns IndexedExpression
	 *     LogicalXor returns IndexedExpression
	 *     LogicalXor.LogicalXor_1_0 returns IndexedExpression
	 *     LogicalAnd returns IndexedExpression
	 *     LogicalAnd.LogicalAnd_1_0 returns IndexedExpression
	 *     Equality returns IndexedExpression
	 *     Equality.Equality_1_0 returns IndexedExpression
	 *     RelationalExp returns IndexedExpression
	 *     RelationalExp.RelationalExp_1_0 returns IndexedExpression
	 *     AdditiveExp returns IndexedExpression
	 *     AdditiveExp.AdditiveExp_1_0 returns IndexedExpression
	 *     MultExp returns IndexedExpression
	 *     MultExp.MultExp_1_0 returns IndexedExpression
	 *     UnaryExp returns IndexedExpression
	 *     LinkExpression returns IndexedExpression
	 *     NavigateExpression returns IndexedExpression
	 *     NavigateExpression.NavigateExpression_1_0 returns IndexedExpression
	 *     ExtendedExpression returns IndexedExpression
	 *     PostfixExpression returns IndexedExpression
	 *     PostfixExpression.ActionCall_1_0_0 returns IndexedExpression
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns IndexedExpression
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns IndexedExpression
	 *     PostfixExpression.IndexedExpression_1_3_0 returns IndexedExpression
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns IndexedExpression
	 *     PrimaryNoActionCallExpression returns IndexedExpression
	 *     PrimaryExpression returns IndexedExpression
	 *     ParenthesisedExpression returns IndexedExpression
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns IndexedExpression
	 *
	 * Constraint:
	 *     (receiver=PostfixExpression_IndexedExpression_1_3_0 brackets=Expression)
	 * </pre>
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, IndexedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.INDEXED_EXPRESSION__RECEIVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.INDEXED_EXPRESSION__RECEIVER));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.INDEXED_EXPRESSION__BRACKETS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.INDEXED_EXPRESSION__BRACKETS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfixExpressionAccess().getIndexedExpressionReceiverAction_1_3_0(), semanticObject.getReceiver());
		feeder.accept(grammarAccess.getPostfixExpressionAccess().getBracketsExpressionParserRuleCall_1_3_2_0(), semanticObject.getBrackets());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixNoActionCallExpression returns CharacteristicCall
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns CharacteristicCall
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns CharacteristicCall
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns CharacteristicCall
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             receiver=PostfixExpression_CharacteristicCall_1_4_0 
	 *             characteristic=[Characteristic|CharacteristicID] 
	 *             (arguments+=Expression arguments+=Expression*)?
	 *         ) | 
	 *         (receiver=PostfixNoActionCallExpression_CharacteristicCall_1_2_0 characteristic=[Characteristic|ID])
	 *     )
	 * </pre>
	 */
	protected void sequence_PostfixExpression_PostfixNoActionCallExpression(ISerializationContext context, CharacteristicCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixNoActionCallExpression returns IndexedExpression
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns IndexedExpression
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns IndexedExpression
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns IndexedExpression
	 *
	 * Constraint:
	 *     (
	 *         (receiver=PostfixExpression_IndexedExpression_1_3_0 brackets=Expression) | 
	 *         (receiver=PostfixNoActionCallExpression_IndexedExpression_1_1_0 brackets=Expression)
	 *     )
	 * </pre>
	 */
	protected void sequence_PostfixExpression_PostfixNoActionCallExpression(ISerializationContext context, IndexedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixNoActionCallExpression returns SimpleFeatureCall
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns SimpleFeatureCall
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns SimpleFeatureCall
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns SimpleFeatureCall
	 *
	 * Constraint:
	 *     (
	 *         (receiver=PostfixExpression_SimpleFeatureCall_1_1_0 feature=[AbstractFeature|ID]) | 
	 *         (receiver=PostfixNoActionCallExpression_SimpleFeatureCall_1_0_0 feature=[AbstractFeature|ID]) | 
	 *         feature=[AbstractFeature|ScopedName]
	 *     )
	 * </pre>
	 */
	protected void sequence_PostfixExpression_PostfixNoActionCallExpression_SimpleFeatureCall(ISerializationContext context, SimpleFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ActionCall
	 *
	 * Constraint:
	 *     (receiver=PostfixExpression_ActionCall_1_0_0 (arguments+=Expression arguments+=Expression*)? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PostfixExpression_PragmaList(ISerializationContext context, ActionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CharacteristicCall
	 *
	 * Constraint:
	 *     (
	 *         receiver=PostfixExpression_CharacteristicCall_1_4_0 
	 *         characteristic=[Characteristic|CharacteristicID] 
	 *         (arguments+=Expression arguments+=Expression*)? 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_PostfixExpression_PragmaList(ISerializationContext context, CharacteristicCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns IndexedExpression
	 *
	 * Constraint:
	 *     (receiver=PostfixExpression_IndexedExpression_1_3_0 brackets=Expression pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PostfixExpression_PragmaList(ISerializationContext context, IndexedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SimpleFeatureCall
	 *
	 * Constraint:
	 *     (((receiver=PostfixExpression_SimpleFeatureCall_1_1_0 feature=[AbstractFeature|ID]) | feature=[AbstractFeature|ScopedName]) pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PostfixExpression_PragmaList_SimpleFeatureCall(ISerializationContext context, SimpleFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns TerminatorActionCall
	 *
	 * Constraint:
	 *     (
	 *         receiver=PostfixExpression_TerminatorActionCall_1_2_0 
	 *         terminatorAction=[AbstractFeature|ID] 
	 *         (arguments+=Expression arguments+=Expression*)? 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_PostfixExpression_PragmaList(ISerializationContext context, TerminatorActionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns SimpleFeatureCall
	 *     AssignStatement.AssignStatement_1_0 returns SimpleFeatureCall
	 *     ConstExpression returns SimpleFeatureCall
	 *     Expression returns SimpleFeatureCall
	 *     StreamExpression returns SimpleFeatureCall
	 *     StreamExpression.StreamExpression_1_0 returns SimpleFeatureCall
	 *     RangeExpression returns SimpleFeatureCall
	 *     RangeExpression.RangeExpression_1_0 returns SimpleFeatureCall
	 *     LogicalOr returns SimpleFeatureCall
	 *     LogicalOr.LogicalOr_1_0 returns SimpleFeatureCall
	 *     LogicalXor returns SimpleFeatureCall
	 *     LogicalXor.LogicalXor_1_0 returns SimpleFeatureCall
	 *     LogicalAnd returns SimpleFeatureCall
	 *     LogicalAnd.LogicalAnd_1_0 returns SimpleFeatureCall
	 *     Equality returns SimpleFeatureCall
	 *     Equality.Equality_1_0 returns SimpleFeatureCall
	 *     RelationalExp returns SimpleFeatureCall
	 *     RelationalExp.RelationalExp_1_0 returns SimpleFeatureCall
	 *     AdditiveExp returns SimpleFeatureCall
	 *     AdditiveExp.AdditiveExp_1_0 returns SimpleFeatureCall
	 *     MultExp returns SimpleFeatureCall
	 *     MultExp.MultExp_1_0 returns SimpleFeatureCall
	 *     UnaryExp returns SimpleFeatureCall
	 *     LinkExpression returns SimpleFeatureCall
	 *     NavigateExpression returns SimpleFeatureCall
	 *     NavigateExpression.NavigateExpression_1_0 returns SimpleFeatureCall
	 *     ExtendedExpression returns SimpleFeatureCall
	 *     PostfixExpression returns SimpleFeatureCall
	 *     PostfixExpression.ActionCall_1_0_0 returns SimpleFeatureCall
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns SimpleFeatureCall
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns SimpleFeatureCall
	 *     PostfixExpression.IndexedExpression_1_3_0 returns SimpleFeatureCall
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns SimpleFeatureCall
	 *     PrimaryNoActionCallExpression returns SimpleFeatureCall
	 *     PrimaryExpression returns SimpleFeatureCall
	 *     ParenthesisedExpression returns SimpleFeatureCall
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns SimpleFeatureCall
	 *
	 * Constraint:
	 *     ((receiver=PostfixExpression_SimpleFeatureCall_1_1_0 feature=[AbstractFeature|ID]) | feature=[AbstractFeature|ScopedName])
	 * </pre>
	 */
	protected void sequence_PostfixExpression_SimpleFeatureCall(ISerializationContext context, SimpleFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns TerminatorActionCall
	 *     AssignStatement.AssignStatement_1_0 returns TerminatorActionCall
	 *     ConstExpression returns TerminatorActionCall
	 *     Expression returns TerminatorActionCall
	 *     StreamExpression returns TerminatorActionCall
	 *     StreamExpression.StreamExpression_1_0 returns TerminatorActionCall
	 *     RangeExpression returns TerminatorActionCall
	 *     RangeExpression.RangeExpression_1_0 returns TerminatorActionCall
	 *     LogicalOr returns TerminatorActionCall
	 *     LogicalOr.LogicalOr_1_0 returns TerminatorActionCall
	 *     LogicalXor returns TerminatorActionCall
	 *     LogicalXor.LogicalXor_1_0 returns TerminatorActionCall
	 *     LogicalAnd returns TerminatorActionCall
	 *     LogicalAnd.LogicalAnd_1_0 returns TerminatorActionCall
	 *     Equality returns TerminatorActionCall
	 *     Equality.Equality_1_0 returns TerminatorActionCall
	 *     RelationalExp returns TerminatorActionCall
	 *     RelationalExp.RelationalExp_1_0 returns TerminatorActionCall
	 *     AdditiveExp returns TerminatorActionCall
	 *     AdditiveExp.AdditiveExp_1_0 returns TerminatorActionCall
	 *     MultExp returns TerminatorActionCall
	 *     MultExp.MultExp_1_0 returns TerminatorActionCall
	 *     UnaryExp returns TerminatorActionCall
	 *     LinkExpression returns TerminatorActionCall
	 *     NavigateExpression returns TerminatorActionCall
	 *     NavigateExpression.NavigateExpression_1_0 returns TerminatorActionCall
	 *     ExtendedExpression returns TerminatorActionCall
	 *     PostfixExpression returns TerminatorActionCall
	 *     PostfixExpression.ActionCall_1_0_0 returns TerminatorActionCall
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns TerminatorActionCall
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns TerminatorActionCall
	 *     PostfixExpression.IndexedExpression_1_3_0 returns TerminatorActionCall
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns TerminatorActionCall
	 *     PostfixNoActionCallExpression returns TerminatorActionCall
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns TerminatorActionCall
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns TerminatorActionCall
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns TerminatorActionCall
	 *     PrimaryNoActionCallExpression returns TerminatorActionCall
	 *     PrimaryExpression returns TerminatorActionCall
	 *     ParenthesisedExpression returns TerminatorActionCall
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns TerminatorActionCall
	 *
	 * Constraint:
	 *     (receiver=PostfixExpression_TerminatorActionCall_1_2_0 terminatorAction=[AbstractFeature|ID] (arguments+=Expression arguments+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, TerminatorActionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTopLevelElement returns ProjectDefinition
	 *     ProjectDefinition returns ProjectDefinition
	 *
	 * Constraint:
	 *     (name=ID domains+=DomainDefinition* pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_ProjectDefinition(ISerializationContext context, ProjectDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns RaiseStatement
	 *
	 * Constraint:
	 *     (exception=[ExceptionDeclaration|ScopedName] argument=Expression? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_RaiseStatement(ISerializationContext context, RaiseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns RangeExpression
	 *
	 * Constraint:
	 *     (from=RangeExpression_RangeExpression_1_0 operator='..' to=LogicalOr pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_RangeExpression(ISerializationContext context, RangeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns RealLiteral
	 *
	 * Constraint:
	 *     (value=REAL pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationshipDefinition returns RegularRelationshipDefinition
	 *
	 * Constraint:
	 *     (name=ID forwards=RelationshipEnd backwards=RelationshipEnd pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_RegularRelationshipDefinition(ISerializationContext context, RegularRelationshipDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns RelationalExp
	 *
	 * Constraint:
	 *     (lhs=RelationalExp_RelationalExp_1_0 (operator='&lt;' | operator='&gt;' | operator='&lt;=' | operator='&gt;=') rhs=AdditiveExp pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_RelationalExp(ISerializationContext context, RelationalExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *
	 * Constraint:
	 *     (value=Expression pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ScheduleStatement
	 *
	 * Constraint:
	 *     (
	 *         timerId=Expression 
	 *         generateStatement=GenerateStatement 
	 *         type=ScheduleType 
	 *         time=Expression 
	 *         period=Expression? 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_PragmaList_ScheduleStatement(ISerializationContext context, ScheduleStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SequenceTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? expression=Expression? elementType=AbstractTypeReference pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_SequenceTypeReference(ISerializationContext context, SequenceTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SetTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? elementType=AbstractTypeReference pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_SetTypeReference(ISerializationContext context, SetTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     pragmas+=Pragma*
	 * </pre>
	 */
	protected void sequence_PragmaList(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns StreamExpression
	 *
	 * Constraint:
	 *     (lhs=StreamExpression_StreamExpression_1_0 operator=StreamOperator rhs=RangeExpression pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_StreamExpression(ISerializationContext context, StreamExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns StringLiteral
	 *
	 * Constraint:
	 *     (value=STRING pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StructureComponentDefinition returns StructureComponentDefinition
	 *
	 * Constraint:
	 *     (name=ID type=AbstractTypeReference defaultValue=ConstExpression? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_StructureComponentDefinition(ISerializationContext context, StructureComponentDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationshipDefinition returns SubtypeRelationshipDefinition
	 *
	 * Constraint:
	 *     (name=ID supertype=[ObjectDeclaration|ID] (subtypes+=[ObjectDeclaration|ID] subtypes+=[ObjectDeclaration|ID]*)? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_SubtypeRelationshipDefinition(ISerializationContext context, SubtypeRelationshipDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TerminatorDefinition returns TerminatorDefinition
	 *
	 * Constraint:
	 *     (name=ID services+=TerminatorServiceDeclaration* pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_TerminatorDefinition(ISerializationContext context, TerminatorDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ThisLiteral
	 *
	 * Constraint:
	 *     pragmas+=Pragma*
	 * </pre>
	 */
	protected void sequence_PragmaList_ThisLiteral(ISerializationContext context, ThisLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns TimestampLiteral
	 *
	 * Constraint:
	 *     (value=TIMESTAMP pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_TimestampLiteral(ISerializationContext context, TimestampLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TransitionRow returns TransitionRow
	 *
	 * Constraint:
	 *     (
	 *         (start=[StateDeclaration|ID] | nonExistant?='Non_Existent' | nonExistant?='Non_Existant' | nonExistant?='non_existent' | nonExistant?='non_existant') 
	 *         (options+=TransitionOption options+=TransitionOption*)? 
	 *         pragmas+=Pragma*
	 *     )
	 * </pre>
	 */
	protected void sequence_PragmaList_TransitionRow(ISerializationContext context, TransitionRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TransitionTable returns TransitionTable
	 *
	 * Constraint:
	 *     (type=TransTableType? rows+=TransitionRow+ pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_TransitionTable(ISerializationContext context, TransitionTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BuiltinTypeDeclaration returns TypeDeclaration
	 *     TypeDeclaration returns TypeDeclaration
	 *
	 * Constraint:
	 *     (visibility=Visibility? subtype?='subtype'? name=ID definition=AbstractTypeDefinition pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_TypeDeclaration(ISerializationContext context, TypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeForwardDeclaration returns TypeForwardDeclaration
	 *
	 * Constraint:
	 *     (visibility=Visibility? subtype?='subtype'? name=ID pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_TypeForwardDeclaration(ISerializationContext context, TypeForwardDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns UnaryExp
	 *
	 * Constraint:
	 *     (operator=UnaryOperator operand=UnaryExp pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_UnaryExp(ISerializationContext context, UnaryExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (name=ID readOnly='readonly'? type=AbstractTypeReferenceWithCA expression=Expression? pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression statements+=Statement* pragmas+=Pragma*)
	 * </pre>
	 */
	protected void sequence_PragmaList_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PragmaValue returns PragmaValue
	 *
	 * Constraint:
	 *     (name=ID | value=Literal)
	 * </pre>
	 */
	protected void sequence_PragmaValue(ISerializationContext context, PragmaValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pragma returns Pragma
	 *
	 * Constraint:
	 *     (name=ID (values+=PragmaValue values+=PragmaValue*)?)
	 * </pre>
	 */
	protected void sequence_Pragma(ISerializationContext context, Pragma semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RaiseStatement returns RaiseStatement
	 *
	 * Constraint:
	 *     (exception=[ExceptionDeclaration|ScopedName] argument=Expression?)
	 * </pre>
	 */
	protected void sequence_RaiseStatement(ISerializationContext context, RaiseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeConstraint returns RangeConstraint
	 *     RangeConstraint returns RangeConstraint
	 *
	 * Constraint:
	 *     range=Expression
	 * </pre>
	 */
	protected void sequence_RangeConstraint(ISerializationContext context, RangeConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.RANGE_CONSTRAINT__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.RANGE_CONSTRAINT__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeConstraintAccess().getRangeExpressionParserRuleCall_1_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns RangeExpression
	 *     AssignStatement.AssignStatement_1_0 returns RangeExpression
	 *     ConstExpression returns RangeExpression
	 *     Expression returns RangeExpression
	 *     StreamExpression returns RangeExpression
	 *     StreamExpression.StreamExpression_1_0 returns RangeExpression
	 *     RangeExpression returns RangeExpression
	 *     RangeExpression.RangeExpression_1_0 returns RangeExpression
	 *     LogicalOr returns RangeExpression
	 *     LogicalOr.LogicalOr_1_0 returns RangeExpression
	 *     LogicalXor returns RangeExpression
	 *     LogicalXor.LogicalXor_1_0 returns RangeExpression
	 *     LogicalAnd returns RangeExpression
	 *     LogicalAnd.LogicalAnd_1_0 returns RangeExpression
	 *     Equality returns RangeExpression
	 *     Equality.Equality_1_0 returns RangeExpression
	 *     RelationalExp returns RangeExpression
	 *     RelationalExp.RelationalExp_1_0 returns RangeExpression
	 *     AdditiveExp returns RangeExpression
	 *     AdditiveExp.AdditiveExp_1_0 returns RangeExpression
	 *     MultExp returns RangeExpression
	 *     MultExp.MultExp_1_0 returns RangeExpression
	 *     UnaryExp returns RangeExpression
	 *     LinkExpression returns RangeExpression
	 *     NavigateExpression returns RangeExpression
	 *     NavigateExpression.NavigateExpression_1_0 returns RangeExpression
	 *     ExtendedExpression returns RangeExpression
	 *     PostfixExpression returns RangeExpression
	 *     PostfixExpression.ActionCall_1_0_0 returns RangeExpression
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns RangeExpression
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns RangeExpression
	 *     PostfixExpression.IndexedExpression_1_3_0 returns RangeExpression
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns RangeExpression
	 *     PostfixNoActionCallExpression returns RangeExpression
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns RangeExpression
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns RangeExpression
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns RangeExpression
	 *     PrimaryNoActionCallExpression returns RangeExpression
	 *     PrimaryExpression returns RangeExpression
	 *     ParenthesisedExpression returns RangeExpression
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns RangeExpression
	 *
	 * Constraint:
	 *     (from=RangeExpression_RangeExpression_1_0 operator='..' to=LogicalOr)
	 * </pre>
	 */
	protected void sequence_RangeExpression(ISerializationContext context, RangeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.RANGE_EXPRESSION__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.RANGE_EXPRESSION__FROM));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.RANGE_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.RANGE_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.RANGE_EXPRESSION__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.RANGE_EXPRESSION__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeExpressionAccess().getRangeExpressionFromAction_1_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getRangeExpressionAccess().getOperatorFullStopFullStopKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRangeExpressionAccess().getToLogicalOrParserRuleCall_1_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeReferenceWithRange returns RangeTypeReference
	 *     RangeTypeReference returns RangeTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? elementType=AbstractTypeReference)
	 * </pre>
	 */
	protected void sequence_RangeTypeReference(ISerializationContext context, RangeTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns RealLiteral
	 *     AssignStatement.AssignStatement_1_0 returns RealLiteral
	 *     ConstExpression returns RealLiteral
	 *     Expression returns RealLiteral
	 *     StreamExpression returns RealLiteral
	 *     StreamExpression.StreamExpression_1_0 returns RealLiteral
	 *     RangeExpression returns RealLiteral
	 *     RangeExpression.RangeExpression_1_0 returns RealLiteral
	 *     LogicalOr returns RealLiteral
	 *     LogicalOr.LogicalOr_1_0 returns RealLiteral
	 *     LogicalXor returns RealLiteral
	 *     LogicalXor.LogicalXor_1_0 returns RealLiteral
	 *     LogicalAnd returns RealLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns RealLiteral
	 *     Equality returns RealLiteral
	 *     Equality.Equality_1_0 returns RealLiteral
	 *     RelationalExp returns RealLiteral
	 *     RelationalExp.RelationalExp_1_0 returns RealLiteral
	 *     AdditiveExp returns RealLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns RealLiteral
	 *     MultExp returns RealLiteral
	 *     MultExp.MultExp_1_0 returns RealLiteral
	 *     UnaryExp returns RealLiteral
	 *     LinkExpression returns RealLiteral
	 *     NavigateExpression returns RealLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns RealLiteral
	 *     ExtendedExpression returns RealLiteral
	 *     PostfixExpression returns RealLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns RealLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns RealLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns RealLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns RealLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns RealLiteral
	 *     PostfixNoActionCallExpression returns RealLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns RealLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns RealLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns RealLiteral
	 *     PrimaryNoActionCallExpression returns RealLiteral
	 *     PrimaryExpression returns RealLiteral
	 *     ParenthesisedExpression returns RealLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns RealLiteral
	 *     Literal returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     value=REAL
	 * </pre>
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.REAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.REAL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValueREALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RegularRelationshipDefinition returns RegularRelationshipDefinition
	 *
	 * Constraint:
	 *     (name=ID forwards=RelationshipEnd backwards=RelationshipEnd)
	 * </pre>
	 */
	protected void sequence_RegularRelationshipDefinition(ISerializationContext context, RegularRelationshipDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.ABSTRACT_NAMED__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.ABSTRACT_NAMED__NAME));
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.REGULAR_RELATIONSHIP_DEFINITION__FORWARDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.REGULAR_RELATIONSHIP_DEFINITION__FORWARDS));
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.REGULAR_RELATIONSHIP_DEFINITION__BACKWARDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.REGULAR_RELATIONSHIP_DEFINITION__BACKWARDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegularRelationshipDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRegularRelationshipDefinitionAccess().getForwardsRelationshipEndParserRuleCall_2_0(), semanticObject.getForwards());
		feeder.accept(grammarAccess.getRegularRelationshipDefinitionAccess().getBackwardsRelationshipEndParserRuleCall_4_0(), semanticObject.getBackwards());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns RelationalExp
	 *     AssignStatement.AssignStatement_1_0 returns RelationalExp
	 *     ConstExpression returns RelationalExp
	 *     Expression returns RelationalExp
	 *     StreamExpression returns RelationalExp
	 *     StreamExpression.StreamExpression_1_0 returns RelationalExp
	 *     RangeExpression returns RelationalExp
	 *     RangeExpression.RangeExpression_1_0 returns RelationalExp
	 *     LogicalOr returns RelationalExp
	 *     LogicalOr.LogicalOr_1_0 returns RelationalExp
	 *     LogicalXor returns RelationalExp
	 *     LogicalXor.LogicalXor_1_0 returns RelationalExp
	 *     LogicalAnd returns RelationalExp
	 *     LogicalAnd.LogicalAnd_1_0 returns RelationalExp
	 *     Equality returns RelationalExp
	 *     Equality.Equality_1_0 returns RelationalExp
	 *     RelationalExp returns RelationalExp
	 *     RelationalExp.RelationalExp_1_0 returns RelationalExp
	 *     AdditiveExp returns RelationalExp
	 *     AdditiveExp.AdditiveExp_1_0 returns RelationalExp
	 *     MultExp returns RelationalExp
	 *     MultExp.MultExp_1_0 returns RelationalExp
	 *     UnaryExp returns RelationalExp
	 *     LinkExpression returns RelationalExp
	 *     NavigateExpression returns RelationalExp
	 *     NavigateExpression.NavigateExpression_1_0 returns RelationalExp
	 *     ExtendedExpression returns RelationalExp
	 *     PostfixExpression returns RelationalExp
	 *     PostfixExpression.ActionCall_1_0_0 returns RelationalExp
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns RelationalExp
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns RelationalExp
	 *     PostfixExpression.IndexedExpression_1_3_0 returns RelationalExp
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns RelationalExp
	 *     PostfixNoActionCallExpression returns RelationalExp
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns RelationalExp
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns RelationalExp
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns RelationalExp
	 *     PrimaryNoActionCallExpression returns RelationalExp
	 *     PrimaryExpression returns RelationalExp
	 *     ParenthesisedExpression returns RelationalExp
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns RelationalExp
	 *
	 * Constraint:
	 *     (lhs=RelationalExp_RelationalExp_1_0 (operator='&lt;' | operator='&gt;' | operator='&lt;=' | operator='&gt;=') rhs=AdditiveExp)
	 * </pre>
	 */
	protected void sequence_RelationalExp(ISerializationContext context, RelationalExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationshipEnd returns RelationshipEnd
	 *
	 * Constraint:
	 *     (from=[ObjectDeclaration|ID] conditionality=Conditionality name=ID multiplicity=Multiplicity to=[ObjectDeclaration|ID])
	 * </pre>
	 */
	protected void sequence_RelationshipEnd(ISerializationContext context, RelationshipEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.RELATIONSHIP_END__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.RELATIONSHIP_END__FROM));
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.RELATIONSHIP_END__CONDITIONALITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.RELATIONSHIP_END__CONDITIONALITY));
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.ABSTRACT_NAMED__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.ABSTRACT_NAMED__NAME));
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.RELATIONSHIP_END__MULTIPLICITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.RELATIONSHIP_END__MULTIPLICITY));
			if (transientValues.isValueTransient(semanticObject, StructurePackage.Literals.RELATIONSHIP_END__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StructurePackage.Literals.RELATIONSHIP_END__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationshipEndAccess().getFromObjectDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.eGet(StructurePackage.Literals.RELATIONSHIP_END__FROM, false));
		feeder.accept(grammarAccess.getRelationshipEndAccess().getConditionalityConditionalityEnumRuleCall_1_0(), semanticObject.getConditionality());
		feeder.accept(grammarAccess.getRelationshipEndAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRelationshipEndAccess().getMultiplicityMultiplicityEnumRuleCall_3_0(), semanticObject.getMultiplicity());
		feeder.accept(grammarAccess.getRelationshipEndAccess().getToObjectDeclarationIDTerminalRuleCall_4_0_1(), semanticObject.eGet(StructurePackage.Literals.RELATIONSHIP_END__TO, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationshipNavigation returns RelationshipNavigation
	 *
	 * Constraint:
	 *     (relationship=[RelationshipDefinition|ScopedName] (objectOrRole=[ObjectOrRole|ID] | objectOrRole=[ObjectOrRole|ObjectOrRoleName])?)
	 * </pre>
	 */
	protected void sequence_RelationshipNavigation(ISerializationContext context, RelationshipNavigation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     value=Expression
	 * </pre>
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.RETURN_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.RETURN_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScheduleStatement returns ScheduleStatement
	 *
	 * Constraint:
	 *     (timerId=Expression generateStatement=GenerateStatement type=ScheduleType time=Expression period=Expression?)
	 * </pre>
	 */
	protected void sequence_ScheduleStatement(ISerializationContext context, ScheduleStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeReferenceWithRange returns SequenceTypeReference
	 *     AbstractTypeDefinition returns SequenceTypeReference
	 *     AbstractTypeReference returns SequenceTypeReference
	 *     AbstractTypeReferenceWithCA returns SequenceTypeReference
	 *     AbstractCollectionTypeReference returns SequenceTypeReference
	 *     SequenceTypeReference returns SequenceTypeReference
	 *     AssignStatement returns SequenceTypeReference
	 *     AssignStatement.AssignStatement_1_0 returns SequenceTypeReference
	 *     ConstExpression returns SequenceTypeReference
	 *     Expression returns SequenceTypeReference
	 *     StreamExpression returns SequenceTypeReference
	 *     StreamExpression.StreamExpression_1_0 returns SequenceTypeReference
	 *     RangeExpression returns SequenceTypeReference
	 *     RangeExpression.RangeExpression_1_0 returns SequenceTypeReference
	 *     LogicalOr returns SequenceTypeReference
	 *     LogicalOr.LogicalOr_1_0 returns SequenceTypeReference
	 *     LogicalXor returns SequenceTypeReference
	 *     LogicalXor.LogicalXor_1_0 returns SequenceTypeReference
	 *     LogicalAnd returns SequenceTypeReference
	 *     LogicalAnd.LogicalAnd_1_0 returns SequenceTypeReference
	 *     Equality returns SequenceTypeReference
	 *     Equality.Equality_1_0 returns SequenceTypeReference
	 *     RelationalExp returns SequenceTypeReference
	 *     RelationalExp.RelationalExp_1_0 returns SequenceTypeReference
	 *     AdditiveExp returns SequenceTypeReference
	 *     AdditiveExp.AdditiveExp_1_0 returns SequenceTypeReference
	 *     MultExp returns SequenceTypeReference
	 *     MultExp.MultExp_1_0 returns SequenceTypeReference
	 *     UnaryExp returns SequenceTypeReference
	 *     LinkExpression returns SequenceTypeReference
	 *     NavigateExpression returns SequenceTypeReference
	 *     NavigateExpression.NavigateExpression_1_0 returns SequenceTypeReference
	 *     ExtendedExpression returns SequenceTypeReference
	 *     PostfixExpression returns SequenceTypeReference
	 *     PostfixExpression.ActionCall_1_0_0 returns SequenceTypeReference
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns SequenceTypeReference
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns SequenceTypeReference
	 *     PostfixExpression.IndexedExpression_1_3_0 returns SequenceTypeReference
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns SequenceTypeReference
	 *     PostfixNoActionCallExpression returns SequenceTypeReference
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns SequenceTypeReference
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns SequenceTypeReference
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns SequenceTypeReference
	 *     PrimaryNoActionCallExpression returns SequenceTypeReference
	 *     PrimaryExpression returns SequenceTypeReference
	 *     TypeNameExpression returns SequenceTypeReference
	 *     ParenthesisedExpression returns SequenceTypeReference
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns SequenceTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? expression=Expression? elementType=AbstractTypeReference)
	 * </pre>
	 */
	protected void sequence_SequenceTypeReference(ISerializationContext context, SequenceTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeReferenceWithRange returns SetTypeReference
	 *     AbstractTypeDefinition returns SetTypeReference
	 *     AbstractTypeReference returns SetTypeReference
	 *     AbstractTypeReferenceWithCA returns SetTypeReference
	 *     AbstractCollectionTypeReference returns SetTypeReference
	 *     SetTypeReference returns SetTypeReference
	 *     AssignStatement returns SetTypeReference
	 *     AssignStatement.AssignStatement_1_0 returns SetTypeReference
	 *     ConstExpression returns SetTypeReference
	 *     Expression returns SetTypeReference
	 *     StreamExpression returns SetTypeReference
	 *     StreamExpression.StreamExpression_1_0 returns SetTypeReference
	 *     RangeExpression returns SetTypeReference
	 *     RangeExpression.RangeExpression_1_0 returns SetTypeReference
	 *     LogicalOr returns SetTypeReference
	 *     LogicalOr.LogicalOr_1_0 returns SetTypeReference
	 *     LogicalXor returns SetTypeReference
	 *     LogicalXor.LogicalXor_1_0 returns SetTypeReference
	 *     LogicalAnd returns SetTypeReference
	 *     LogicalAnd.LogicalAnd_1_0 returns SetTypeReference
	 *     Equality returns SetTypeReference
	 *     Equality.Equality_1_0 returns SetTypeReference
	 *     RelationalExp returns SetTypeReference
	 *     RelationalExp.RelationalExp_1_0 returns SetTypeReference
	 *     AdditiveExp returns SetTypeReference
	 *     AdditiveExp.AdditiveExp_1_0 returns SetTypeReference
	 *     MultExp returns SetTypeReference
	 *     MultExp.MultExp_1_0 returns SetTypeReference
	 *     UnaryExp returns SetTypeReference
	 *     LinkExpression returns SetTypeReference
	 *     NavigateExpression returns SetTypeReference
	 *     NavigateExpression.NavigateExpression_1_0 returns SetTypeReference
	 *     ExtendedExpression returns SetTypeReference
	 *     PostfixExpression returns SetTypeReference
	 *     PostfixExpression.ActionCall_1_0_0 returns SetTypeReference
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns SetTypeReference
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns SetTypeReference
	 *     PostfixExpression.IndexedExpression_1_3_0 returns SetTypeReference
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns SetTypeReference
	 *     PostfixNoActionCallExpression returns SetTypeReference
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns SetTypeReference
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns SetTypeReference
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns SetTypeReference
	 *     PrimaryNoActionCallExpression returns SetTypeReference
	 *     PrimaryExpression returns SetTypeReference
	 *     TypeNameExpression returns SetTypeReference
	 *     ParenthesisedExpression returns SetTypeReference
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns SetTypeReference
	 *
	 * Constraint:
	 *     (anonymous?='anonymous'? elementType=AbstractTypeReference)
	 * </pre>
	 */
	protected void sequence_SetTypeReference(ISerializationContext context, SetTypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleFeatureCall returns SimpleFeatureCall
	 *
	 * Constraint:
	 *     feature=[AbstractFeature|ScopedName]
	 * </pre>
	 */
	protected void sequence_SimpleFeatureCall(ISerializationContext context, SimpleFeatureCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleFeatureCallAccess().getFeatureAbstractFeatureScopedNameParserRuleCall_0_1(), semanticObject.eGet(BehaviorPackage.Literals.FEATURE_CALL__FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SortOrderComponent returns SortOrderComponent
	 *
	 * Constraint:
	 *     (reverse?='reverse'? feature=SortOrderFeature)
	 * </pre>
	 */
	protected void sequence_SortOrderComponent(ISerializationContext context, SortOrderComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SortOrderFeature returns SimpleFeatureCall
	 *     SortOrderFeature.SimpleFeatureCall_2_0 returns SimpleFeatureCall
	 *
	 * Constraint:
	 *     (receiver=SortOrderFeature_SimpleFeatureCall_2_0 feature=[AbstractFeature|ID])
	 * </pre>
	 */
	protected void sequence_SortOrderFeature(ISerializationContext context, SimpleFeatureCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__RECEIVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__RECEIVER));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSortOrderFeatureAccess().getSimpleFeatureCallReceiverAction_2_0(), semanticObject.getReceiver());
		feeder.accept(grammarAccess.getSortOrderFeatureAccess().getFeatureAbstractFeatureIDTerminalRuleCall_2_2_0_1(), semanticObject.eGet(BehaviorPackage.Literals.FEATURE_CALL__FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SortOrderFeature returns SortOrderFeature
	 *     SortOrderFeature.SimpleFeatureCall_2_0 returns SortOrderFeature
	 *
	 * Constraint:
	 *     feature=[AbstractFeature|ID]
	 * </pre>
	 */
	protected void sequence_SortOrderFeature(ISerializationContext context, SortOrderFeature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.FEATURE_CALL__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSortOrderFeatureAccess().getFeatureAbstractFeatureIDTerminalRuleCall_1_0_1(), semanticObject.eGet(BehaviorPackage.Literals.FEATURE_CALL__FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SortOrder returns SortOrder
	 *
	 * Constraint:
	 *     (components+=SortOrderComponent components+=SortOrderComponent*)?
	 * </pre>
	 */
	protected void sequence_SortOrder(ISerializationContext context, SortOrder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns StreamExpression
	 *     AssignStatement.AssignStatement_1_0 returns StreamExpression
	 *     ConstExpression returns StreamExpression
	 *     Expression returns StreamExpression
	 *     StreamExpression returns StreamExpression
	 *     StreamExpression.StreamExpression_1_0 returns StreamExpression
	 *     RangeExpression returns StreamExpression
	 *     RangeExpression.RangeExpression_1_0 returns StreamExpression
	 *     LogicalOr returns StreamExpression
	 *     LogicalOr.LogicalOr_1_0 returns StreamExpression
	 *     LogicalXor returns StreamExpression
	 *     LogicalXor.LogicalXor_1_0 returns StreamExpression
	 *     LogicalAnd returns StreamExpression
	 *     LogicalAnd.LogicalAnd_1_0 returns StreamExpression
	 *     Equality returns StreamExpression
	 *     Equality.Equality_1_0 returns StreamExpression
	 *     RelationalExp returns StreamExpression
	 *     RelationalExp.RelationalExp_1_0 returns StreamExpression
	 *     AdditiveExp returns StreamExpression
	 *     AdditiveExp.AdditiveExp_1_0 returns StreamExpression
	 *     MultExp returns StreamExpression
	 *     MultExp.MultExp_1_0 returns StreamExpression
	 *     UnaryExp returns StreamExpression
	 *     LinkExpression returns StreamExpression
	 *     NavigateExpression returns StreamExpression
	 *     NavigateExpression.NavigateExpression_1_0 returns StreamExpression
	 *     ExtendedExpression returns StreamExpression
	 *     PostfixExpression returns StreamExpression
	 *     PostfixExpression.ActionCall_1_0_0 returns StreamExpression
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns StreamExpression
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns StreamExpression
	 *     PostfixExpression.IndexedExpression_1_3_0 returns StreamExpression
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns StreamExpression
	 *     PostfixNoActionCallExpression returns StreamExpression
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns StreamExpression
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns StreamExpression
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns StreamExpression
	 *     PrimaryNoActionCallExpression returns StreamExpression
	 *     PrimaryExpression returns StreamExpression
	 *     ParenthesisedExpression returns StreamExpression
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns StreamExpression
	 *
	 * Constraint:
	 *     (lhs=StreamExpression_StreamExpression_1_0 operator=StreamOperator rhs=RangeExpression)
	 * </pre>
	 */
	protected void sequence_StreamExpression(ISerializationContext context, StreamExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.STREAM_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.STREAM_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.STREAM_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.STREAM_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.STREAM_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.STREAM_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStreamExpressionAccess().getStreamExpressionLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getStreamExpressionAccess().getOperatorStreamOperatorParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getStreamExpressionAccess().getRhsRangeExpressionParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns StringLiteral
	 *     AssignStatement.AssignStatement_1_0 returns StringLiteral
	 *     ConstExpression returns StringLiteral
	 *     Expression returns StringLiteral
	 *     StreamExpression returns StringLiteral
	 *     StreamExpression.StreamExpression_1_0 returns StringLiteral
	 *     RangeExpression returns StringLiteral
	 *     RangeExpression.RangeExpression_1_0 returns StringLiteral
	 *     LogicalOr returns StringLiteral
	 *     LogicalOr.LogicalOr_1_0 returns StringLiteral
	 *     LogicalXor returns StringLiteral
	 *     LogicalXor.LogicalXor_1_0 returns StringLiteral
	 *     LogicalAnd returns StringLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns StringLiteral
	 *     Equality returns StringLiteral
	 *     Equality.Equality_1_0 returns StringLiteral
	 *     RelationalExp returns StringLiteral
	 *     RelationalExp.RelationalExp_1_0 returns StringLiteral
	 *     AdditiveExp returns StringLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns StringLiteral
	 *     MultExp returns StringLiteral
	 *     MultExp.MultExp_1_0 returns StringLiteral
	 *     UnaryExp returns StringLiteral
	 *     LinkExpression returns StringLiteral
	 *     NavigateExpression returns StringLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns StringLiteral
	 *     ExtendedExpression returns StringLiteral
	 *     PostfixExpression returns StringLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns StringLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns StringLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns StringLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns StringLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns StringLiteral
	 *     PostfixNoActionCallExpression returns StringLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns StringLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns StringLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns StringLiteral
	 *     PrimaryNoActionCallExpression returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     ParenthesisedExpression returns StringLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeDefinition returns StructureTypeDefinition
	 *     StructureTypeDefinition returns StructureTypeDefinition
	 *
	 * Constraint:
	 *     components+=StructureComponentDefinition*
	 * </pre>
	 */
	protected void sequence_StructureTypeDefinition(ISerializationContext context, StructureTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubtypeRelationshipDefinition returns SubtypeRelationshipDefinition
	 *
	 * Constraint:
	 *     (name=ID supertype=[ObjectDeclaration|ID] (subtypes+=[ObjectDeclaration|ID] subtypes+=[ObjectDeclaration|ID]*)?)
	 * </pre>
	 */
	protected void sequence_SubtypeRelationshipDefinition(ISerializationContext context, SubtypeRelationshipDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns ThisLiteral
	 *     AssignStatement.AssignStatement_1_0 returns ThisLiteral
	 *     ConstExpression returns ThisLiteral
	 *     Expression returns ThisLiteral
	 *     StreamExpression returns ThisLiteral
	 *     StreamExpression.StreamExpression_1_0 returns ThisLiteral
	 *     RangeExpression returns ThisLiteral
	 *     RangeExpression.RangeExpression_1_0 returns ThisLiteral
	 *     LogicalOr returns ThisLiteral
	 *     LogicalOr.LogicalOr_1_0 returns ThisLiteral
	 *     LogicalXor returns ThisLiteral
	 *     LogicalXor.LogicalXor_1_0 returns ThisLiteral
	 *     LogicalAnd returns ThisLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns ThisLiteral
	 *     Equality returns ThisLiteral
	 *     Equality.Equality_1_0 returns ThisLiteral
	 *     RelationalExp returns ThisLiteral
	 *     RelationalExp.RelationalExp_1_0 returns ThisLiteral
	 *     AdditiveExp returns ThisLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns ThisLiteral
	 *     MultExp returns ThisLiteral
	 *     MultExp.MultExp_1_0 returns ThisLiteral
	 *     UnaryExp returns ThisLiteral
	 *     LinkExpression returns ThisLiteral
	 *     NavigateExpression returns ThisLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns ThisLiteral
	 *     ExtendedExpression returns ThisLiteral
	 *     PostfixExpression returns ThisLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns ThisLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns ThisLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns ThisLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns ThisLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns ThisLiteral
	 *     PostfixNoActionCallExpression returns ThisLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns ThisLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns ThisLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns ThisLiteral
	 *     PrimaryNoActionCallExpression returns ThisLiteral
	 *     PrimaryExpression returns ThisLiteral
	 *     ParenthesisedExpression returns ThisLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns ThisLiteral
	 *     Literal returns ThisLiteral
	 *     ThisLiteral returns ThisLiteral
	 *
	 * Constraint:
	 *     {ThisLiteral}
	 * </pre>
	 */
	protected void sequence_ThisLiteral(ISerializationContext context, ThisLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns TimestampLiteral
	 *     AssignStatement.AssignStatement_1_0 returns TimestampLiteral
	 *     ConstExpression returns TimestampLiteral
	 *     Expression returns TimestampLiteral
	 *     StreamExpression returns TimestampLiteral
	 *     StreamExpression.StreamExpression_1_0 returns TimestampLiteral
	 *     RangeExpression returns TimestampLiteral
	 *     RangeExpression.RangeExpression_1_0 returns TimestampLiteral
	 *     LogicalOr returns TimestampLiteral
	 *     LogicalOr.LogicalOr_1_0 returns TimestampLiteral
	 *     LogicalXor returns TimestampLiteral
	 *     LogicalXor.LogicalXor_1_0 returns TimestampLiteral
	 *     LogicalAnd returns TimestampLiteral
	 *     LogicalAnd.LogicalAnd_1_0 returns TimestampLiteral
	 *     Equality returns TimestampLiteral
	 *     Equality.Equality_1_0 returns TimestampLiteral
	 *     RelationalExp returns TimestampLiteral
	 *     RelationalExp.RelationalExp_1_0 returns TimestampLiteral
	 *     AdditiveExp returns TimestampLiteral
	 *     AdditiveExp.AdditiveExp_1_0 returns TimestampLiteral
	 *     MultExp returns TimestampLiteral
	 *     MultExp.MultExp_1_0 returns TimestampLiteral
	 *     UnaryExp returns TimestampLiteral
	 *     LinkExpression returns TimestampLiteral
	 *     NavigateExpression returns TimestampLiteral
	 *     NavigateExpression.NavigateExpression_1_0 returns TimestampLiteral
	 *     ExtendedExpression returns TimestampLiteral
	 *     PostfixExpression returns TimestampLiteral
	 *     PostfixExpression.ActionCall_1_0_0 returns TimestampLiteral
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns TimestampLiteral
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns TimestampLiteral
	 *     PostfixExpression.IndexedExpression_1_3_0 returns TimestampLiteral
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns TimestampLiteral
	 *     PostfixNoActionCallExpression returns TimestampLiteral
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns TimestampLiteral
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns TimestampLiteral
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns TimestampLiteral
	 *     PrimaryNoActionCallExpression returns TimestampLiteral
	 *     PrimaryExpression returns TimestampLiteral
	 *     ParenthesisedExpression returns TimestampLiteral
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns TimestampLiteral
	 *     Literal returns TimestampLiteral
	 *     TimestampLiteral returns TimestampLiteral
	 *
	 * Constraint:
	 *     value=TIMESTAMP
	 * </pre>
	 */
	protected void sequence_TimestampLiteral(ISerializationContext context, TimestampLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.TIMESTAMP_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.TIMESTAMP_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimestampLiteralAccess().getValueTIMESTAMPTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TransitionOption returns TransitionOption
	 *
	 * Constraint:
	 *     (
	 *         eventObject=[ObjectDefinition|ID]? 
	 *         event=[EventDefinition|ID] 
	 *         (endState=[StateDeclaration|ID] | ignore?='Ignore' | cannotHappen?='Cannot_Happen' | cannotHappen?='cannot_happen')
	 *     )
	 * </pre>
	 */
	protected void sequence_TransitionOption(ISerializationContext context, TransitionOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeParameter returns TypeParameter
	 *
	 * Constraint:
	 *     (enum?='enum'? name=ID)
	 * </pre>
	 */
	protected void sequence_TypeParameter(ISerializationContext context, TypeParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssignStatement returns UnaryExp
	 *     AssignStatement.AssignStatement_1_0 returns UnaryExp
	 *     ConstExpression returns UnaryExp
	 *     Expression returns UnaryExp
	 *     StreamExpression returns UnaryExp
	 *     StreamExpression.StreamExpression_1_0 returns UnaryExp
	 *     RangeExpression returns UnaryExp
	 *     RangeExpression.RangeExpression_1_0 returns UnaryExp
	 *     LogicalOr returns UnaryExp
	 *     LogicalOr.LogicalOr_1_0 returns UnaryExp
	 *     LogicalXor returns UnaryExp
	 *     LogicalXor.LogicalXor_1_0 returns UnaryExp
	 *     LogicalAnd returns UnaryExp
	 *     LogicalAnd.LogicalAnd_1_0 returns UnaryExp
	 *     Equality returns UnaryExp
	 *     Equality.Equality_1_0 returns UnaryExp
	 *     RelationalExp returns UnaryExp
	 *     RelationalExp.RelationalExp_1_0 returns UnaryExp
	 *     AdditiveExp returns UnaryExp
	 *     AdditiveExp.AdditiveExp_1_0 returns UnaryExp
	 *     MultExp returns UnaryExp
	 *     MultExp.MultExp_1_0 returns UnaryExp
	 *     UnaryExp returns UnaryExp
	 *     LinkExpression returns UnaryExp
	 *     NavigateExpression returns UnaryExp
	 *     NavigateExpression.NavigateExpression_1_0 returns UnaryExp
	 *     ExtendedExpression returns UnaryExp
	 *     PostfixExpression returns UnaryExp
	 *     PostfixExpression.ActionCall_1_0_0 returns UnaryExp
	 *     PostfixExpression.SimpleFeatureCall_1_1_0 returns UnaryExp
	 *     PostfixExpression.TerminatorActionCall_1_2_0 returns UnaryExp
	 *     PostfixExpression.IndexedExpression_1_3_0 returns UnaryExp
	 *     PostfixExpression.CharacteristicCall_1_4_0 returns UnaryExp
	 *     PostfixNoActionCallExpression returns UnaryExp
	 *     PostfixNoActionCallExpression.SimpleFeatureCall_1_0_0 returns UnaryExp
	 *     PostfixNoActionCallExpression.IndexedExpression_1_1_0 returns UnaryExp
	 *     PostfixNoActionCallExpression.CharacteristicCall_1_2_0 returns UnaryExp
	 *     PrimaryNoActionCallExpression returns UnaryExp
	 *     PrimaryExpression returns UnaryExp
	 *     ParenthesisedExpression returns UnaryExp
	 *     ParenthesisedExpression.StructureAggregateExpression_2_0 returns UnaryExp
	 *
	 * Constraint:
	 *     (operator=UnaryOperator operand=UnaryExp)
	 * </pre>
	 */
	protected void sequence_UnaryExp(ISerializationContext context, UnaryExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.UNARY_EXP__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.UNARY_EXP__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.UNARY_EXP__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.UNARY_EXP__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpAccess().getOperatorUnaryOperatorParserRuleCall_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getUnaryExpAccess().getOperandUnaryExpParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractTypeDefinition returns UnconstrainedArrayDefinition
	 *     UnconstrainedArrayDefinition returns UnconstrainedArrayDefinition
	 *
	 * Constraint:
	 *     (indexType=NamedTypeReference elementType=AbstractTypeReference)
	 * </pre>
	 */
	protected void sequence_UnconstrainedArrayDefinition(ISerializationContext context, UnconstrainedArrayDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.UNCONSTRAINED_ARRAY_DEFINITION__INDEX_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.UNCONSTRAINED_ARRAY_DEFINITION__INDEX_TYPE));
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.UNCONSTRAINED_ARRAY_DEFINITION__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.UNCONSTRAINED_ARRAY_DEFINITION__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnconstrainedArrayDefinitionAccess().getIndexTypeNamedTypeReferenceParserRuleCall_2_0(), semanticObject.getIndexType());
		feeder.accept(grammarAccess.getUnconstrainedArrayDefinitionAccess().getElementTypeAbstractTypeReferenceParserRuleCall_7_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
