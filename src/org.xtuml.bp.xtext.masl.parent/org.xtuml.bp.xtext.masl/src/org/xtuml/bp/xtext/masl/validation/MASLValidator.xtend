/*
 * generated by Xtext 2.9.2
 */
package org.xtuml.bp.xtext.masl.validation

import com.google.inject.Inject
import java.util.HashSet
import java.util.Set
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.ComposedChecks
import org.xtuml.bp.xtext.masl.masl.behavior.ReturnStatement
import org.xtuml.bp.xtext.masl.masl.behavior.StatementList
import org.xtuml.bp.xtext.masl.masl.behavior.ThisLiteral
import org.xtuml.bp.xtext.masl.masl.structure.AbstractTopLevelElement
import org.xtuml.bp.xtext.masl.masl.structure.DomainDefinition
import org.xtuml.bp.xtext.masl.masl.structure.ObjectDeclaration
import org.xtuml.bp.xtext.masl.masl.structure.StateDefinition
import org.xtuml.bp.xtext.masl.masl.structure.StructurePackage
import org.xtuml.bp.xtext.masl.masl.structure.SubtypeRelationshipDefinition

import static org.xtuml.bp.xtext.masl.validation.MaslIssueCodesProvider.*

import static extension org.eclipse.xtext.EcoreUtil2.*
import org.xtuml.bp.xtext.masl.masl.structure.ObjectServiceDefinition

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@ComposedChecks(validators=#[TypeValidator, NameValidator, StructureValidator])
class MASLValidator extends AbstractMASLValidator {

	@Inject extension StructurePackage structurePackage
	
	@Check
	def inheritanceCycle(ObjectDeclaration it) {
		if(findInheritanceCycle(newHashSet)) {
			addIssue('Object has a cycle in its supertype hierarchy', it, structurePackage.abstractNamed_Name, CYCLIC_INHERITANCE)
		}
	}
	
	private def boolean findInheritanceCycle(ObjectDeclaration object,
		Set<ObjectDeclaration> seenSubtypes) {
		if (!seenSubtypes.add(object))
			return true
		val domain = object.eContainer as DomainDefinition
		domain.relationships.filter(SubtypeRelationshipDefinition).filter[subtypes.contains(object)].map [
			supertype
		].exists [
			findInheritanceCycle(new HashSet(seenSubtypes))
		]
	}
	
	@Check 
	def checkThis(ThisLiteral it) {
		val topLevelElement = getContainerOfType(AbstractTopLevelElement)
		switch topLevelElement {
			ObjectServiceDefinition: 
				if(!topLevelElement.isInstance)
					addIssue("'this' is only allowed in instance services", it, null, INVALID_THIS)	
			StateDefinition: { 
				// noop
			}
			default: 
				addIssue("'this' is only allowed in " + topLevelElement.eClass.name, it, null, INVALID_THIS)				
		}
	}
	
	@Check
	def checkReturnIsLastStatement(ReturnStatement it) {
		val parent = eContainer 
		if(parent instanceof StatementList) {
			val siblings = parent.statements
			val index = siblings.indexOf(it)
			if(index < siblings.size()-1) {
				addIssue('Unreachable code', parent.statements.get(index + 1), null, UNREACHABLE_CODE) 
			}
			
		}
	}
}

