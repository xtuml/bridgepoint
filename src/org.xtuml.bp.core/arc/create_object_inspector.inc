.//========================================================================
.//
.//File:      $RCSfile: create_object_inspector.inc,v $
.//Version:   $Revision: 1.23 $
.//Modified:  $Date: 2013/01/17 03:38:58 $
.//
.//Copyright 2004-2014 by Mentor Graphics Corporation. All rights reserved.
.//
.//========================================================================
.// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
.// use this file except in compliance with the License.  You may obtain a copy 
.// of the License at
.//
.//       http://www.apache.org/licenses/LICENSE-2.0
.//
.// Unless required by applicable law or agreed to in writing, software 
.// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
.// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the 
.// License for the specific language governing permissions and limitations under
.// the License.
.//========================================================================
.//
.// This file is responsible for creating the adapters that provide the 
.// traversal support over the meta-model
.// 
.function create_object_inspector
  .param inst_ref tree_node
  .param string node_name
  .param string path
  .param string adapter_interface_name
  .param string model_element_class_name
  .param string initial_package
  .//
  .assign inspector_name = "${node_name}Inspector"
  .assign attr_result = inspector_name
  .select any this_class from instances of O_OBJ where (selected.Key_Lett == tree_node.Key_Lett)
  .invoke result = get_class_name(this_class)
  .assign this_class_name = "${result.body}"
//======================================================================
//
// File: ${path}/inspector/${inspector_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      $$Revision: 1.23 $$
//
// (c) Copyright 2004-2014 by Mentor Graphics Corp.  All rights reserved.
//
//======================================================================
//
// This class is responsible for decoupling the client model entity
// class ${this_class_name} from the traversal mechanisms that it provides to
// model diff.
//
import ${initial_package}.*;

import org.eclipse.swt.graphics.Image;

.if(initial_package != "org.xtuml.bp.core")
import org.xtuml.bp.core.CorePlugin;
import org.xtuml.bp.core.inspector.*;
.end if
import org.xtuml.bp.core.sorter.MetadataSortingManager;
import java.util.*;

/**
 * This file adapts the meta-model entity; '${this_class_name}' to provide 
 * support of traversing to its children and parents.
 * <p>
 * Do not edit this class, it was created using the Mentor Graphics
 * MC-Java code generator product.
 * </p>
 */
public class ${inspector_name} extends BaseModelClassInspector {

  private String parentAssoc;
  
  public ${inspector_name}(MetadataSortingManager sortingManager){
    super(sortingManager);
  }

  /**
   * @see ${adapter_interface_name}#getParent(Object)
   * Returns the parent(s) of this node
   */
  public Object getParent(Object arg) {
    .select many specs related by tree_node->T_TPS[R1001]
    .if (not_empty specs)
        .assign resultInd = 1
        .for each spec in specs
            .if ((spec.NameOnly == "") or (spec.UseNameOnlyForUniqueness))
                .select one parent related by spec->T_TNS[R1000]
                .assign result_obj_name = "result" 
                .assign result_obj_name = result_obj_name + "${resultInd}"
                .invoke rel_nav = generate_forward_rel_chain_nav( spec.ParentChildRelChain, parent.Key_Lett, this_class_name, "arg", result_obj_name )       
${rel_nav.body} \
    if (${result_obj_name} != null) {
        return ${result_obj_name};
    }               
                .assign resultInd = resultInd + 1;
            .end if
        .end for    
        return null;    //No parent found           
    .else
        return null;
    .end if
  }
  	  
  /**
   * @see ${adapter_interface_name}#getChildRelations(Object)
   * Returns the children of this node
   */
  public ${model_element_class_name}[] getChildRelations(Object arg) {
    int resultSize = 0;
  .//
  .// We need to return a set of instances for each item that is specified
  .// as a child of the element represented by this adapter.
  .//
  .select many child_specs related by tree_node->T_TPS[R1000] where (selected.Prev_TPS_ID == 0)
  .select any first_spec related by tree_node->T_TPS[R1000] where (selected.Prev_TPS_ID == -1)
  .while(not_empty first_spec)
    .assign child_specs = child_specs | first_spec
    .select one first_spec related by first_spec->T_TPS[R1003.'succeeds']
  .end while
  .assign specCount = 0
  .for each spec in child_specs
    .if ((spec.NameOnly == "") or (spec.UseNameOnlyForUniqueness))
        .assign specCount = specCount + 1
        .select one child related by spec->T_TNS[R1001]
        .assign child_var_name_extra = ""
        .if(spec.UseNameOnlyForUniqueness)
          .assign child_var_name_extra = "$r{spec.NameOnly}"
        .end if
      .assign child_var_name = "v_$lr{child.CategoryName}${child_var_name_extra}"
        .invoke rel_nav = generate_backward_rel_chain_nav_load(tree_node, spec.ParentChildRelChain, "many", "arg", child_var_name, ", load")
${rel_nav.body}\
    sort(${child_var_name});
    .end if
  .end for
    List<${model_element_class_name}> result = new ArrayList<${model_element_class_name}> ();
  .if (specCount != 0)
    .for each spec in child_specs
        .if ((spec.NameOnly == "") or (spec.UseNameOnlyForUniqueness))
            .select one child related by spec->T_TNS[R1001]
            .assign child_var_name_extra = ""
        .if(spec.UseNameOnlyForUniqueness)
            .assign child_var_name_extra = "$r{spec.NameOnly}"
          .end if
        .assign child_var_name = "v_$lr{child.CategoryName}${child_var_name_extra}"
    for (int i = 0 ; i < ${child_var_name}.length ; i++) {   
          .if(spec.filterLogic != "")
      if(!${spec.filterLogic}) {
          .end if
        result.add(new ${model_element_class_name}("${child_var_name}", ${model_element_class_name}.RELATION_ROLE_ELEMENT, ${child_var_name}[i], arg, $l{spec.UserModifiable}));
          .if(spec.filterLogic != "")
      }
          .end if
    }
        .end if
    .end for
  .end if
    return result.toArray(new ${model_element_class_name}[result.size()]);
  }
  /**
   * @see ${adapter_interface_name}#hasChildren(Object)
   * Returns true if this node has any children
   */
  public boolean hasChildRelations(Object arg) {
  .for each spec in child_specs
    .select one child related by spec->T_TNS[R1001]
    .assign child_var_name_extra = ""
    .if(spec.UseNameOnlyForUniqueness)
      .assign child_var_name_extra = "$r{spec.NameOnly}"
      .end if
    .assign child_var_name = "v_$lr{child.CategoryName}${child_var_name_extra}"
    .if ((spec.NameOnly == "") or (spec.UseNameOnlyForUniqueness))
        .invoke rel_nav = generate_backward_rel_chain_nav(tree_node, spec.ParentChildRelChain, "many", "arg", child_var_name)
${rel_nav.body}\
    if (${child_var_name}.length > 0) return true;
    .end if
  .end for
    return false;
  }
  
  public Object[] getReferentialDetails(Class<?> referentialClass, Object arg) {
  	Object[] details = new Object[4];
  .select any class from instances of O_OBJ where (selected.Key_Lett == tree_node.Key_Lett)
  .select many child_specs related by tree_node->T_TPS[R1000]
  .assign count = 0
  .for each spec in child_specs
    .if((spec.NameOnly != "") and (not spec.UseNameOnlyForUniqueness))
      .select one das related by spec->T_DAS[R1004]
      .assign parent_child_chain = spec.ParentChildRelChain
      .select one parent related by spec->T_TNS[R1000]
      .select one child related by spec->T_TNS[R1001]
      .assign parent_key_lett = parent.Key_Lett
      .assign referring = "arg"
      .assign child_key_lett = child.Key_Lett
      .assign parent_key_lett = parent.Key_Lett
      .if(not_empty das)
        .assign child_chain = das.data_child_chain
        .assign parent_child_chain = das.data_parent_chain
        .assign parent_key_lett = das.parent_key_lett
        .assign child_key_lett = das.child_key_lett
        .if(child_chain != "")
          .if(child_chain != "self")
            .invoke rel_nav = generate_forward_rel_chain_nav( child_chain, das.child_key_lett, this_class_name, "arg", "" )
            .assign referring = rel_nav.body
          .end if                    
        .end if
      .end if
      .select any childObj from instances of O_OBJ where (selected.Key_Lett == child_key_lett)
      .invoke ccn = get_class_name(childObj)
      .assign child_class_name = ccn.body
      .invoke parse = parse_chain(parent_child_chain, "forward");
      .select any parentObj from instances of O_OBJ where (selected.Key_Lett == parent_key_lett)
      .invoke pcn = get_class_name(parentObj)
      .assign parent_class_name = pcn.body
      .assign key_lett = parent_key_lett
      .invoke rel_nav = generate_backward_rel_chain_nav( tree_node, parent_child_chain, "one", "arg", "" )
      .invoke backward_parse = parse_chain(parent_child_chain, "backward")
      .if(backward_parse.remainder != "")
        .invoke backward_rel_nav = generate_backward_rel_chain_nav(tree_node, backward_parse.remainder, "one", "arg", "")
        .assign referring = backward_rel_nav.body
      .end if
      .assign rel_nav_string = rel_nav.body
      .assign rel_numb = backward_parse.rel_num_str
      .assign rel_phrase = backward_parse.phrase
	if(details[0] == null && referentialClass == ${child_class_name}.class) {
		details[0] = ${rel_nav_string};
		details[1] = arg;
		details[2] = "${rel_numb}";
		details[3] = "${rel_phrase}";
	}
    .end if	  
  .end for
	return details;
  }
  
  /**
  * @seee ${adapter_interface_name}#getReferentials(Object)
  * Returns the an array of Role Objects specifying the referenctial attibutes of
  * this model element
  * Role Name: <T_TPS.NameOnly>
  * Role Value: <Chain_result>
  * Role Type: "Referential"
  */
  public ${model_element_class_name}[] getReferentials(Object arg) {
    .//
    .// We need to return a set of instances for each item that is specified
    .// as a child of the element represented by this adapter.
    .//
  .select any class from instances of O_OBJ where (selected.Key_Lett == tree_node.Key_Lett)
  .select many child_specs related by tree_node->T_TPS[R1000]
     List<${model_element_class_name}> referentials = new ArrayList<${model_element_class_name}>();
  .assign count = 0
  .for each spec in child_specs
    .if((spec.NameOnly != "") and (not spec.UseNameOnlyForUniqueness))
        .assign count = count + 1
        .//
        .select one child related by spec->T_TNS[R1001]
        .select any start_class from instances of O_OBJ where (selected.Key_Lett == tree_node.Key_Lett)
        .invoke scn = get_class_name(start_class)
        .invoke rel_nav = backward_rel_chain_nav(scn.body, "arg", spec.ParentChildRelChain, "one", true)
        .//
        .if(count == 1)
        Object referential = ${rel_nav.body};
        .else
        referential = ${rel_nav.body};
        .end if
        .if(spec.filterLogic != "")
    if(!${spec.filterLogic}) {
        .end if
     referentials.add(new ${model_element_class_name} ("referential_$_{spec.NameOnly}", ${model_element_class_name}.REFERENTIAL_ATTRIBUTE_ELEMENT, referential, arg, $l{spec.UserModifiable}));
        .if(spec.filterLogic != "")
    }
        .end if
    .end if
  .end for
    return referentials.toArray(new ${model_element_class_name} [referentials.size()]);        
  }

  /**
  * @seee ${adapter_interface_name}#getAttributes(Object)
  * Returns the an array of Role objects that give the attibutes of the model 
  * element it self e.g.
  * Role Name: "Name"
  * Role Value: metaModelElement.getName()
  * Role Type: "Primitive"
  */
  public ${model_element_class_name}[] getAttributes(Object arg) {
  .select any class from instances of O_OBJ where (selected.Key_Lett == tree_node.Key_Lett)
  .select many attrs related by class->O_ATTR[R102]
  .select many external_attrs related by tree_node->T_EDL[R1005]->T_EA[R1006]
  .assign num_of_attr = cardinality attrs
  .assign external_attr_count = cardinality external_attrs
  .assign num_of_attr = num_of_attr + external_attr_count
    ${model_element_class_name} attrSet[] = new ${model_element_class_name}[${num_of_attr}];
  .assign original_attr_count = 0
  .for each attr in attrs
    .select one prevAttr related by attr->O_ATTR[R103.'precedes']
    .if (empty prevAttr)
        .while (not_empty attr)
            .select one dt related by attr->S_DT[R114]
            .select one rattr related by attr->O_RATTR[R106]
            .select one dbattr related by attr->O_BATTR[R106]->O_DBATTR[R107]
            .if (((dt.Name != "unique_id") and (empty rattr)) and ("$l{attr.Descrip:User_Visible}" != "false"))             
                .assign name = "${attr.Name}"
                .invoke attr_accessor = get_attribute_accessor(attr)
                .invoke class_name = get_class_name(class)
                .assign user_modifiable = "true"
                .if("$l{attr.Descrip:readonly}" == "true")
                  .assign user_modifiable = "false"
                .end if; 
      attrSet[${original_attr_count}] = new ${model_element_class_name}("${name}", ${model_element_class_name}.ATTRIBUTE_ELEMENT,  ((${class_name.body}) arg).${attr_accessor.body}(), arg, "${attr_accessor.body}", $l{user_modifiable});
                .if(not_empty dbattr)
      attrSet[${original_attr_count}].setDerived();
                .end if
                .assign original_attr_count = original_attr_count + 1
            .end if
            .select one nextAttr related by attr->O_ATTR[R103.'succeeds']
            .assign attr = nextAttr
        .end while
        .break for
    .end if
  .end for
  .// cover any external attributes
  .for each external_attr in external_attrs
    .select one edl related by external_attr->T_EDL[R1006]
    .select any external_class from instances of O_OBJ where (selected.Key_Lett == edl.Key_Lett)
    .invoke external_cn = get_class_name(external_class)
    .invoke class_name = get_class_name(class)
    .select any e_attr related by external_class->O_ATTR[R102] where (selected.Name == external_attr.Attribute_Name)
    .invoke rel_nav = backward_rel_chain_nav(external_cn.body, "(${class_name.body}) arg", edl.RelChain, "one", false)
    .assign user_modifiable = "true"
    .if("$l{e_attr.Descrip:readonly}" == "true")
      .assign user_modifiable = "false"
    .end if; 
      ${external_cn.body} ${external_attr.Attribute_Name}Owner = 
      ${rel_nav.body};
      if(${external_attr.Attribute_Name}Owner != null) {
		   attrSet[${original_attr_count}] = new ObjectElement("${external_attr.Attribute_Name}", ObjectElement.ATTRIBUTE_ELEMENT, ((${external_cn.body}) ${external_attr.Attribute_Name}Owner).get$c{external_attr.Attribute_Name}(), arg, "get$c{external_attr.Attribute_Name}", $l{user_modifiable});
		   attrSet[${original_attr_count}].setAttributeOwner(${external_attr.Attribute_Name}Owner);
  	  }
    .assign original_attr_count = original_attr_count + 1
  .end for
    ${model_element_class_name} compAttrSet[] = new ${model_element_class_name}[${original_attr_count}];    
  .if (original_attr_count > 0)     
    for (int i = 0; i < ${original_attr_count} ; i++) {
        compAttrSet[i] = attrSet[i];
    }
  .end if   
    return compAttrSet;
  }

    /**
     * Return configured image if none exists for the element type
     */
    public Image getImage(Object element) {
		Image image = CorePlugin.getImageFor(element, false);
		if(image != null) {
			return image;
		}
		return CorePlugin.getImageFor("${tree_node.Icon}");
	}
.end function
.//
.//
.//
.function create_slot_functions
  .param inst_ref tree_node
  .param boolean isOverride
  /**
  * Returns a "slot number" to be used when comparing and merging tree elements
  * that contain multiple children.  All model element inspector's contain this 
  * function, but it only returns a value for cases where it a parent element
  * in a tree and the parent has multiple children.
  * 
  * @returns 0 if this is not a "parent" in the tree OR if the parent has less 
  * than 2 children. 
  */
.if (isOverride)
	@Override
.end if
	public int getTreeDifferenceSlot(Object element) {
.select many children related by tree_node->T_TPS[R1000]->T_TNS[R1001] 
.assign num_children = cardinality children
.if (num_children > 1)
  .assign slot_count = 1;
  .for each child in children 		
    .select any class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
    .invoke cn = get_class_name(class)
    .assign class_name = cn.body
    	if (element instanceof ${class_name}) {
			return ${slot_count};
		}
    .assign slot_count = slot_count + 1;
  .end for
.end if
		return 0;
	}
.end function
.//
.//
.//
.function create_object_inspector_end
	}       
.end function
.//
